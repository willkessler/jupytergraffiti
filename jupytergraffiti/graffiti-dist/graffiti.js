// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
// https://github.com/pieroxy/lz-string/blob/master/libs/lz-string.js
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

  // private property
  var f = String.fromCharCode;
  var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
  var baseReverseDic = {};

  function getBaseValue(alphabet, character) {
    if (!baseReverseDic[alphabet]) {
      baseReverseDic[alphabet] = {};
      for (var i=0 ; i<alphabet.length ; i++) {
        baseReverseDic[alphabet][alphabet.charAt(i)] = i;
      }
    }
    return baseReverseDic[alphabet][character];
  }

  var LZString = {
    compressToBase64 : function (input) {
      if (input == null) return "";
      var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
      switch (res.length % 4) { // To produce valid Base64
        default: // When could this happen ?
        case 0 : return res;
        case 1 : return res+"===";
        case 2 : return res+"==";
        case 3 : return res+"=";
      }
    },

    decompressFromBase64 : function (input) {
      if (input == null) return "";
      if (input == "") return null;
      return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
    },

    compressToUTF16 : function (input) {
      if (input == null) return "";
      return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
    },

    decompressFromUTF16: function (compressed) {
      if (compressed == null) return "";
      if (compressed == "") return null;
      return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
    },

    //compress into uint8array (UCS-2 big endian format)
    compressToUint8Array: function (uncompressed) {
      var compressed = LZString.compress(uncompressed);
      var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

      for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
        var current_value = compressed.charCodeAt(i);
        buf[i*2] = current_value >>> 8;
        buf[i*2+1] = current_value % 256;
      }
      return buf;
    },

    //decompress from uint8array (UCS-2 big endian format)
    decompressFromUint8Array:function (compressed) {
      if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
      } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

      }

    },


    //compress into a string that is already URI encoded
    compressToEncodedURIComponent: function (input) {
      if (input == null) return "";
      return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
    },

    //decompress from an output of compressToEncodedURIComponent
    decompressFromEncodedURIComponent:function (input) {
      if (input == null) return "";
      if (input == "") return null;
      input = input.replace(/ /g, "+");
      return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
    },

    compress: function (uncompressed) {
      return LZString._compress(uncompressed, 16, function(a){return f(a);});
    },
    _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
      if (uncompressed == null) return "";
      var i, value,
          context_dictionary= {},
          context_dictionaryToCreate= {},
          context_c="",
          context_wc="",
          context_w="",
          context_enlargeIn= 2, // Compensate for the first entry which should not count
          context_dictSize= 3,
          context_numBits= 2,
          context_data=[],
          context_data_val=0,
          context_data_position=0,
          ii;

      for (ii = 0; ii < uncompressed.length; ii += 1) {
        context_c = uncompressed.charAt(ii);
        if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
          context_dictionary[context_c] = context_dictSize++;
          context_dictionaryToCreate[context_c] = true;
        }

        context_wc = context_w + context_c;
        if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
          context_w = context_wc;
        } else {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
            if (context_w.charCodeAt(0)<256) {
              for (i=0 ; i<context_numBits ; i++) {
                context_data_val = (context_data_val << 1);
                if (context_data_position == bitsPerChar-1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i=0 ; i<8 ; i++) {
                context_data_val = (context_data_val << 1) | (value&1);
                if (context_data_position == bitsPerChar-1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i=0 ; i<context_numBits ; i++) {
                context_data_val = (context_data_val << 1) | value;
                if (context_data_position ==bitsPerChar-1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i=0 ; i<16 ; i++) {
                context_data_val = (context_data_val << 1) | (value&1);
                if (context_data_position == bitsPerChar-1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }


          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          // Add wc to the dictionary.
          context_dictionary[context_wc] = context_dictSize++;
          context_w = String(context_c);
        }
      }

      // Output the code for w.
      if (context_w !== "") {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
      }

      // Mark the end of the stream
      value = 2;
      for (i=0 ; i<context_numBits ; i++) {
        context_data_val = (context_data_val << 1) | (value&1);
        if (context_data_position == bitsPerChar-1) {
          context_data_position = 0;
          context_data.push(getCharFromInt(context_data_val));
          context_data_val = 0;
        } else {
          context_data_position++;
        }
        value = value >> 1;
      }

      // Flush the last char
      while (true) {
        context_data_val = (context_data_val << 1);
        if (context_data_position == bitsPerChar-1) {
          context_data.push(getCharFromInt(context_data_val));
          break;
        }
        else context_data_position++;
      }
      return context_data.join('');
    },

    decompress: function (compressed) {
      if (compressed == null) return "";
      if (compressed == "") return null;
      return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
    },

    _decompress: function (length, resetValue, getNextValue) {
      var dictionary = [],
          next,
          enlargeIn = 4,
          dictSize = 4,
          numBits = 3,
          entry = "",
          result = [],
          i,
          w,
          bits, resb, maxpower, power,
          c,
          data = {val:getNextValue(0), position:resetValue, index:1};

      for (i = 0; i < 3; i += 1) {
        dictionary[i] = i;
      }

      bits = 0;
      maxpower = Math.pow(2,2);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (next = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 2:
          return "";
      }
      dictionary[3] = c;
      w = c;
      result.push(c);
      while (true) {
        if (data.index > length) {
          return "";
        }

        bits = 0;
        maxpower = Math.pow(2,numBits);
        power=1;
        while (power!=maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb>0 ? 1 : 0) * power;
          power <<= 1;
        }

        switch (c = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2,8);
            power=1;
            while (power!=maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb>0 ? 1 : 0) * power;
              power <<= 1;
            }

            dictionary[dictSize++] = f(bits);
            c = dictSize-1;
            enlargeIn--;
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2,16);
            power=1;
            while (power!=maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb>0 ? 1 : 0) * power;
              power <<= 1;
            }
            dictionary[dictSize++] = f(bits);
            c = dictSize-1;
            enlargeIn--;
            break;
          case 2:
            return result.join('');
        }

        if (enlargeIn == 0) {
          enlargeIn = Math.pow(2, numBits);
          numBits++;
        }

        if (dictionary[c]) {
          entry = dictionary[c];
        } else {
          if (c === dictSize) {
            entry = w + w.charAt(0);
          } else {
            return null;
          }
        }
        result.push(entry);

        // Add w+entry[0] to the dictionary.
        dictionary[dictSize++] = w + entry.charAt(0);
        enlargeIn--;

        w = entry;

        if (enlargeIn == 0) {
          enlargeIn = Math.pow(2, numBits);
          numBits++;
        }

      }
    }
  };
  return LZString;
})();

if (typeof define === 'function' && define.amd) {
  define('js/LZString.js',[],function () { return LZString; });
} else if( typeof module !== 'undefined' && module != null ) {
  module.exports = LZString
} else if( typeof angular !== 'undefined' && angular != null ) {
  angular.module('LZString', [])
         .factory('LZString', function () {
           return LZString;
         });
}
;
define('js/utils.js',[
  'components/marked/lib/marked'
], function (marked) {

  const utils = {
    cellMaps: {},
    cplusplusKernel11: 'xeus-cling-cpp11',
    cplusplusKernel14: 'xeus-cling-cpp14',
    cplusplusKernel17: 'xeus-cling-cpp17',
    pythonKernel: 'python3',
    rKernel: 'ir',

    addCR: (str) => {
      return str + "\n";
    },

    getNotebookDirectory: () => {
      const fullNotebookPath = Jupyter.notebook.notebook_path;
      let notebookPath, notebookPathParts;
      if (fullNotebookPath.indexOf('/') === -1) {
        notebookPath = fullNotebookPath;
        if (notebookPath.indexOf('.ipynb') !== -1) {
          notebookPath = undefined; // at the top level, we don't set a CD command
        }
      } else {
        notebookPathParts = fullNotebookPath.split('/');
        notebookPath = notebookPathParts.slice(0,notebookPathParts.length - 1).join('/');
      }
      return notebookPath;
    },

    rerenderMarkdownCell: (cell) => {
      setTimeout(() => {
        cell.unrender();
        cell.render();
      },1); // needing to do this, is really weird. if you don't call this on a timeout, jupyter does not rerender the cell.
    },

    generateUniqueId: () => {
      return 'id_' + Math.random().toString(36).substr(2, 7);
    },

    getNow: () => {
      return new Date().getTime();
    },

    createPermanentStringFromFlag: (flag) => {
      return flag ? 'permanent': 'temporary';
    },

    getCodeCommentString: () => {
      const currentKernelName = Jupyter.notebook.kernel.name;
      let codeCommentString;
      switch (currentKernelName) {
        case utils.cplusplusKernel11:
        case utils.cplusplusKernel14:
        case utils.cplusplusKernel17:
          codeCommentString = '//';
          break;
        case utils.pythonKernel:
        case utils.rKernel:
          codeCommentString = '#';
          break;
      }
      return codeCommentString;
    },

    // These two functions help us translate between what we store in the notebook json itself ('graffitiCellId') and how we use it in the code, just as 'cellId'.
    // This was done to make our tags less likely to collide with other Jupyter plugins, but we wanted to keep the field name short in the Graffiti code.
    getMetadataCellId: (metadata) => {
      return metadata.graffitiCellId;
    },

    setMetadataCellId: (metadata, cellId) => {
      metadata.graffitiCellId = cellId;
      return cellId;
    },

    parseRecordingFullId: (recordingFullId) => {
      const parts = recordingFullId.split('_');
      const recordingCellId = 'id_' + parts[0];
      const recordingKey = 'id_' + parts[1];
      return {
        recordingCellId: recordingCellId,
        recordingKey: recordingKey
      };
    },

    computeArrayAverage: (array) => {
      let average = 0;
      for (let i = 0; i < array.length;++i) {
        average += array[i];
      }
      average = average / array.length;
      return average;      
    },

    subtractCoords: (c1, c2) => {
      const x1 = (c1.x !== undefined ? c1.x : c1.left);
      const y1 = (c1.y !== undefined ? c1.y : c1.top);
      const x2 = (c2.x !== undefined ? c2.x : c2.left);
      const y2 = (c2.y !== undefined ? c2.y : c2.top);
      return { 
        x: x2 - x1, 
        y: y2 - y1
      }
    },

    refreshCodeMirrorSelection: (cell) => {
      if ((cell.cell_type === 'code') && (cell.selected)) {
        cm = cell.code_mirror;
        selections = cm.listSelections();
        cell.focus_cell();
        cm.getInputField().focus();
        cm.setSelections(selections);
      } 
    },

    refreshCodeMirrorSelections: () => {
      const cells = Jupyter.notebook.get_cells();
      let cm,selections;
      for (let i = 0; i < cells.length; ++i) {
        cell = cells[i];
        utils.refreshCodeMirrorSelection(cell);
      }       
    },

    clearSelectedCellOutput: () => {
      const selectedCell = Jupyter.notebook.get_selected_cell();
      if (selectedCell !== undefined) {
        selectedCell.clear_output();
      }
    },

    composeGraffitiId: (cellId, recordingKey, activeTakeId) => {
      const combinedIds = [cellId.replace('id_',''),recordingKey.replace('id_','')];
      if (activeTakeId !== undefined) {
        combinedIds.push(activeTakeId.replace('id_',''));
      }
      const combinedIdStr = combinedIds.join('_');
      return combinedIdStr;
    },

    // Assign cellIds to any cells that don't have them yet.
    assignCellIds: () => {
      const cells = Jupyter.notebook.get_cells();
      let cell, cellId, i;
      for (let i = 0; i < cells.length; ++i) {
        cell = cells[i];
        cellId = utils.generateUniqueId();
        if (!cell.metadata.hasOwnProperty('graffitiCellId')) {
          utils.setMetadataCellId(cell.metadata, cellId);
        }
      }
    },

    assignCellGraffitiConfig: (cell, graffitiConfig) => {
      cell.metadata['graffitiConfig'] = graffitiConfig;
    },

    setCellGraffitiConfigEntry: (cell, key, val) => {
      if (!cell.metadata.hasOwnProperty('graffitiConfig')) {
        cell.metadata['graffitiConfig'] = {};
      }
      cell.metadata.graffitiConfig[key] = val;
    },

    getCellGraffitiConfig: (cell) => {
      if (cell.metadata.hasOwnProperty('graffitiConfig')) {
        return cell.metadata['graffitiConfig'];
      }
      return undefined;
    },

    getCellGraffitiConfigEntry: (cell, key) => {
      if (cell.metadata.hasOwnProperty('graffitiConfig')) {
        if (cell.metadata.graffitiConfig.hasOwnProperty(key)) {
          return cell.metadata.graffitiConfig[key];
        }
      }
      return undefined;
    },

    getNotebookGraffitiConfigEntry: (key) => {
      if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
        return Jupyter.notebook.metadata['graffiti'][key];
      }
      return undefined;
    },

    setNotebookGraffitiConfigEntry: (key, val) => {
      if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
        Jupyter.notebook.metadata['graffiti'][key] = val;
      }
    },

    // Also note any graffitis present in this cell, if it is a markdown cell, so that we can process their removal correctly if the user 
    // has moved them from where they were created originally (for instance, graffiti buttons).
    refreshCellMaps: () => {
      utils.cellMaps = {
        cells: Jupyter.notebook.get_cells(),
        maps: {},
        location: {}, // the id of the cell every graffiti is actually currently located in (may not be the cell where it was created)
      }
      let cell, cellId, cellDOM, tagsRe,graffitiId, cellKeys = Object.keys(utils.cellMaps.cells);
      for (let cellIndex = 0; cellIndex < cellKeys.length; ++cellIndex) {
        cell = utils.cellMaps.cells[cellIndex];
        cellId = utils.getMetadataCellId(cell.metadata);
        // Support lookups by cellId.
        utils.cellMaps.maps[cellId] = cellIndex;
        // Dress up the DOM  cellId so we can track selections in them (pretty much only markdown, selections in code_mirror are done through its API
        if (cell.hasOwnProperty('inner_cell')) {
          cellDOM = $(cell.inner_cell).parents('.cell');
        } else if (cell.hasOwnProperty('element')) {
          cellDOM = $(cell.element);
        }
        if (cellDOM !== undefined) {
          cellDOM.attr({ 'graffiti-cell-id' : utils.getMetadataCellId(cell.metadata)});
        }
        if (cell.cell_type === 'markdown') {
          contents = cell.get_text();
          tagsRe = utils.createGraffitiTagRegex();
          let match, idMatch;
          while ((match = tagsRe.exec(contents)) !== null) { 
            idMatch = match[1].match(/graffiti-(id_.[^\-]+)-(id_[^\s]+)/);
            graffitiId = idMatch[1] + '_' + idMatch[2];
            utils.cellMaps.location[graffitiId] = cellId;
          }        
        }
        //console.trace('cellMaps',utils.cellMaps.location);
      }
    },

    findCellIdByLocationMap: (recordingCellId, recordingKey) => {
      const graffitiId = recordingCellId + '_' + recordingKey;
      if (utils.cellMaps.location[graffitiId] !== undefined) {
        return utils.cellMaps.location[graffitiId];
      }

      return undefined;
    },

    findCellIndexByCellId: (cellId) => {
      if (utils.cellMaps !== undefined && utils.cellMaps.maps !== undefined && utils.cellMaps.maps.hasOwnProperty(cellId)) {
        return utils.cellMaps.maps[cellId];
      }
      return undefined;
    },

    findCellByCellId: (cellId) => {
      const index = utils.findCellIndexByCellId(cellId);
      if (index !== undefined) {
        return utils.cellMaps.cells[index];
      }
      return undefined;
    },


    findCellByCodeMirror: (cm) => {
      for (let cell of utils.cellMaps.cells) {
        if (cell.code_mirror === cm) {
          return cell;
        }
      }
      return undefined;
    },
    
    findCellIndexByCodeMirror: (cm) => {
      for (let cell of utils.cellMaps.cells) {
        if (cell.code_mirror === cm) {
          const cellId = utils.getMetadataCellId(cell.metadata);
          if (cellId !== undefined) {
            return utils.findCellIndexByCellId(cellId);
          }
        }
      }
      return undefined;
    },

    selectCellByCellId: (cellId) => {
      const cellIndex = utils.findCellIndexByCellId(cellId);
      if (cellIndex !== undefined) {
        Jupyter.notebook.select(cellIndex);
      }
    },

    extractRecordingCellId: (selectedTokens) => {
      return ((selectedTokens.tagCellId !== undefined) && 
              (selectedTokens.tagCellId !== selectedTokens.recordingCellId) ? 
              selectedTokens.tagCellId : 
              selectedTokens.recordingCellId);
    },

    getCellRects: (cell) => {
      const cellElement = $(cell.element[0]);
      const cellRect = cellElement[0].getBoundingClientRect();
      const innerCell = cellElement.find('.inner_cell')[0];
      const innerCellRect = innerCell.getBoundingClientRect();
      const prompt = cellElement.find('.prompt')[0];
      const promptRect = prompt.getBoundingClientRect();

      return {
        cellRect: cellRect,
        innerCell: innerCell,
        innerCellRect: innerCellRect,
        promptRect:promptRect
      }
    },

    renderMarkdown: (contents) => {
      // Strip out special commands eg. headline commands and make all hrefs pop new tabs
      const cleanedContents = contents.replace(/^\s*%%(.*)$/mg, '');
      return marked(cleanedContents).replace(/(href=".*")>/g, "$1 target=\"_blank\">");
    },

    collectViewInfo: (clientX, clientY, notebookPanelHeight, scrollDiff) => {
      let cellElement, cellElementJq, cellRect, outerCellRect,
          cellIndex, cellIndexStr, cell, innerCell, innerCellRect, innerCellRectRaw, prompt, 
          pointerPosition, pointerInsidePromptArea, cellPosition, lineNumbersVisible, cm;
      const inputCells = Jupyter.notebook.get_cells();
      const selectedCell = Jupyter.notebook.get_selected_cell();
      const selectedCellId = utils.getMetadataCellId(selectedCell.metadata);
      // handle case where pointer is above all cells or below all cells
      let promptBbox = undefined;
      for (cellIndexStr in inputCells) {
        cellIndex = parseInt(cellIndexStr);
        cell = inputCells[cellIndex];
        cellElement = cell.element[0];
        cellElementJq = $(cellElement);
        cellRect = cellElement.getBoundingClientRect();
        prompt = cellElementJq.find('.prompt');
        pointerInsidePromptArea = false;
        if ((prompt.length > 0) && (prompt.is(':visible'))) {
          promptBbox = prompt[0].getBoundingClientRect();
          pointerInsidePromptArea = ((clientX >= promptBbox.left) && (clientX < promptBbox.right) &&
                                     (clientY >= promptBbox.top)  && (clientY < promptBbox.bottom));
        }
        if ( ((cellRect.top <= clientY) && (clientY <= cellRect.bottom)) ||
             // These are the cases where the pointer is above the first cell or below the last cell
             (((cellIndex === 0) && (clientY < cellRect.top)) ||
              ((cellIndex === inputCells.length - 1) && (cellRect.bottom < clientY))) ) {
          outerCellRect = {
            top: cellRect.top,
            left: cellRect.left
          };
          innerCell = cellElementJq.find('.inner_cell')[0];
          innerCellRectRaw = innerCell.getBoundingClientRect();
          innerCellRect = { 
            top: innerCellRectRaw.top, 
            left: innerCellRectRaw.left, 
            width: innerCellRectRaw.width, 
            height: innerCellRectRaw.height 
          };
          lineNumbersVisible = cell.code_mirror.options.lineNumbers;
          cellPosition = cellElementJq.position();
          cm = cell.code_mirror;
          const innerScrollInfo = cm.getScrollInfo();
          const innerScroll = { left: innerScrollInfo.left, top: innerScrollInfo.top };
          return {
            cellId: utils.getMetadataCellId(cell.metadata), // The id of cell that the pointer is hovering over right now
            cellIndex: cellIndex,
            innerCellRect: innerCellRect,
            innerScroll: innerScroll,
            lineNumbersVisible: lineNumbersVisible,
            outerCellRect: outerCellRect,
            inMarkdownCell: (cell.cell_type === 'markdown'),
            inPromptArea: pointerInsidePromptArea,
            promptWidth: (promptBbox === undefined ? 0 : promptBbox.width),
            selectedCellId: selectedCellId,
            notebookPanelHeight: notebookPanelHeight,
            scrollDiff: scrollDiff
          };
        }
      }
      return { cellId: undefined, cellRectTop: undefined, cellRectBottom: undefined, relativePointerPosition: undefined };

    },

    getActiveCellId: () => {
      const activeCell = Jupyter.notebook.get_selected_cell();
      return utils.getMetadataCellId(activeCell.metadata);
    },

    getActiveCellLineNumber: () => {
      const activeCell = Jupyter.notebook.get_selected_cell();
      const cm = activeCell.code_mirror;
      const selections = cm.listSelections();
      const activeLine = selections[0].anchor.line;
      return activeLine;
    },

    saveNotebook: (cb) => {
      Jupyter.notebook.save_notebook().then( () => { 
        if (cb !== undefined) {
          cb();
        }
        console.log('Graffiti: Notebook saved.') 
      });
    },

    // You can delete this, it's no longer needed now that we call cell.focus_cell() when we change selections
    shrinkAllCMSelections: () => {
      const inputCells = Jupyter.notebook.get_cells();
      let cell,cm,selections;
      for (let i = 0; i < inputCells.length; ++i) {
        cell = inputCells[i];       
        if (cell.cell_type === 'code') {
          cm = cell.code_mirror;
          selections = cm.listSelections();
          if (selections.length > 0) {
            console.log('Graffiti: Clearing selections before: selections:', selections);
            for (let j = 0; j < selections.length; ++j) {
              selections[j].head = $.extend({}, selections[j].anchor);
            }
            console.log('Graffiti: Clearing selections after: selections:', selections);
            cm.setSelections(selections);
          }
        }
      }
    },

    // Legacy
    /*
       collectTokenStrings: (allTokens, tokens) => {
       const subTokens = allTokens.slice(tokens.firstTokenOffset, tokens.firstTokenOffset + tokens.extraTokens + 1);
       return subTokens.reduce( (tokensString, token) => { tokensString + token.string } )
       },
     */

    createGraffitiTagRegex: () => {
      return RegExp('<span class="graffiti-highlight (graffiti-[^"]+)">(.*?)</span>','gm');
    },

    // Find out whether the current selection intersections with any graffiti token ranges, or which tokens are in the selection if not.
    findSelectionTokens: (recordingCell,  tokenRanges, state) => {
      //console.log('findSelectionTokens, tokenRanges:', tokenRanges);
      let range, startRange, endRange, recording, hasMovie, recordingKey, markdown, isIntersecting = false;
      const recordingCellId = utils.getMetadataCellId(recordingCell.metadata);
      const recordingCellType = recordingCell.cell_type;
      const cm = recordingCell.code_mirror;
      const selections = cm.listSelections();
      const firstSelection = selections[0];
      const anchorPos = cm.indexFromPos(firstSelection.anchor);
      const headPos = cm.indexFromPos(firstSelection.head);
      let startPos = Math.min(anchorPos, headPos);
      let endPos = Math.max(anchorPos, headPos);
      let minStartRange = 1000000000;
      const noResults = { isIntersecting: false, noTokensPresent: true };
      let results = noResults;

      if (recordingCellType === 'markdown') {
        // If in a markdown cell, the selection "tokens" are simply the selection, but only if the selection is 2 characters or more. We do not try to use
        // code mirror's tokenizer tools within markdown cells as there's other stuff like html in a markdown cell that could be confusing to it.
        const contents = recordingCell.get_text();
        let tagsRe = utils.createGraffitiTagRegex();
        let tags = [], match, tag;
        let idMatch;
        while ((match = tagsRe.exec(contents)) !== null) { 
          idMatch = match[1].match(/graffiti-(id_.[^\-]+)-(id_[^\s]+)/);
          tags.push({
            fullMatch: match[0],
            recordingCellId: idMatch[1],
            recordingKey: idMatch[2],
            innerText: match[2],
            startRange: match.index,
            endRange: match.index + match[0].length
          }); 
        }

        // Figure out if the startPs or endPos is inside an existing Graffiti in this markdown cell (intersecting).
        if (tags.length > 0) {
          for (tag of tags) {
            if ( ((startPos >= tag.startRange) && (startPos <= tag.endRange)) ||
                 ((endPos >= tag.startRange) && (endPos <= tag.endRange)) ) {
              isIntersecting = true;
              break;
            }
          }
        }
        if (isIntersecting) {
          recording = state.getManifestSingleRecording(tag.recordingCellId, tag.recordingKey);
          if (recording !== undefined) {
            hasMovie = recording.hasMovie;
            results = {
              isIntersecting: true,
              noTokensPresent: false,
              recordingCell: recordingCell,
              recordingCellId: recordingCellId,
              // If the graffiti was moved around, then the cell id in its tag won't match the cell where it's found. 
              // We store this here to detect this situation so we can track down the graffiti recording that used to be in a different cell.
              tagCellId: tag.recordingCellId, 
              recordingKey: tag.recordingKey, 
              hasMovie: hasMovie,
              allTokensString: tag.innerText,
              markdown: tag.innerText,
              range: {
                start: tag.startRange,
                end:   tag.endRange,
              }
            }
          }
        } else {
          // Now check for a selection in the markdown cm cell.
          if (endPos > startPos + 1) { // 2 or more chars is in the selection; this way we disallow Graffitis applied to just CR's
            // Move startPos forward past markdown-significant characters, because if we put a graffiti around the markdown indicators, they will lose their markdown significance.
            let skipped = false;
            let checkChar = contents[startPos];
            const skipChars = '#_*'; // note: we do not include backticks, even though they are significant to markdown, as we want them inside our selected text for the graffiti spans.
            while ((skipChars.indexOf(checkChar) !== -1) && (startPos < endPos)) {
              skipped = true;
              startPos++;
              checkChar = contents[startPos];
            }
            if (skipped && (contents[startPos] === ' ')) {
              // skip past the space after hashtags
              ++startPos;
            }
            // expand the range to include surrounding backticks
            if (startPos > 0) {
              if (contents[startPos - 1] === '`') {
                startPos--;
              }
            }
            if (endPos < contents.length - 1) {
              if (contents[endPos + 1] === '`') {
                endPos++;
              }
            }
            // Backup from a cr. this may happen if the user triple clicked on a line and absorbed the cr. we don't want that.
            //console.log('Check for backing up:-->', contents.substring(startPos,endPos), '<--');
            //console.log('code:', contents[endPos].charCodeAt(0), 'code-1:', contents[endPos-1].charCodeAt(0));
            while (contents[endPos-1].charCodeAt(0) === 10) {
              //console.log('backing up, -->', contents[endPos], '<--,', contents[endPos-1].charCodeAt(0) );
              endPos--;
              if (endPos === startPos + 2) {
                break;
              }
            }
            //console.log('selection will be:', contents.substring(startPos,endPos), '<--', contents[endPos].charCodeAt(0));
            results = {
              isIntersecting: false,
              noTokensPresent: false,
              range: {
                start: startPos,
                end: endPos
              },
              allTokensString: cm.getSelection()
            }
          }
        }
        //console.log('final results:',results);
      } else if (recordingCellType === 'code') {
        // If in a code cell, try to find tokens in and around the selection.
        if (tokenRanges[recordingCellId] !== undefined) {
          const tokenRangesThisCell = tokenRanges[recordingCellId];
          for (recordingKey of Object.keys(tokenRangesThisCell)) {
            range = tokenRangesThisCell[recordingKey];
            startRange = cm.indexFromPos(range.start);
            endRange = cm.indexFromPos(range.end);
            // console.log('startPos:', startPos, 'endPos:', endPos, '| startRange:', startRange, 'endRange:', endRange, 'range:', range);
            if ((startPos <= startRange && endPos >= endRange) || // selection surrounds or equals the range
                ((startPos >= startRange && startPos < endRange) || (endPos > startRange && endPos <= endRange))) { // selection is inside the range
              if (startRange < minStartRange) {
                minStartRange = startRange;
                recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
                if (recording) {
                  markdown = recording.markdown;
                  hasMovie = recording.hasMovie;
                  //console.log('found range:', range);
                  isIntersecting = true;
                  results = {
                    isIntersecting: true,
                    noTokensPresent: false,
                    recordingCell: recordingCell,
                    recordingCellId: recordingCellId,
                    recordingKey: recordingKey, 
                    markdown: markdown,
                    hasMovie: hasMovie,
                    range: {
                      start: startRange,
                      end:   endRange
                    }
                  }
                };
              }
            }
          }
        }
        if (!isIntersecting) {
          // we didn't find a match within existing recordings. See what tokens are selected overall in that case.
          // console.log('not intersecting, now checking for new graffiti creation');
          const allTokens = utils.collectCMTokens(cm);
          let startCheck, endCheck, token, startToken, endToken, lastToken, startTokenIndex, startTokenStringTrimmed, tokenCount = 0, tokensString = '';
          if (allTokens.length === 0) {
            // degnerate case 1: no tokens present at all in the cell
            results = noResults;
          } else {
            token = allTokens[allTokens.length - 1];
            endCheck = cm.indexFromPos({line: token.line, ch: token.end});
            if (startPos > endCheck) {
              // degenerate case 2: selection caret is past the last token present
              results = noResults;
            } else {
              for (let i = 0; i < allTokens.length; ++i) {
                lastToken = token;
                token = allTokens[i];
                startCheck = cm.indexFromPos({line: token.line, ch: token.start});
                endCheck = cm.indexFromPos({line: token.line, ch: token.end});
                //console.log('startPos, endPos:', startPos, endPos, 'checking token:', token.string, startCheck, endCheck);
                if (startToken === undefined) {
                  startTokenStringTrimmed = $.trim(token.string);
                  if ((startTokenStringTrimmed.length > 0) &&
                      ((startPos >= startCheck && startPos <= endCheck) ||
                       (endPos >= startCheck && endPos <= endCheck))) {
                    startToken = token;
                    startTokenIndex = i;
                    tokenCount = 1;
                    tokensString = startToken.string;
                    //console.log('start token:', startToken);
                    if (startPos === endPos) {
                      endToken = token; // the selection is zero characters long so the startToken and the endToken are the same
                    }
                  }
                } else if (!(startCheck >= endPos)) { // scan forward for the ending token
                  endToken = token;
                  tokenCount++;
                  tokensString += token.string;
                  //console.log('end token:', endToken);
                }
                if (startCheck > endPos) {
                  if (startToken === undefined && lastToken !== undefined) {
                    console.log('Graffiti: between tokens, so cannot create a Graffiti.');
                    results = noResults;
                  }
                  break;
                }
              }
              
              // Find the occurence count of the first token in the code cell, e.g. if the token is the second "hello" in "hello there, mr. hello dude"
              if (startToken === undefined) {
                results = noResults;
                console.log('Graffiti: degenerate case 3, startToken not found despite everything. Falling to safe route.');
              } else {
                //console.log('Graffiti: startPos, endPos:', startPos, endPos, 'startToken,endToken:', startToken,endToken);
                startToken.offset = 0;
                for (let i = 0; i < allTokens.length; ++i) {
                  token = allTokens[i];
                  if (token.type === startToken.type && token.string === startToken.string) {
                    if (i < startTokenIndex) {
                     ++startToken.offset;
                    } else {
                      break;
                    }
                  }
                }

                if (endToken === undefined) {
                  console.log('Graffiti: degenerate case 4, endToken not found. Falling to safe route.');
                  endToken = startToken; // degenerate case 4: never found an end token, assume just one token. not sure why this happens yet 8/20/18
                }

                results = {
                  isIntersecting: false,
                  noTokensPresent: false,
                  tokens: {
                    start: {
                      type: startToken.type,
                      string: startToken.string,
                      offset: startToken.offset
                    },
                    count: tokenCount
                  },
                  allTokensString: tokensString,
                  range: {
                    start: cm.indexFromPos({line:startToken.line, ch: startToken.ch}),
                    end:   cm.indexFromPos({line:endToken.line, ch: endToken.ch}),
                    selectionStart: startPos,
                    selectionEnd: endPos
                  }
                }
              }
            }
          }
        }
      }

      //console.log('findIntersectingRange results:', results);
      return results;
    },

    // Collect all tokens in code-mirror into an array and tag each with which line it's found on. We use this 
    // in refreshGraffitiHighlights() as we mark up a cell with existing recorded graffitis.
    collectCMTokens: (cm) => {
      let allTokens = [];
      const lineCount = cm.lineCount();
      for (let i = 0; i < lineCount; ++i) {
        lineTokens = cm.getLineTokens(i);
        for (let j of Object.keys(lineTokens)) {
          lineTokens[j].line = i;
        }
        allTokens = allTokens.concat(lineTokens);
      }
      return allTokens;
    },

    // Given a start token string and a tokenOffset, and how many subsequent tokens are needed, pull the line and character ranges
    // out of the given code mirror instance (since those ranges might have changed since the graffiti was first created).
    getCMTokenRange: (cm, tokens, allTokens) => {
      const startToken = tokens.start;
      if (startToken === undefined) {
        return undefined; // couldn't find start token, degenerate case, can only happen if a graffiti has a corrupted startToken.
      }
      const allTokensLength = allTokens.length;
      let i, tokenCounter = 0, lineTokens, token, firstTokenPosition;
      for (i = 0; i < allTokensLength; ++i) {
        token = allTokens[i];
        if ((token.string === startToken.string) && (token.type === startToken.type)) {
          if (tokenCounter === startToken.offset) {
            firstTokenPosition = i;
            break;
          } else {
            ++tokenCounter;
          }
        }
      }
      if (firstTokenPosition === undefined) {
        return undefined; // couldn't find first token
      }
      const lastTokenPosition = Math.min(allTokensLength - 1, firstTokenPosition + tokens.count - 1);
      const firstToken = allTokens[firstTokenPosition];
      const lastToken = allTokens[lastTokenPosition];

      return {
        start: {
          line: firstToken.line, ch: firstToken.start
        },
        end: {
          line: lastToken.line, ch: lastToken.end
        }
      };
    },

    cleanSelectionRecord: (rec) => {
      return {
        anchor: { 
          ch: rec.anchor.ch,
          line: rec.anchor.line
        },
        head: {
          ch: rec.head.ch,
          line: rec.head.line
        }
      }
    },

    cleanSelectionRecords: (recs) => {
      let cleanedRecs = [];
      if (recs.length === 0) {
        return cleanedRecs;
      }
      for (let i = 0; i < recs.length; ++i) {
        cleanedRecs.push(utils.cleanSelectionRecord(recs[i]));
      }
      return cleanedRecs;
    },

    //
    // Time formatting functions
    //
    timeZeroPad: (num) => {
      const strNum = num.toString();
      return(strNum.length < 2 ? '0' + strNum : strNum);
    },

    formatTime: (currentTimeMilliseconds, opts) => {
      const currentTimeSeconds = currentTimeMilliseconds / 1000;
      const computedHour = Math.floor(currentTimeSeconds / 3600);
      const computedMinutes = Math.floor((currentTimeSeconds - (computedHour * 3600)) / 60);
      const computedSeconds = Math.floor(currentTimeSeconds - (computedMinutes * 60 + computedHour * 3600));
      const computedMilliseconds = Math.min(99, 
                                            (Math.floor(currentTimeMilliseconds -
                                                        ((computedSeconds + computedMinutes * 60 + computedHour * 3600) * 1000)) / 10).toFixed(0));
      let displayMilliseconds = utils.timeZeroPad(computedMilliseconds);
      let displaySeconds = utils.timeZeroPad(computedSeconds);
      let displayMinutes = utils.timeZeroPad(computedMinutes);
      let displayHour = utils.timeZeroPad(computedHour);
      let currentTimeFormatted;
      if (opts.includeMillis) {
        currentTimeFormatted = `${displayMinutes}:${displaySeconds}:${displayMilliseconds}`;
      } else {
        currentTimeFormatted = `${displayMinutes}:${displaySeconds}`;
      }
      return(currentTimeFormatted);
    },

    loadCss: (cssPaths) => {
      let path, reworkedPath, previousCssTag;
      for (let i in cssPaths) {
        path = cssPaths[i];
        reworkedPath = path;
        // Rework CSS paths on hosts like binder.org, where there is some additional virtual path between document.origin
        // and the path to the notebook. If a relative path, keep "tree" or "notebook" in the path; otherwise start
        // any absolute path from *after* document.location.origin + virtual path.
        const loc = document.location;
        const urlPathName = loc.pathname;
        const hasTree = (urlPathName.indexOf('/tree') > -1);
        const hasNotebooks = (urlPathName.indexOf('/notebooks/') > -1);
        const leadingSlash = (path[0] === '/');
        let treeNotebook = '', parts;
        if (hasTree) {
          treeNotebook = (leadingSlash ? '' : '/tree/');
          parts = urlPathName.split(/\/tree/,2);
        } else if (hasNotebooks) {
          treeNotebook = (leadingSlash ? '' : '/notebooks/');
          parts = urlPathName.split(/\/notebooks\//,2);
        }
        reworkedPath = loc.origin + (parts[0].length > 0 ? parts[0] + treeNotebook + path : treeNotebook + path);

        previousCssTag = $('#recorder-css-tag-' + i);
        if (previousCssTag.length === 0) {
          // https://stackoverflow.com/questions/18510347/dynamically-load-stylesheets
          const styles = document.createElement('link');
          styles.rel = 'stylesheet';
          styles.id = 'recorder-css-tag-' + i;
          styles.type = 'text/css';
          styles.media = 'screen';
          styles.href = reworkedPath;
          document.getElementsByTagName('head')[0].appendChild(styles);
        }
      }
    },

    // https://stackoverflow.com/a/18284182/2767287
    getViewportSize: (w) => {
      // Use the specified window or the current window if no argument
      w = w || window;

      // This works for all browsers except IE8 and before
      if (w.innerWidth != null) return { w: w.innerWidth, h: w.innerHeight };

      // For IE (or any browser) in Standards mode
      var d = w.document;
      if (document.compatMode == "CSS1Compat")
        return { w: d.documentElement.clientWidth,
                 h: d.documentElement.clientHeight };

      // For browsers in Quirks mode
      return { w: d.body.clientWidth, h: d.body.clientHeight };

    },

    // Thanks for this goes to : https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f
    copyToClipboard: (str) => {
      const el = document.createElement('textarea');  // Create a <textarea> element
      el.value = str;                                 // Set its value to the string that you want copied
      el.setAttribute('readonly', '');                // Make it readonly to be tamper-proof
      el.style.position = 'absolute';                 
      el.style.left = '-9999px';                      // Move outside the screen to make it invisible
      document.body.appendChild(el);                  // Append the <textarea> element to the HTML document
      const selected =            
        document.getSelection().rangeCount > 0        // Check if there is any content selected previously
        ? document.getSelection().getRangeAt(0)       // Store selection if found
        : false;                                      // Mark as false to know no selection existed before
      el.select();                                    // Select the <textarea> content
      document.execCommand('copy');                   // Copy - only works as a result of a user action (e.g. click events)
      document.body.removeChild(el);                  // Remove the <textarea> element
      if (selected) {                                 // If a selection existed before copying
        document.getSelection().removeAllRanges();    // Unselect everything on the HTML document
        document.getSelection().addRange(selected);   // Restore the original selection
      }
    },

    isUdacityEnvironment: () => {
      const host = location.hostname;
      if (host.endsWith('udacity.com') || 
          host.endsWith('udacity-student-workspaces.com')) {
        return true;
      }
      return false;
    },

    createApiSymlink: () => {
      if (!utils.isUdacityEnvironment()) {
        return;
      }
      // Create a symlink to get 'import jupytergraffiti' working in Udacity environment
      const graffitiPath = '/opt/workspace-jupyter-graffiti/jupytergraffiti';
      const createSymlinkCmd = `ln -sf ${graffitiPath} jupytergraffiti`;

      // Create a python file and execute the file 
      let importApiScript = '';
      // Adding /opt/jupytergraffiti to system path allows us to import it as a python module
      importApiScript += 'import sys\\n';
      importApiScript += 'api_path="'+ graffitiPath +'"\\n';
      importApiScript += 'if api_path not in sys.path:\\n';
      importApiScript += '  sys.path.insert(0,api_path)\\n';
      const executePythonScript = `!${createSymlinkCmd} && echo '${importApiScript}' > /tmp/graffiti-symlink.py && python /tmp/graffiti-symlink.py`;
      const scriptOptions = {
        silent: false,
        store_history: false,
        stop_on_error : true
      }
      
      Jupyter.notebook.kernel.execute(executePythonScript, undefined, scriptOptions);
    }

  }

  return(utils);
});

define('js/localizer.js',[
  'js/state.js',
], function (state) {
  const localizer = {  
    defaultLanguage: 'EN',
    language: 'EN',

    getLanguage: () => {
      return localizer.language;
    },

    setLanguage: (language) => {
      if (language !== undefined) {
        localizer.language = language;
      } else {
        localizer.language = localizer.defaultLanguage;
      }
    },

    getString: (token) => {
      if (localizer.translations.hasOwnProperty(localizer.language)) {
        if (localizer.translations[localizer.language].hasOwnProperty(token)) {
          if (localizer.translations[localizer.language][token].length > 0) {
            // console.log('localized, for ' + token + ' returning ' , localizer.translations[localizer.language][token]);
            return localizer.translations[localizer.language][token];
          } else {
            // console.log('unlocalized, for ' + token + ' returning ' , localizer.translations[localizer.defaultLanguage][token]);
            return localizer.translations[localizer.defaultLanguage][token];
          }
        }
      }
      // Cant find the string, just return the token so it's obvious it needs translation
      return token;
    },

    loadLocale: (locale) => {
      switch (locale) {
        case 'EN':
          localizer.translations['EN'] = {
            'ENABLE_GRAFFITI':                   'Enable Graffiti',
            'ACTIVATE_GRAFFITI':                 'Activate Graffiti',
            'GRAFFITI_PRESENT':                  'Graffiti is present on this line to the left.',
            'MOVIE_UNAVAILABLE':                 'Movie is not available.',
            'MOVIE_UNAVAILABLE_EXPLANATION':     'We are sorry, we could not load this movie at this time. Please contact the author of this Notebook for help.',
            'FILE_UNAVAILABLE':                  'File unavailable',
            'FILE_UNAVAILABLE_EXPLANATION':      'The file you requested with <i>%%insert_data_from_file</i> was not found.',
            'ACTIVATE_GRAFFITI_CONFIRM':         'Activate Graffiti On This Notebook?',
            'CREATE_1':                          'Create',
            'CREATE_2':                          'Record',
            'EDIT' :                             'Edit',
            'EDIT_TOOLTIP' :                     'Edit Tooltip / Graffiti Settings',
            'START_RECORDING':                   'Start Recording',
            'END_RECORDING':                     'End Recording',
            'RECORD' :                           'Record',
            'RECORD_MOVIE' :                     'Record movie',
            'RERECORD':                          'Rerecord',
            'RERECORD_MOVIE':                    'Rerecord movie',
            'START_PLAYBACK':                    'Start playback',
            'PAUSE_PLAYBACK':                    'Pause playback (spacebar)',
            'EXIT_PLAYBACK':                     'Exit movie (restore notebook contents)',
            'MUTE':                              'Mute audio',
            'UNMUTE':                            'Unmute audio',
            'HIGH_SPEED_PLAYBACK':               'Switch to high speed playback',
            'REGULAR_SPEED_PLAYBACK':            'Switch to regular speed playback',
            'HIGH_SPEED_SILENCES':               'High Speed during silences',
            'REGULAR_SPEED_SILENCES':            'Regular Speed during silences',
            'SKIP_BACK':                         'Skip back',
            'SKIP_FORWARD':                      'Skip forward',
            'TO_PREVIOUS_SENTENCE':              'to previous sentence',
            'TO_NEXT_SENTENCE':                  'to next sentence',
            'SECONDS':                           'second',
            'SAVE_GRAFFITI':                     'Save Graffiti',
            'REMOVE_GRAFFITI':                   'Remove Graffiti',
            'BELOW_TYPE_MARKDOWN':               "%% Below, type any markdown to display in the Graffiti tip.\n" +
                                                 "%% Then run this cell to save it.\n",
            'SAMPLE_API':                        'Create Sample API Calls',
            'SKIPS_API':                         'Fast Forwards / Skips',
            'SKIPS_DIALOG_TITLE':                'Remove Fast Forwards & Skips on This Recording?',
            'SKIPS_DIALOG_BODY':                 'This will remove all fast forwards and skips you have set. Are you positive?',
            'SKIPS_DIALOG_CONFIRM_1':            'Proceed',
            'SKIPS_DIALOG_CANCEL':               'Cancel',
            'SKIPS_HEADER':                      'Fast Forwards & Skips',
            'SKIPS_COMPRESS_BTN':                'Compress time to fixed length',
            'SKIPS_2X_BTN':                      'Set to fast forward at 2x speed',
            'SKIPS_3X_BTN':                      'Set to fast forward at 3x speed',
            'SKIPS_4X_BTN':                      'Set to fast forward at 4x speed',
            'SKIPS_COMPRESS_BTN':                'Compress time to fixed length',
            'SKIPS_ABSOLUTE_BTN':                'Skip a section entirely',
            'SKIPS_CLEAR_BTN':                   'Remove all skips',
            'TAKES':                             'Takes',
            'SELECT_SOME_TEXT_MARKDOWN' :        'Select some text in this Markdown cell to add or modify Graffiti, or click inside any existing Graffiti text to modify it.',
            'EDIT_IN_MARKDOWN_CELL' :            'Edit the Markdown cell to add or modify Graffiti in the cell, or use Graffiti Extras (below)',
            'SELECT_SOME_TEXT_PLAIN' :           'Select some text in a cell to create or modify Graffiti, click inside any existing Graffiti text to modify that Graffiti, ' +
                                                 'or use Graffiti Extras (below)',
            'YOU_CAN_PLAY_VIA_TOOLTIP' :         'You can play this movie any time via its tooltip.',
            'NO_MOVIE_RECORDED_YET' :            'No movie has been recorded for this Graffiti yet.',
            'PLEASE_WAIT_STORING_MOVIE' :        'Please wait, storing this movie...',
            'YOU_CAN_FILTER' :                   'You can filter this Notebook\'s Graffiti by clicking on creators in the list below.',
            'PAUSE_TO_INTERACT' :                '<span class="graffiti-notifier-link" id="graffiti-pause-link">Pause</span> (or scroll the page) to interact with this Notebook',
            'CANCEL_MOVIE_PLAYBACK_1' :          '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-link">Cancel</span> movie playback (Esc)',
            'CANCEL_MOVIE_PLAYBACK_2' :          '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-postreset-link">Cancel</span> movie playback (Esc)',
            'CANCEL_MOVIE_PLAYBACK_3' :          '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-prereset-link">Cancel</span> movie playback (Esc)',
            'PLAY_MOVIE_AGAIN' :                 '<span class="graffiti-notifier-link" id="graffiti-restart-play-link">Play movie again</span>',
            'CONTINUE_MOVIE_PLAYBACK' :          '<span class="graffiti-notifier-link" id="graffiti-continue-play-link">Continue</span> movie playback',
            'ENTER_AND_SAVE' :                   'Enter the markdown you want to be displayed in the Graffiti and then click "Save Graffiti"  (or just run the label cell).',
            'CANCEL_CHANGES_1' :                 'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-graffiting-link">Cancel changes</span>',
            'CANCEL_CHANGES_2' :                 'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-recording-labelling-link">Cancel changes</span>',
            'ENTER_MARKDOWN_MOVIE_DESCRIPTION' : 'Enter markdown to describe your movie, then click "Start Recording" (or just run the label cell).',
            'CLICK_BEGIN_MOVIE_RECORDING' :      'Click anywhere in the notebook to begin recording your movie.',
            'CANCEL_RECORDING_1' :               'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-recording-pending-link">Cancel recording</span>',
            'CANCEL_RECORDING_2' :               'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-recording-link">Cancel recording</span>',
            'RECORDING_HINT_1' :                 '<div class="graffiti-keyboard-sim"><div>option/alt</div><div>key</div></div>',
            'RECORDING_HINT_2' :                 '<span>Tap</span>: Pause Rec.',
            'RECORDING_HINT_3' :                 '<span>Hold</span>: End Rec.',
            'RECORDING_HINT_4' :                 '<div class="graffiti-keyboard-sim" style="color:red;"><div>Skipping</div><div>(option/alt to resume)</div></div>',
            'IS_SKIPPING' :                      '--:--',
            'ACTIVITIES_BEING_RECORDED':         'Your activities are being recorded. Hold the option key down to end recording.',
            'LOADING':                           'Loading...',
            'LOADING_PLEASE_WAIT':               'Loading Graffiti movie, please wait...',
            'RECORDED_ON':                       'Recorded',
            'PRESS_ESC_TO_END_MOVIE_PLAYBACK' :  'Press ESC to end movie playback',
            'SHOW_GRAFFITI_EDITOR':              'Show Graffiti Editor',
            'HIDE_GRAFFITI_EDITOR':              'Hide Graffiti Editor',
            'ENTER_LABEL':                       'Enter a label...',
            'FREEFORM_PEN_TOOL' :                'Freeform pen tool',
            'HIGHLIGHTER_TOOL':                  'Highlighter tool',
            'ERASER_TOOL':                       'Eraser tool',
            'USE_DISAPPEARING_INK':              'Use disappearing ink',
            'USE_DASHED_LINES':                  'Use dashed lines',
            'DASHED_LINES':                      'Dashed lines',
            'TEMPORARY_INK':                     'Temporary Ink',
            'SOLID_FILL':                        'Solid Fill',
            'SHIFT_KEY_ALIGN':                   'Shift-key: align items to grid / keep items square',
            'PLAY_CONFIRM':                      'Are you sure you want to play this Graffiti?',
            'REPLACE_CONFIRM_BODY_1':            'This Graffiti movie may replace the contents of code cells. After this movie plays, do you want to...',
            'REPLACE_CONFIRM_BODY_2':            'Restore Cell Contents After Playback Ends',
            'REPLACE_CONFIRM_BODY_3':            'Let this Movie Permanently Set Cell Contents',
            'ACCESS_MICROPHONE_PROMPT':          'Please grant access to your browser\'s microphone.',
            'ACCESS_MICROPHONE_ADVISORY':        'You cannot record Graffiti movies unless you grant access to the microphone. ' +
                                                 'Please <a href="https://help.aircall.io/hc/en-gb/articles/115001425325-How-to-allow-Google-Chrome-to-access-your-microphone" ' +
                                                 'target="_">grant access</a> and then reload this page.',
            'ACTIVATE_GRAFFITI_ADVISORY':        'Enable Graffiti on this Notebook, so you can begin using Graffiti for the first time?<br>' +
                                                 'If you click Cancel, we will not change the notebook in any way.' +
                                                 '<br><br><i>(This process merely adds some metadata to the cells, but does not otherwise change the Notebook\'s contents.)</i>',
            'SCRUB':                             'scrub',
            'TOOLTIP_HINT':                      'Without moving your mouse, click now to watch a movie about this.',
            'MOVIE_DURATION':                    'Movie duration',
            'INSERT_GRAFFITI_BUTTON_CELL':       '+ Insert Graffiti Button',
            'INSERT_GRAFFITI_BUTTON_CELL_ALT_TAG': 'Insert a Graffiti-enabled button',
            'INSERT_GRAFFITI_TERMINAL':          '+ Insert Graffiti Terminal',
            'INSERT_GRAFFITI_TERMINAL_ALT_TAG': 'Insert a Graffiti-enabled terminal',
            'INSERT_GRAFFITI_TERMINAL_SUITE':    '+ Insert Terminal Suite',
            'INSERT_GRAFFITI_TERMINAL_SUITE_ALT_TAG': 'Insert a code cell + terminal + button',
            'INSERT_TERMINAL_SUITE_STATUS':      'Inserting a terminal suite, please wait...',
            'JUMP_TO_NOTEBOOK_DIR':              'Jump to Notebook\'s Dir',
            'RESET_TERMINAL':                    'Reset',
            'CELL_EXECUTES_GRAFFITI':            'Code Cell, Executes Graffiti',
            'CELL_EXECUTE_CHOICE':               'Now click on the element that contains the Graffiti you want this cell to run...',
            'CELL_EXECUTE_CHOICE_SET':           'Your choice has been saved.',
            'ACTIVATE_LOCK_ALT_TAG':             'Lock/unlock all markdown cells',
            'CREATE_SHOWHIDE_BUTTON':            'Create show/hide button',
            'LOCK_VERB':                         'Lock',
            'UNLOCK_VERB':                       'Unlock',
            'UNLOCK_BODY':                       'This will unlock all markdown cells so you can edit them (note: terminal cells are always locked).',
            'LOCK_BODY':                         'This will lock all markdown cells so they can no longer be edited.',
            'LOCK_CONFIRM':                      'markdown cells in notebook?',
          }
          break;
        case 'CN':
          localizer.translations['CN'] = {          
            'ENABLE_GRAFFITI':                   ' Graffiti',
            'ACTIVATE_GRAFFITI':                 ' Graffiti ',
            'GRAFFITI_PRESENT':                  ' Graffiti ',
            'MOVIE_UNAVAILABLE':                 '',
            'MOVIE_UNAVAILABLE_EXPLANATION':     ' Notebook ',
            'FILE_UNAVAILABLE':                  'File unavailable',
            'FILE_UNAVAILABLE_EXPLANATION':      'The file you requested with `%%insert_data_from_file` was not available',
            'ACTIVATE_GRAFFITI_CONFIRM':         ' Notebook  Graffiti',
            'CREATE_1':                          '',
            'CREATE_2':                          '',
            'EDIT' :                             '',
            'EDIT_TOOLTIP' :                     ' Graffiti ',
            'START_RECORDING':                   '',
            'END_RECORDING':                     '',
            'RECORD' :                           '',
            'RECORD_MOVIE' :                     '',
            'RERECORD':                          '',
            'RERECORD_MOVIE':                    '',
            'START_PLAYBACK':                    '',
            'PAUSE_PLAYBACK':                    ' (spacebar)',
            'EXIT_PLAYBACK':                     'Exit movie (restore notebook contents)',
            'MUTE':                              '',
            'UNMUTE':                            '',
            'HIGH_SPEED_PLAYBACK':               '',
            'REGULAR_SPEED_PLAYBACK':            '',
            'HIGH_SPEED_SILENCES':               '',
            'REGULAR_SPEED_SILENCES':            '',
            'SKIP_BACK':                         '',
            'SKIP_FORWARD':                      '',
            'TO_PREVIOUS_SENTENCE':              '',
            'TO_NEXT_SENTENCE':                  '',
            'SECONDS':                           '',
            'SAVE_GRAFFITI':                     ' Graffiti ',
            'REMOVE_GRAFFITI':                   ' Graffiti ',
            'BELOW_TYPE_MARKDOWN':               ' markdown  Graffiti ' +
                                                 '',
            'SAMPLE_API':                        ' API Calls',
            'SKIPS_API':                         'Fast Forwards / Skips',
            'SKIPS_DIALOG_TITLE':                'Remove Fast Forwards & Skips on This Recording?',
            'SKIPS_DIALOG_BODY':                 'This will remove all fast forwards and skips you have set. Are you positive?',
            'SKIPS_DIALOG_CONFIRM_1':            'Proceed',
            'SKIPS_DIALOG_CANCEL':               'Cancel',
            'SKIPS_HEADER':                      'Fast Forwards & Skips',
            'SKIPS_COMPRESS_BTN':                'Compress time to fixed length',
            'SKIPS_2X_BTN':                      'Set to fast forward at 2x speed',
            'SKIPS_3X_BTN':                      'Set to fast forward at 3x speed',
            'SKIPS_4X_BTN':                      'Set to fast forward at 4x speed',
            'SKIPS_COMPRESS_BTN':                'Compress time to fixed length',
            'SKIPS_ABSOLUTE_BTN':                'Skip a section entirely',
            'SKIPS_CLEAR_BTN':                   'Remove all skips',
            'TAKES':                             '',
            'SELECT_SOME_TEXT_MARKDOWN' :        ' Graffiti Graffiti ',
            'EDIT_IN_MARKDOWN_CELL' :            'Edit the Markdown cell to add or modify Graffiti in the cell, or use Graffiti Extras (below)',
            'SELECT_SOME_TEXT_PLAIN' :           'Select some text in a cell to create or modify Graffiti, click inside any existing Graffiti text to modify that Graffiti, ' +
                                                 'or use Graffiti Extras (below)',
            'YOU_CAN_PLAY_VIA_TOOLTIP' :         '',
            'NO_MOVIE_RECORDED_YET' :            'No movie has been recorded for this Graffiti yet.',
            'PLEASE_WAIT_STORING_MOVIE' :        '...',
            'YOU_CAN_FILTER' :                   ' Notebook  Graffiti',
            'PAUSE_TO_INTERACT' :                '<span class="graffiti-notifier-link" id="graffiti-pause-link"></span> Notebook ',
            'CANCEL_MOVIE_PLAYBACK_1' :          '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-link"></span> Esc ',
            'CANCEL_MOVIE_PLAYBACK_2' :          '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-postreset-link"></span> Esc ',
            'CANCEL_MOVIE_PLAYBACK_3' :          '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-prereset-link"></span> Esc ',
            'PLAY_MOVIE_AGAIN' :                 '<span class="graffiti-notifier-link" id="graffiti-restart-play-link"></span>',
            'CONTINUE_MOVIE_PLAYBACK' :          '<span class="graffiti-notifier-link" id="graffiti-continue-play-link"></span>',
            'ENTER_AND_SAVE' :                   ' Graffiti  Graffiti',
            'CANCEL_CHANGES_1' :                 '<span class="graffiti-notifier-link" id="graffiti-cancel-graffiting-link"></span>',
            'CANCEL_CHANGES_2' :                 '<span class="graffiti-notifier-link" id="graffiti-cancel-recording-labelling-link"></span>',
            'ENTER_MARKDOWN_MOVIE_DESCRIPTION' : '',
            'CLICK_BEGIN_MOVIE_RECORDING' :      ' Notebook ',
            'CANCEL_RECORDING_1' :               '<span class="graffiti-notifier-link" id="graffiti-cancel-recording-pending-link"></span>',
            'CANCEL_RECORDING_2' :               '<span class="graffiti-notifier-link" id="graffiti-cancel-recording-link"></span>',
            'RECORDING_HINT_1' :                 '<div class="graffiti-keyboard-sim"><div>option/alt</div><div>key</div></div>',
            'RECORDING_HINT_2' :                 '<span>Tap</span>: Pause Rec.',
            'RECORDING_HINT_3' :                 '<span>Hold</span>: End Rec.',
            'RECORDING_HINT_4' :                 '<div class="graffiti-keyboard-sim" style="color:red;"><div>Skipping</div><div>(option/alt to resume)</div></div>',
            'IS_SKIPPING' :                      '--:--',
            'ACTIVITIES_BEING_RECORDED':         '' +
                                                 ' -M <span class="graffiti-notifier-link" id="graffiti-end-recording-link"></span> ' +
                                                 '',
            'LOADING':                           '',
            'LOADING_PLEASE_WAIT':               ' Graffiti ...',
            'RECORDED_ON':                       '',
            'PRESS_ESC_TO_END_MOVIE_PLAYBACK' :  ' ESC ',
            'SHOW_GRAFFITI_EDITOR':              ' Graffiti ',
            'HIDE_GRAFFITI_EDITOR':              ' Graffiti ',
            'ENTER_LABEL':                       '',
            'FREEFORM_PEN_TOOL' :                '',
            'HIGHLIGHTER_TOOL':                  '',
            'ERASER_TOOL':                       '',
            'USE_DISAPPEARING_INK':              '',
            'USE_DASHED_LINES':                  '',
            'DASHED_LINES':                      '',
            'TEMPORARY_INK':                     '',
            'SOLID_FILL':                        '',
            'SHIFT_KEY_ALIGN':                   ' Shift ',
            'PLAY_CONFIRM':                      ' Graffiti ',
            'REPLACE_CONFIRM_BODY_1':            ' Graffiti ',
            'REPLACE_CONFIRM_BODY_2':            '',
            'REPLACE_CONFIRM_BODY_3':            '',
            'ACCESS_MICROPHONE_PROMPT':          '',
            'ACCESS_MICROPHONE_ADVISORY':        '' +
                                                 ' <a href="https://help.aircall.io/hc/en-gb/articles/115001425325-How-to-allow-Google-Chrome-to-access-your-microphone" ' +
                                                 'target="_"></a>',
            'ACTIVATE_GRAFFITI_ADVISORY':        ' Notebook  Graffiti' +
                                                 ' notebook' +
                                                 '<br><br><i>( Notebook )</i>',
            'SCRUB':                             'scrub',
            'TOOLTIP_HINT':                      'Click the underlined text (below) to watch a movie about this.',
            'MOVIE_DURATION':                    'Movie duration',
            'INSERT_GRAFFITI_BUTTON_CELL':       '+ Graffiti Button',
            'INSERT_GRAFFITI_BUTTON_CELL_ALT_TAG': 'Insert a Graffiti-enabled button',
            'INSERT_GRAFFITI_TERMINAL':          '+ Terminal',
            'INSERT_GRAFFITI_TERMINAL_ALT_TAG': 'Insert a Graffiti-enabled terminal',
            'INSERT_GRAFFITI_TERMINAL_SUITE':    '+ Terminal Suite',
            'INSERT_GRAFFITI_TERMINAL_SUITE_ALT_TAG': 'Insert a code cell + terminal + button',
            'INSERT_TERMINAL_SUITE_STATUS':      'Inserting a terminal suite, please wait...',
            'JUMP_TO_NOTEBOOK_DIR':              'Jump to Notebook\'s Dir',
            'RESET_TERMINAL':                    'Reset',
            'CELL_EXECUTES_GRAFFITI':            'Code Cell, Executes Graffiti',
            'CELL_EXECUTE_CHOICE':               'Now click on the element that contains the Graffiti you want this cell to run...',
            'CELL_EXECUTE_CHOICE_SET':           'Your choice has been saved.',
            'ACTIVATE_LOCK_ALT_TAG':             'Lock/unlock all markdown cells',
            'CREATE_SHOWHIDE_BUTTON':            'Create show/hide button',
            'LOCK_VERB':                         'Lock',
            'UNLOCK_VERB':                       'Unlock',
            'UNLOCK_BODY':                       'This will unlock all markdown cells so you can edit them (note: terminal cells are always locked).',
            'LOCK_BODY':                         'This will lock all markdown cells so they can no longer be edited.',
            'LOCK_CONFIRM':                      'markdown cells in notebook?',
          };
          break;
      }
    },

    init: () => {
      localizer.translations = {};
      localizer.loadLocale('EN');
      localizer.loadLocale('CN');

      const notebook = Jupyter.notebook;
      localizer.setLanguage('EN');
      if (notebook.metadata.hasOwnProperty('graffiti')) {
        if (notebook.metadata.graffiti.hasOwnProperty('language')) {
          localizer.setLanguage(notebook.metadata.graffiti.language);
        }
      }

// Load localized strings for China. Paths not working right now, so we're using an inline solution instead, see above
/*      
      return new Promise((resolve) => {
        requirejs(['/nbextensions/graffiti_extension/js/locales/cn/strings.js'], function (strings) {
          console.log('Fetched lang strings');
          localizer.translations['CN'] = strings.getTranslations();
          console.log('we loaded chinese translations.');
          //localizer.setLanguage('CN');
          resolve();
        });
      });
*/

      return Promise.resolve();

    },

  };

  return (localizer);

});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('js/xterm/xterm.js',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Terminal = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Strings = require("./Strings");
var Platform_1 = require("./core/Platform");
var RenderDebouncer_1 = require("./ui/RenderDebouncer");
var Lifecycle_1 = require("./ui/Lifecycle");
var Lifecycle_2 = require("./common/Lifecycle");
var MAX_ROWS_TO_READ = 20;
var AccessibilityManager = (function (_super) {
    __extends(AccessibilityManager, _super);
    function AccessibilityManager(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._liveRegionLineCount = 0;
        _this._charsToConsume = [];
        _this._accessibilityTreeRoot = document.createElement('div');
        _this._accessibilityTreeRoot.classList.add('xterm-accessibility');
        _this._rowContainer = document.createElement('div');
        _this._rowContainer.classList.add('xterm-accessibility-tree');
        _this._rowElements = [];
        for (var i = 0; i < _this._terminal.rows; i++) {
            _this._rowElements[i] = _this._createAccessibilityTreeNode();
            _this._rowContainer.appendChild(_this._rowElements[i]);
        }
        _this._topBoundaryFocusListener = function (e) { return _this._onBoundaryFocus(e, 0); };
        _this._bottomBoundaryFocusListener = function (e) { return _this._onBoundaryFocus(e, 1); };
        _this._rowElements[0].addEventListener('focus', _this._topBoundaryFocusListener);
        _this._rowElements[_this._rowElements.length - 1].addEventListener('focus', _this._bottomBoundaryFocusListener);
        _this._refreshRowsDimensions();
        _this._accessibilityTreeRoot.appendChild(_this._rowContainer);
        _this._renderRowsDebouncer = new RenderDebouncer_1.RenderDebouncer(_this._terminal, _this._renderRows.bind(_this));
        _this._refreshRows();
        _this._liveRegion = document.createElement('div');
        _this._liveRegion.classList.add('live-region');
        _this._liveRegion.setAttribute('aria-live', 'assertive');
        _this._accessibilityTreeRoot.appendChild(_this._liveRegion);
        _this._terminal.element.insertAdjacentElement('afterbegin', _this._accessibilityTreeRoot);
        _this.register(_this._renderRowsDebouncer);
        _this.register(_this._terminal.addDisposableListener('resize', function (data) { return _this._onResize(data.rows); }));
        _this.register(_this._terminal.addDisposableListener('refresh', function (data) { return _this._refreshRows(data.start, data.end); }));
        _this.register(_this._terminal.addDisposableListener('scroll', function (data) { return _this._refreshRows(); }));
        _this.register(_this._terminal.addDisposableListener('a11y.char', function (char) { return _this._onChar(char); }));
        _this.register(_this._terminal.addDisposableListener('linefeed', function () { return _this._onChar('\n'); }));
        _this.register(_this._terminal.addDisposableListener('a11y.tab', function (spaceCount) { return _this._onTab(spaceCount); }));
        _this.register(_this._terminal.addDisposableListener('key', function (keyChar) { return _this._onKey(keyChar); }));
        _this.register(_this._terminal.addDisposableListener('blur', function () { return _this._clearLiveRegion(); }));
        _this.register(_this._terminal.addDisposableListener('dprchange', function () { return _this._refreshRowsDimensions(); }));
        _this.register(_this._terminal.renderer.addDisposableListener('resize', function () { return _this._refreshRowsDimensions(); }));
        _this.register(Lifecycle_1.addDisposableDomListener(window, 'resize', function () { return _this._refreshRowsDimensions(); }));
        return _this;
    }
    AccessibilityManager.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._terminal.element.removeChild(this._accessibilityTreeRoot);
        this._rowElements.length = 0;
    };
    AccessibilityManager.prototype._onBoundaryFocus = function (e, position) {
        var boundaryElement = e.target;
        var beforeBoundaryElement = this._rowElements[position === 0 ? 1 : this._rowElements.length - 2];
        var posInSet = boundaryElement.getAttribute('aria-posinset');
        var lastRowPos = position === 0 ? '1' : "" + this._terminal.buffer.lines.length;
        if (posInSet === lastRowPos) {
            return;
        }
        if (e.relatedTarget !== beforeBoundaryElement) {
            return;
        }
        var topBoundaryElement;
        var bottomBoundaryElement;
        if (position === 0) {
            topBoundaryElement = boundaryElement;
            bottomBoundaryElement = this._rowElements.pop();
            this._rowContainer.removeChild(bottomBoundaryElement);
        }
        else {
            topBoundaryElement = this._rowElements.shift();
            bottomBoundaryElement = boundaryElement;
            this._rowContainer.removeChild(topBoundaryElement);
        }
        topBoundaryElement.removeEventListener('focus', this._topBoundaryFocusListener);
        bottomBoundaryElement.removeEventListener('focus', this._bottomBoundaryFocusListener);
        if (position === 0) {
            var newElement = this._createAccessibilityTreeNode();
            this._rowElements.unshift(newElement);
            this._rowContainer.insertAdjacentElement('afterbegin', newElement);
        }
        else {
            var newElement = this._createAccessibilityTreeNode();
            this._rowElements.push(newElement);
            this._rowContainer.appendChild(newElement);
        }
        this._rowElements[0].addEventListener('focus', this._topBoundaryFocusListener);
        this._rowElements[this._rowElements.length - 1].addEventListener('focus', this._bottomBoundaryFocusListener);
        this._terminal.scrollLines(position === 0 ? -1 : 1);
        this._rowElements[position === 0 ? 1 : this._rowElements.length - 2].focus();
        e.preventDefault();
        e.stopImmediatePropagation();
    };
    AccessibilityManager.prototype._onResize = function (rows) {
        this._rowElements[this._rowElements.length - 1].removeEventListener('focus', this._bottomBoundaryFocusListener);
        for (var i = this._rowContainer.children.length; i < this._terminal.rows; i++) {
            this._rowElements[i] = this._createAccessibilityTreeNode();
            this._rowContainer.appendChild(this._rowElements[i]);
        }
        while (this._rowElements.length > rows) {
            this._rowContainer.removeChild(this._rowElements.pop());
        }
        this._rowElements[this._rowElements.length - 1].addEventListener('focus', this._bottomBoundaryFocusListener);
        this._refreshRowsDimensions();
    };
    AccessibilityManager.prototype._createAccessibilityTreeNode = function () {
        var element = document.createElement('div');
        element.setAttribute('role', 'listitem');
        element.tabIndex = -1;
        this._refreshRowDimensions(element);
        return element;
    };
    AccessibilityManager.prototype._onTab = function (spaceCount) {
        for (var i = 0; i < spaceCount; i++) {
            this._onChar(' ');
        }
    };
    AccessibilityManager.prototype._onChar = function (char) {
        var _this = this;
        if (this._liveRegionLineCount < MAX_ROWS_TO_READ + 1) {
            if (this._charsToConsume.length > 0) {
                var shiftedChar = this._charsToConsume.shift();
                if (shiftedChar !== char) {
                    this._announceCharacter(char);
                }
            }
            else {
                this._announceCharacter(char);
            }
            if (char === '\n') {
                this._liveRegionLineCount++;
                if (this._liveRegionLineCount === MAX_ROWS_TO_READ + 1) {
                    this._liveRegion.textContent += Strings.tooMuchOutput;
                }
            }
            if (Platform_1.isMac) {
                if (this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode) {
                    setTimeout(function () {
                        _this._accessibilityTreeRoot.appendChild(_this._liveRegion);
                    }, 0);
                }
            }
        }
    };
    AccessibilityManager.prototype._clearLiveRegion = function () {
        this._liveRegion.textContent = '';
        this._liveRegionLineCount = 0;
        if (Platform_1.isMac) {
            if (this._liveRegion.parentNode) {
                this._accessibilityTreeRoot.removeChild(this._liveRegion);
            }
        }
    };
    AccessibilityManager.prototype._onKey = function (keyChar) {
        this._clearLiveRegion();
        this._charsToConsume.push(keyChar);
    };
    AccessibilityManager.prototype._refreshRows = function (start, end) {
        this._renderRowsDebouncer.refresh(start, end);
    };
    AccessibilityManager.prototype._renderRows = function (start, end) {
        var buffer = this._terminal.buffer;
        var setSize = buffer.lines.length.toString();
        for (var i = start; i <= end; i++) {
            var lineData = buffer.translateBufferLineToString(buffer.ydisp + i, true);
            var posInSet = (buffer.ydisp + i + 1).toString();
            var element = this._rowElements[i];
            element.textContent = lineData.length === 0 ? Strings.blankLine : lineData;
            element.setAttribute('aria-posinset', posInSet);
            element.setAttribute('aria-setsize', setSize);
        }
    };
    AccessibilityManager.prototype._refreshRowsDimensions = function () {
        if (!this._terminal.renderer.dimensions.actualCellHeight) {
            return;
        }
        if (this._rowElements.length !== this._terminal.rows) {
            this._onResize(this._terminal.rows);
        }
        for (var i = 0; i < this._terminal.rows; i++) {
            this._refreshRowDimensions(this._rowElements[i]);
        }
    };
    AccessibilityManager.prototype._refreshRowDimensions = function (element) {
        element.style.height = this._terminal.renderer.dimensions.actualCellHeight + "px";
    };
    AccessibilityManager.prototype._announceCharacter = function (char) {
        if (char === ' ') {
            this._liveRegion.innerHTML += '&nbsp;';
        }
        else {
            this._liveRegion.textContent += char;
        }
    };
    return AccessibilityManager;
}(Lifecycle_2.Disposable));
exports.AccessibilityManager = AccessibilityManager;

},{"./Strings":14,"./common/Lifecycle":20,"./core/Platform":23,"./ui/Lifecycle":51,"./ui/RenderDebouncer":54}],2:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BufferLine_1 = require("./BufferLine");
var BufferReflow_1 = require("./BufferReflow");
var CircularList_1 = require("./common/CircularList");
var EventEmitter_1 = require("./common/EventEmitter");
var Types_1 = require("./renderer/atlas/Types");
exports.DEFAULT_ATTR = (0 << 18) | (Types_1.DEFAULT_COLOR << 9) | (256 << 0);
exports.CHAR_DATA_ATTR_INDEX = 0;
exports.CHAR_DATA_CHAR_INDEX = 1;
exports.CHAR_DATA_WIDTH_INDEX = 2;
exports.CHAR_DATA_CODE_INDEX = 3;
exports.MAX_BUFFER_SIZE = 4294967295;
exports.NULL_CELL_CHAR = '';
exports.NULL_CELL_WIDTH = 1;
exports.NULL_CELL_CODE = 0;
exports.WHITESPACE_CELL_CHAR = ' ';
exports.WHITESPACE_CELL_WIDTH = 1;
exports.WHITESPACE_CELL_CODE = 32;
exports.FILL_CHAR_DATA = [exports.DEFAULT_ATTR, exports.NULL_CELL_CHAR, exports.NULL_CELL_WIDTH, exports.NULL_CELL_CODE];
var Buffer = (function () {
    function Buffer(_terminal, _hasScrollback) {
        this._terminal = _terminal;
        this._hasScrollback = _hasScrollback;
        this.markers = [];
        this._cols = this._terminal.cols;
        this._rows = this._terminal.rows;
        this.clear();
    }
    Buffer.prototype.getBlankLine = function (attr, isWrapped) {
        var fillCharData = [attr, exports.NULL_CELL_CHAR, exports.NULL_CELL_WIDTH, exports.NULL_CELL_CODE];
        return new BufferLine_1.BufferLine(this._cols, fillCharData, isWrapped);
    };
    Object.defineProperty(Buffer.prototype, "hasScrollback", {
        get: function () {
            return this._hasScrollback && this.lines.maxLength > this._rows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Buffer.prototype, "isCursorInViewport", {
        get: function () {
            var absoluteY = this.ybase + this.y;
            var relativeY = absoluteY - this.ydisp;
            return (relativeY >= 0 && relativeY < this._rows);
        },
        enumerable: true,
        configurable: true
    });
    Buffer.prototype._getCorrectBufferLength = function (rows) {
        if (!this._hasScrollback) {
            return rows;
        }
        var correctBufferLength = rows + this._terminal.options.scrollback;
        return correctBufferLength > exports.MAX_BUFFER_SIZE ? exports.MAX_BUFFER_SIZE : correctBufferLength;
    };
    Buffer.prototype.fillViewportRows = function (fillAttr) {
        if (this.lines.length === 0) {
            if (fillAttr === undefined) {
                fillAttr = exports.DEFAULT_ATTR;
            }
            var i = this._rows;
            while (i--) {
                this.lines.push(this.getBlankLine(fillAttr));
            }
        }
    };
    Buffer.prototype.clear = function () {
        this.ydisp = 0;
        this.ybase = 0;
        this.y = 0;
        this.x = 0;
        this.lines = new CircularList_1.CircularList(this._getCorrectBufferLength(this._rows));
        this.scrollTop = 0;
        this.scrollBottom = this._rows - 1;
        this.setupTabStops();
    };
    Buffer.prototype.resize = function (newCols, newRows) {
        var newMaxLength = this._getCorrectBufferLength(newRows);
        if (newMaxLength > this.lines.maxLength) {
            this.lines.maxLength = newMaxLength;
        }
        if (this.lines.length > 0) {
            if (this._cols < newCols) {
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines.get(i).resize(newCols, exports.FILL_CHAR_DATA);
                }
            }
            var addToY = 0;
            if (this._rows < newRows) {
                for (var y = this._rows; y < newRows; y++) {
                    if (this.lines.length < newRows + this.ybase) {
                        if (this.ybase > 0 && this.lines.length <= this.ybase + this.y + addToY + 1) {
                            this.ybase--;
                            addToY++;
                            if (this.ydisp > 0) {
                                this.ydisp--;
                            }
                        }
                        else {
                            this.lines.push(new BufferLine_1.BufferLine(newCols, exports.FILL_CHAR_DATA));
                        }
                    }
                }
            }
            else {
                for (var y = this._rows; y > newRows; y--) {
                    if (this.lines.length > newRows + this.ybase) {
                        if (this.lines.length > this.ybase + this.y + 1) {
                            this.lines.pop();
                        }
                        else {
                            this.ybase++;
                            this.ydisp++;
                        }
                    }
                }
            }
            if (newMaxLength < this.lines.maxLength) {
                var amountToTrim = this.lines.length - newMaxLength;
                if (amountToTrim > 0) {
                    this.lines.trimStart(amountToTrim);
                    this.ybase = Math.max(this.ybase - amountToTrim, 0);
                    this.ydisp = Math.max(this.ydisp - amountToTrim, 0);
                }
                this.lines.maxLength = newMaxLength;
            }
            this.x = Math.min(this.x, newCols - 1);
            this.y = Math.min(this.y, newRows - 1);
            if (addToY) {
                this.y += addToY;
            }
            this.savedY = Math.min(this.savedY, newRows - 1);
            this.savedX = Math.min(this.savedX, newCols - 1);
            this.scrollTop = 0;
        }
        this.scrollBottom = newRows - 1;
        if (this._hasScrollback) {
            this._reflow(newCols, newRows);
            if (this._cols > newCols) {
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines.get(i).resize(newCols, exports.FILL_CHAR_DATA);
                }
            }
        }
        this._cols = newCols;
        this._rows = newRows;
    };
    Buffer.prototype._reflow = function (newCols, newRows) {
        if (this._cols === newCols) {
            return;
        }
        if (newCols > this._cols) {
            this._reflowLarger(newCols);
        }
        else {
            this._reflowSmaller(newCols, newRows);
        }
    };
    Buffer.prototype._reflowLarger = function (newCols) {
        var toRemove = BufferReflow_1.reflowLargerGetLinesToRemove(this.lines, newCols, this.ybase + this.y);
        if (toRemove.length > 0) {
            var newLayoutResult = BufferReflow_1.reflowLargerCreateNewLayout(this.lines, toRemove);
            BufferReflow_1.reflowLargerApplyNewLayout(this.lines, newLayoutResult.layout);
            this._reflowLargerAdjustViewport(newCols, newLayoutResult.countRemoved);
        }
    };
    Buffer.prototype._reflowLargerAdjustViewport = function (newCols, countRemoved) {
        var viewportAdjustments = countRemoved;
        while (viewportAdjustments-- > 0) {
            if (this.ybase === 0) {
                if (this.y > 0) {
                    this.y--;
                }
                if (this.lines.length < this._rows) {
                    this.lines.push(new BufferLine_1.BufferLine(newCols, exports.FILL_CHAR_DATA));
                }
            }
            else {
                if (this.ydisp === this.ybase) {
                    this.ydisp--;
                }
                this.ybase--;
            }
        }
    };
    Buffer.prototype._reflowSmaller = function (newCols, newRows) {
        var toInsert = [];
        var countToInsert = 0;
        for (var y = this.lines.length - 1; y >= 0; y--) {
            var nextLine = this.lines.get(y);
            if (!nextLine.isWrapped && nextLine.getTrimmedLength() <= newCols) {
                continue;
            }
            var wrappedLines = [nextLine];
            while (nextLine.isWrapped && y > 0) {
                nextLine = this.lines.get(--y);
                wrappedLines.unshift(nextLine);
            }
            var absoluteY = this.ybase + this.y;
            if (absoluteY >= y && absoluteY < y + wrappedLines.length) {
                continue;
            }
            var lastLineLength = wrappedLines[wrappedLines.length - 1].getTrimmedLength();
            var destLineLengths = BufferReflow_1.reflowSmallerGetNewLineLengths(wrappedLines, this._cols, newCols);
            var linesToAdd = destLineLengths.length - wrappedLines.length;
            var trimmedLines = void 0;
            if (this.ybase === 0 && this.y !== this.lines.length - 1) {
                trimmedLines = Math.max(0, this.y - this.lines.maxLength + linesToAdd);
            }
            else {
                trimmedLines = Math.max(0, this.lines.length - this.lines.maxLength + linesToAdd);
            }
            var newLines = [];
            for (var i = 0; i < linesToAdd; i++) {
                var newLine = this.getBlankLine(exports.DEFAULT_ATTR, true);
                newLines.push(newLine);
            }
            if (newLines.length > 0) {
                toInsert.push({
                    start: y + wrappedLines.length + countToInsert,
                    newLines: newLines
                });
                countToInsert += newLines.length;
            }
            wrappedLines.push.apply(wrappedLines, newLines);
            var destLineIndex = destLineLengths.length - 1;
            var destCol = destLineLengths[destLineIndex];
            if (destCol === 0) {
                destLineIndex--;
                destCol = destLineLengths[destLineIndex];
            }
            var srcLineIndex = wrappedLines.length - linesToAdd - 1;
            var srcCol = lastLineLength;
            while (srcLineIndex >= 0) {
                var cellsToCopy = Math.min(srcCol, destCol);
                wrappedLines[destLineIndex].copyCellsFrom(wrappedLines[srcLineIndex], srcCol - cellsToCopy, destCol - cellsToCopy, cellsToCopy, true);
                destCol -= cellsToCopy;
                if (destCol === 0) {
                    destLineIndex--;
                    destCol = destLineLengths[destLineIndex];
                }
                srcCol -= cellsToCopy;
                if (srcCol === 0) {
                    srcLineIndex--;
                    srcCol = wrappedLines[Math.max(srcLineIndex, 0)].getTrimmedLength();
                }
            }
            for (var i = 0; i < wrappedLines.length; i++) {
                if (destLineLengths[i] < newCols) {
                    wrappedLines[i].set(destLineLengths[i], exports.FILL_CHAR_DATA);
                }
            }
            var viewportAdjustments = linesToAdd - trimmedLines;
            while (viewportAdjustments-- > 0) {
                if (this.ybase === 0) {
                    if (this.y < this._rows - 1) {
                        this.y++;
                        this.lines.pop();
                    }
                    else {
                        this.ybase++;
                        this.ydisp++;
                    }
                }
                else {
                    if (this.ybase < Math.min(this.lines.maxLength, this.lines.length + countToInsert) - newRows) {
                        if (this.ybase === this.ydisp) {
                            this.ydisp++;
                        }
                        this.ybase++;
                    }
                }
            }
        }
        if (toInsert.length > 0) {
            var insertEvents = [];
            var originalLines = [];
            for (var i = 0; i < this.lines.length; i++) {
                originalLines.push(this.lines.get(i));
            }
            var originalLinesLength = this.lines.length;
            var originalLineIndex = originalLinesLength - 1;
            var nextToInsertIndex = 0;
            var nextToInsert = toInsert[nextToInsertIndex];
            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + countToInsert);
            var countInsertedSoFar = 0;
            for (var i = Math.min(this.lines.maxLength - 1, originalLinesLength + countToInsert - 1); i >= 0; i--) {
                if (nextToInsert && nextToInsert.start > originalLineIndex + countInsertedSoFar) {
                    for (var nextI = nextToInsert.newLines.length - 1; nextI >= 0; nextI--) {
                        this.lines.set(i--, nextToInsert.newLines[nextI]);
                    }
                    i++;
                    insertEvents.push({
                        index: originalLineIndex + 1,
                        amount: nextToInsert.newLines.length
                    });
                    countInsertedSoFar += nextToInsert.newLines.length;
                    nextToInsert = toInsert[++nextToInsertIndex];
                }
                else {
                    this.lines.set(i, originalLines[originalLineIndex--]);
                }
            }
            var insertCountEmitted = 0;
            for (var i = insertEvents.length - 1; i >= 0; i--) {
                insertEvents[i].index += insertCountEmitted;
                this.lines.emit('insert', insertEvents[i]);
                insertCountEmitted += insertEvents[i].amount;
            }
            var amountToTrim = Math.max(0, originalLinesLength + countToInsert - this.lines.maxLength);
            if (amountToTrim > 0) {
                this.lines.emitMayRemoveListeners('trim', amountToTrim);
            }
        }
    };
    Buffer.prototype.stringIndexToBufferIndex = function (lineIndex, stringIndex, trimRight) {
        if (trimRight === void 0) { trimRight = false; }
        while (stringIndex) {
            var line = this.lines.get(lineIndex);
            if (!line) {
                return [-1, -1];
            }
            var length_1 = (trimRight) ? line.getTrimmedLength() : line.length;
            for (var i = 0; i < length_1; ++i) {
                if (line.get(i)[exports.CHAR_DATA_WIDTH_INDEX]) {
                    stringIndex -= line.get(i)[exports.CHAR_DATA_CHAR_INDEX].length || 1;
                }
                if (stringIndex < 0) {
                    return [lineIndex, i];
                }
            }
            lineIndex++;
        }
        return [lineIndex, 0];
    };
    Buffer.prototype.translateBufferLineToString = function (lineIndex, trimRight, startCol, endCol) {
        if (startCol === void 0) { startCol = 0; }
        var line = this.lines.get(lineIndex);
        if (!line) {
            return '';
        }
        return line.translateToString(trimRight, startCol, endCol);
    };
    Buffer.prototype.getWrappedRangeForLine = function (y) {
        var first = y;
        var last = y;
        while (first > 0 && this.lines.get(first).isWrapped) {
            first--;
        }
        while (last + 1 < this.lines.length && this.lines.get(last + 1).isWrapped) {
            last++;
        }
        return { first: first, last: last };
    };
    Buffer.prototype.setupTabStops = function (i) {
        if (i !== null && i !== undefined) {
            if (!this.tabs[i]) {
                i = this.prevStop(i);
            }
        }
        else {
            this.tabs = {};
            i = 0;
        }
        for (; i < this._cols; i += this._terminal.options.tabStopWidth) {
            this.tabs[i] = true;
        }
    };
    Buffer.prototype.prevStop = function (x) {
        if (x === null || x === undefined) {
            x = this.x;
        }
        while (!this.tabs[--x] && x > 0)
            ;
        return x >= this._cols ? this._cols - 1 : x < 0 ? 0 : x;
    };
    Buffer.prototype.nextStop = function (x) {
        if (x === null || x === undefined) {
            x = this.x;
        }
        while (!this.tabs[++x] && x < this._cols)
            ;
        return x >= this._cols ? this._cols - 1 : x < 0 ? 0 : x;
    };
    Buffer.prototype.addMarker = function (y) {
        var _this = this;
        var marker = new Marker(y);
        this.markers.push(marker);
        marker.register(this.lines.addDisposableListener('trim', function (amount) {
            marker.line -= amount;
            if (marker.line < 0) {
                marker.dispose();
            }
        }));
        marker.register(this.lines.addDisposableListener('insert', function (event) {
            if (marker.line >= event.index) {
                marker.line += event.amount;
            }
        }));
        marker.register(this.lines.addDisposableListener('delete', function (event) {
            if (marker.line >= event.index && marker.line < event.index + event.amount) {
                marker.dispose();
            }
            if (marker.line > event.index) {
                marker.line -= event.amount;
            }
        }));
        marker.register(marker.addDisposableListener('dispose', function () { return _this._removeMarker(marker); }));
        return marker;
    };
    Buffer.prototype._removeMarker = function (marker) {
        this.markers.splice(this.markers.indexOf(marker), 1);
    };
    Buffer.prototype.iterator = function (trimRight, startIndex, endIndex, startOverscan, endOverscan) {
        return new BufferStringIterator(this, trimRight, startIndex, endIndex, startOverscan, endOverscan);
    };
    return Buffer;
}());
exports.Buffer = Buffer;
var Marker = (function (_super) {
    __extends(Marker, _super);
    function Marker(line) {
        var _this = _super.call(this) || this;
        _this.line = line;
        _this._id = Marker._nextId++;
        _this.isDisposed = false;
        return _this;
    }
    Object.defineProperty(Marker.prototype, "id", {
        get: function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Marker.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.emit('dispose');
        _super.prototype.dispose.call(this);
    };
    Marker._nextId = 1;
    return Marker;
}(EventEmitter_1.EventEmitter));
exports.Marker = Marker;
var BufferStringIterator = (function () {
    function BufferStringIterator(_buffer, _trimRight, _startIndex, _endIndex, _startOverscan, _endOverscan) {
        if (_startIndex === void 0) { _startIndex = 0; }
        if (_endIndex === void 0) { _endIndex = _buffer.lines.length; }
        if (_startOverscan === void 0) { _startOverscan = 0; }
        if (_endOverscan === void 0) { _endOverscan = 0; }
        this._buffer = _buffer;
        this._trimRight = _trimRight;
        this._startIndex = _startIndex;
        this._endIndex = _endIndex;
        this._startOverscan = _startOverscan;
        this._endOverscan = _endOverscan;
        if (this._startIndex < 0) {
            this._startIndex = 0;
        }
        if (this._endIndex > this._buffer.lines.length) {
            this._endIndex = this._buffer.lines.length;
        }
        this._current = this._startIndex;
    }
    BufferStringIterator.prototype.hasNext = function () {
        return this._current < this._endIndex;
    };
    BufferStringIterator.prototype.next = function () {
        var range = this._buffer.getWrappedRangeForLine(this._current);
        if (range.first < this._startIndex - this._startOverscan) {
            range.first = this._startIndex - this._startOverscan;
        }
        if (range.last > this._endIndex + this._endOverscan) {
            range.last = this._endIndex + this._endOverscan;
        }
        range.first = Math.max(range.first, 0);
        range.last = Math.min(range.last, this._buffer.lines.length);
        var result = '';
        for (var i = range.first; i <= range.last; ++i) {
            result += this._buffer.translateBufferLineToString(i, this._trimRight);
        }
        this._current = range.last + 1;
        return { range: range, content: result };
    };
    return BufferStringIterator;
}());
exports.BufferStringIterator = BufferStringIterator;

},{"./BufferLine":3,"./BufferReflow":4,"./common/CircularList":17,"./common/EventEmitter":19,"./renderer/atlas/Types":46}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("./Buffer");
var CELL_SIZE = 3;
var IS_COMBINED_BIT_MASK = 0x80000000;
var BufferLine = (function () {
    function BufferLine(cols, fillCharData, isWrapped) {
        if (isWrapped === void 0) { isWrapped = false; }
        this.isWrapped = isWrapped;
        this._data = null;
        this._combined = {};
        if (!fillCharData) {
            fillCharData = [0, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
        }
        if (cols) {
            this._data = new Uint32Array(cols * CELL_SIZE);
            for (var i = 0; i < cols; ++i) {
                this.set(i, fillCharData);
            }
        }
        this.length = cols;
    }
    BufferLine.prototype.get = function (index) {
        var stringData = this._data[index * CELL_SIZE + 1];
        return [
            this._data[index * CELL_SIZE + 0],
            (stringData & IS_COMBINED_BIT_MASK)
                ? this._combined[index]
                : (stringData) ? String.fromCharCode(stringData) : '',
            this._data[index * CELL_SIZE + 2],
            (stringData & IS_COMBINED_BIT_MASK)
                ? this._combined[index].charCodeAt(this._combined[index].length - 1)
                : stringData
        ];
    };
    BufferLine.prototype.getWidth = function (index) {
        return this._data[index * CELL_SIZE + 2];
    };
    BufferLine.prototype.set = function (index, value) {
        this._data[index * CELL_SIZE + 0] = value[0];
        if (value[1].length > 1) {
            this._combined[index] = value[1];
            this._data[index * CELL_SIZE + 1] = index | IS_COMBINED_BIT_MASK;
        }
        else {
            this._data[index * CELL_SIZE + 1] = value[1].charCodeAt(0);
        }
        this._data[index * CELL_SIZE + 2] = value[2];
    };
    BufferLine.prototype.insertCells = function (pos, n, fillCharData) {
        pos %= this.length;
        if (n < this.length - pos) {
            for (var i = this.length - pos - n - 1; i >= 0; --i) {
                this.set(pos + n + i, this.get(pos + i));
            }
            for (var i = 0; i < n; ++i) {
                this.set(pos + i, fillCharData);
            }
        }
        else {
            for (var i = pos; i < this.length; ++i) {
                this.set(i, fillCharData);
            }
        }
    };
    BufferLine.prototype.deleteCells = function (pos, n, fillCharData) {
        pos %= this.length;
        if (n < this.length - pos) {
            for (var i = 0; i < this.length - pos - n; ++i) {
                this.set(pos + i, this.get(pos + n + i));
            }
            for (var i = this.length - n; i < this.length; ++i) {
                this.set(i, fillCharData);
            }
        }
        else {
            for (var i = pos; i < this.length; ++i) {
                this.set(i, fillCharData);
            }
        }
    };
    BufferLine.prototype.replaceCells = function (start, end, fillCharData) {
        while (start < end && start < this.length) {
            this.set(start++, fillCharData);
        }
    };
    BufferLine.prototype.resize = function (cols, fillCharData) {
        if (cols === this.length) {
            return;
        }
        if (cols > this.length) {
            var data = new Uint32Array(cols * CELL_SIZE);
            if (this.length) {
                if (cols * CELL_SIZE < this._data.length) {
                    data.set(this._data.subarray(0, cols * CELL_SIZE));
                }
                else {
                    data.set(this._data);
                }
            }
            this._data = data;
            for (var i = this.length; i < cols; ++i) {
                this.set(i, fillCharData);
            }
        }
        else {
            if (cols) {
                var data = new Uint32Array(cols * CELL_SIZE);
                data.set(this._data.subarray(0, cols * CELL_SIZE));
                this._data = data;
                var keys = Object.keys(this._combined);
                for (var i = 0; i < keys.length; i++) {
                    var key = parseInt(keys[i], 10);
                    if (key >= cols) {
                        delete this._combined[key];
                    }
                }
            }
            else {
                this._data = null;
                this._combined = {};
            }
        }
        this.length = cols;
    };
    BufferLine.prototype.fill = function (fillCharData) {
        this._combined = {};
        for (var i = 0; i < this.length; ++i) {
            this.set(i, fillCharData);
        }
    };
    BufferLine.prototype.copyFrom = function (line) {
        if (this.length !== line.length) {
            this._data = new Uint32Array(line._data);
        }
        else {
            this._data.set(line._data);
        }
        this.length = line.length;
        this._combined = {};
        for (var el in line._combined) {
            this._combined[el] = line._combined[el];
        }
        this.isWrapped = line.isWrapped;
    };
    BufferLine.prototype.clone = function () {
        var newLine = new BufferLine(0);
        newLine._data = new Uint32Array(this._data);
        newLine.length = this.length;
        for (var el in this._combined) {
            newLine._combined[el] = this._combined[el];
        }
        newLine.isWrapped = this.isWrapped;
        return newLine;
    };
    BufferLine.prototype.getTrimmedLength = function () {
        for (var i = this.length - 1; i >= 0; --i) {
            if (this._data[i * CELL_SIZE + 1] !== 0) {
                return i + this._data[i * CELL_SIZE + 2];
            }
        }
        return 0;
    };
    BufferLine.prototype.copyCellsFrom = function (src, srcCol, destCol, length, applyInReverse) {
        var srcData = src._data;
        if (applyInReverse) {
            for (var cell = length - 1; cell >= 0; cell--) {
                for (var i = 0; i < CELL_SIZE; i++) {
                    this._data[(destCol + cell) * CELL_SIZE + i] = srcData[(srcCol + cell) * CELL_SIZE + i];
                }
            }
        }
        else {
            for (var cell = 0; cell < length; cell++) {
                for (var i = 0; i < CELL_SIZE; i++) {
                    this._data[(destCol + cell) * CELL_SIZE + i] = srcData[(srcCol + cell) * CELL_SIZE + i];
                }
            }
        }
        var srcCombinedKeys = Object.keys(src._combined);
        for (var i = 0; i < srcCombinedKeys.length; i++) {
            var key = parseInt(srcCombinedKeys[i], 10);
            if (key >= srcCol) {
                this._combined[key - srcCol + destCol] = src._combined[key];
            }
        }
    };
    BufferLine.prototype.translateToString = function (trimRight, startCol, endCol) {
        if (trimRight === void 0) { trimRight = false; }
        if (startCol === void 0) { startCol = 0; }
        if (endCol === void 0) { endCol = this.length; }
        if (trimRight) {
            endCol = Math.min(endCol, this.getTrimmedLength());
        }
        var result = '';
        while (startCol < endCol) {
            var stringData = this._data[startCol * CELL_SIZE + 1];
            result += (stringData & IS_COMBINED_BIT_MASK) ? this._combined[startCol] : (stringData) ? String.fromCharCode(stringData) : Buffer_1.WHITESPACE_CELL_CHAR;
            startCol += this._data[startCol * CELL_SIZE + 2] || 1;
        }
        return result;
    };
    return BufferLine;
}());
exports.BufferLine = BufferLine;

},{"./Buffer":2}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("./Buffer");
function reflowLargerGetLinesToRemove(lines, newCols, bufferAbsoluteY) {
    var toRemove = [];
    for (var y = 0; y < lines.length - 1; y++) {
        var i = y;
        var nextLine = lines.get(++i);
        if (!nextLine.isWrapped) {
            continue;
        }
        var wrappedLines = [lines.get(y)];
        while (i < lines.length && nextLine.isWrapped) {
            wrappedLines.push(nextLine);
            nextLine = lines.get(++i);
        }
        if (bufferAbsoluteY >= y && bufferAbsoluteY < i) {
            y += wrappedLines.length - 1;
            continue;
        }
        var destLineIndex = 0;
        var destCol = wrappedLines[destLineIndex].getTrimmedLength();
        var srcLineIndex = 1;
        var srcCol = 0;
        while (srcLineIndex < wrappedLines.length) {
            var srcTrimmedTineLength = wrappedLines[srcLineIndex].getTrimmedLength();
            var srcRemainingCells = srcTrimmedTineLength - srcCol;
            var destRemainingCells = newCols - destCol;
            var cellsToCopy = Math.min(srcRemainingCells, destRemainingCells);
            wrappedLines[destLineIndex].copyCellsFrom(wrappedLines[srcLineIndex], srcCol, destCol, cellsToCopy, false);
            destCol += cellsToCopy;
            if (destCol === newCols) {
                destLineIndex++;
                destCol = 0;
            }
            srcCol += cellsToCopy;
            if (srcCol === srcTrimmedTineLength) {
                srcLineIndex++;
                srcCol = 0;
            }
            if (destCol === 0 && destLineIndex !== 0) {
                if (wrappedLines[destLineIndex - 1].getWidth(newCols - 1) === 2) {
                    wrappedLines[destLineIndex].copyCellsFrom(wrappedLines[destLineIndex - 1], newCols - 1, destCol++, 1, false);
                    wrappedLines[destLineIndex - 1].set(newCols - 1, Buffer_1.FILL_CHAR_DATA);
                }
            }
        }
        wrappedLines[destLineIndex].replaceCells(destCol, newCols, Buffer_1.FILL_CHAR_DATA);
        var countToRemove = 0;
        for (var i_1 = wrappedLines.length - 1; i_1 > 0; i_1--) {
            if (i_1 > destLineIndex || wrappedLines[i_1].getTrimmedLength() === 0) {
                countToRemove++;
            }
            else {
                break;
            }
        }
        if (countToRemove > 0) {
            toRemove.push(y + wrappedLines.length - countToRemove);
            toRemove.push(countToRemove);
        }
        y += wrappedLines.length - 1;
    }
    return toRemove;
}
exports.reflowLargerGetLinesToRemove = reflowLargerGetLinesToRemove;
function reflowLargerCreateNewLayout(lines, toRemove) {
    var layout = [];
    var nextToRemoveIndex = 0;
    var nextToRemoveStart = toRemove[nextToRemoveIndex];
    var countRemovedSoFar = 0;
    for (var i = 0; i < lines.length; i++) {
        if (nextToRemoveStart === i) {
            var countToRemove = toRemove[++nextToRemoveIndex];
            lines.emit('delete', {
                index: i - countRemovedSoFar,
                amount: countToRemove
            });
            i += countToRemove - 1;
            countRemovedSoFar += countToRemove;
            nextToRemoveStart = toRemove[++nextToRemoveIndex];
        }
        else {
            layout.push(i);
        }
    }
    return {
        layout: layout,
        countRemoved: countRemovedSoFar
    };
}
exports.reflowLargerCreateNewLayout = reflowLargerCreateNewLayout;
function reflowLargerApplyNewLayout(lines, newLayout) {
    var newLayoutLines = [];
    for (var i = 0; i < newLayout.length; i++) {
        newLayoutLines.push(lines.get(newLayout[i]));
    }
    for (var i = 0; i < newLayoutLines.length; i++) {
        lines.set(i, newLayoutLines[i]);
    }
    lines.length = newLayout.length;
}
exports.reflowLargerApplyNewLayout = reflowLargerApplyNewLayout;
function reflowSmallerGetNewLineLengths(wrappedLines, oldCols, newCols) {
    var newLineLengths = [];
    var cellsNeeded = wrappedLines.map(function (l) { return l.getTrimmedLength(); }).reduce(function (p, c) { return p + c; });
    var srcCol = 0;
    var srcLine = 0;
    var cellsAvailable = 0;
    while (cellsAvailable < cellsNeeded) {
        if (cellsNeeded - cellsAvailable < newCols) {
            newLineLengths.push(cellsNeeded - cellsAvailable);
            break;
        }
        srcCol += newCols;
        var oldTrimmedLength = wrappedLines[srcLine].getTrimmedLength();
        if (srcCol > oldTrimmedLength) {
            srcCol -= oldTrimmedLength;
            srcLine++;
        }
        var endsWithWide = wrappedLines[srcLine].getWidth(srcCol - 1) === 2;
        if (endsWithWide) {
            srcCol--;
        }
        var lineLength = endsWithWide ? newCols - 1 : newCols;
        newLineLengths.push(lineLength);
        cellsAvailable += lineLength;
    }
    return newLineLengths;
}
exports.reflowSmallerGetNewLineLengths = reflowSmallerGetNewLineLengths;

},{"./Buffer":2}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("./Buffer");
var EventEmitter_1 = require("./common/EventEmitter");
var BufferSet = (function (_super) {
    __extends(BufferSet, _super);
    function BufferSet(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._normal = new Buffer_1.Buffer(_this._terminal, true);
        _this._normal.fillViewportRows();
        _this._alt = new Buffer_1.Buffer(_this._terminal, false);
        _this._activeBuffer = _this._normal;
        _this.setupTabStops();
        return _this;
    }
    Object.defineProperty(BufferSet.prototype, "alt", {
        get: function () {
            return this._alt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BufferSet.prototype, "active", {
        get: function () {
            return this._activeBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BufferSet.prototype, "normal", {
        get: function () {
            return this._normal;
        },
        enumerable: true,
        configurable: true
    });
    BufferSet.prototype.activateNormalBuffer = function () {
        if (this._activeBuffer === this._normal) {
            return;
        }
        this._normal.x = this._alt.x;
        this._normal.y = this._alt.y;
        this._alt.clear();
        this._activeBuffer = this._normal;
        this.emit('activate', {
            activeBuffer: this._normal,
            inactiveBuffer: this._alt
        });
    };
    BufferSet.prototype.activateAltBuffer = function (fillAttr) {
        if (this._activeBuffer === this._alt) {
            return;
        }
        this._alt.fillViewportRows(fillAttr);
        this._alt.x = this._normal.x;
        this._alt.y = this._normal.y;
        this._activeBuffer = this._alt;
        this.emit('activate', {
            activeBuffer: this._alt,
            inactiveBuffer: this._normal
        });
    };
    BufferSet.prototype.resize = function (newCols, newRows) {
        this._normal.resize(newCols, newRows);
        this._alt.resize(newCols, newRows);
    };
    BufferSet.prototype.setupTabStops = function (i) {
        this._normal.setupTabStops(i);
        this._alt.setupTabStops(i);
    };
    return BufferSet;
}(EventEmitter_1.EventEmitter));
exports.BufferSet = BufferSet;

},{"./Buffer":2,"./common/EventEmitter":19}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TypedArrayUtils_1 = require("./common/TypedArrayUtils");
exports.wcwidth = (function (opts) {
    var COMBINING_BMP = [
        [0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489],
        [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2],
        [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603],
        [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670],
        [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED],
        [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A],
        [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902],
        [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D],
        [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981],
        [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD],
        [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C],
        [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D],
        [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC],
        [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD],
        [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C],
        [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D],
        [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0],
        [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48],
        [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC],
        [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD],
        [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D],
        [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6],
        [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E],
        [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC],
        [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35],
        [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E],
        [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97],
        [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030],
        [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039],
        [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F],
        [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753],
        [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD],
        [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD],
        [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922],
        [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B],
        [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34],
        [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42],
        [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF],
        [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063],
        [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F],
        [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B],
        [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F],
        [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB]
    ];
    var COMBINING_HIGH = [
        [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F],
        [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169],
        [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD],
        [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F],
        [0xE0100, 0xE01EF]
    ];
    function bisearch(ucs, data) {
        var min = 0;
        var max = data.length - 1;
        var mid;
        if (ucs < data[0][0] || ucs > data[max][1]) {
            return false;
        }
        while (max >= min) {
            mid = (min + max) >> 1;
            if (ucs > data[mid][1]) {
                min = mid + 1;
            }
            else if (ucs < data[mid][0]) {
                max = mid - 1;
            }
            else {
                return true;
            }
        }
        return false;
    }
    function wcwidthHigh(ucs) {
        if (bisearch(ucs, COMBINING_HIGH)) {
            return 0;
        }
        if ((ucs >= 0x20000 && ucs <= 0x2fffd) || (ucs >= 0x30000 && ucs <= 0x3fffd)) {
            return 2;
        }
        return 1;
    }
    var control = opts.control | 0;
    var table = new Uint8Array(65536);
    TypedArrayUtils_1.fill(table, 1);
    table[0] = opts.nul;
    TypedArrayUtils_1.fill(table, opts.control, 1, 32);
    TypedArrayUtils_1.fill(table, opts.control, 0x7f, 0xa0);
    TypedArrayUtils_1.fill(table, 2, 0x1100, 0x1160);
    table[0x2329] = 2;
    table[0x232a] = 2;
    TypedArrayUtils_1.fill(table, 2, 0x2e80, 0xa4d0);
    table[0x303f] = 1;
    TypedArrayUtils_1.fill(table, 2, 0xac00, 0xd7a4);
    TypedArrayUtils_1.fill(table, 2, 0xf900, 0xfb00);
    TypedArrayUtils_1.fill(table, 2, 0xfe10, 0xfe1a);
    TypedArrayUtils_1.fill(table, 2, 0xfe30, 0xfe70);
    TypedArrayUtils_1.fill(table, 2, 0xff00, 0xff61);
    TypedArrayUtils_1.fill(table, 2, 0xffe0, 0xffe7);
    for (var r = 0; r < COMBINING_BMP.length; ++r) {
        TypedArrayUtils_1.fill(table, 0, COMBINING_BMP[r][0], COMBINING_BMP[r][1] + 1);
    }
    return function (num) {
        if (num < 32) {
            return control | 0;
        }
        if (num < 127) {
            return 1;
        }
        if (num < 65536) {
            return table[num];
        }
        return wcwidthHigh(num);
    };
})({ nul: 0, control: 0 });
function getStringCellWidth(s) {
    var result = 0;
    var length = s.length;
    for (var i = 0; i < length; ++i) {
        var code = s.charCodeAt(i);
        if (0xD800 <= code && code <= 0xDBFF) {
            if (++i >= length) {
                return result + exports.wcwidth(code);
            }
            var second = s.charCodeAt(i);
            if (0xDC00 <= second && second <= 0xDFFF) {
                code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
            else {
                result += exports.wcwidth(second);
            }
        }
        result += exports.wcwidth(code);
    }
    return result;
}
exports.getStringCellWidth = getStringCellWidth;

},{"./common/TypedArrayUtils":21}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CompositionHelper = (function () {
    function CompositionHelper(_textarea, _compositionView, _terminal) {
        this._textarea = _textarea;
        this._compositionView = _compositionView;
        this._terminal = _terminal;
        this._isComposing = false;
        this._isSendingComposition = false;
        this._compositionPosition = { start: null, end: null };
    }
    CompositionHelper.prototype.compositionstart = function () {
        this._isComposing = true;
        this._compositionPosition.start = this._textarea.value.length;
        this._compositionView.textContent = '';
        this._compositionView.classList.add('active');
    };
    CompositionHelper.prototype.compositionupdate = function (ev) {
        var _this = this;
        this._compositionView.textContent = ev.data;
        this.updateCompositionElements();
        setTimeout(function () {
            _this._compositionPosition.end = _this._textarea.value.length;
        }, 0);
    };
    CompositionHelper.prototype.compositionend = function () {
        this._finalizeComposition(true);
    };
    CompositionHelper.prototype.keydown = function (ev) {
        if (this._isComposing || this._isSendingComposition) {
            if (ev.keyCode === 229) {
                return false;
            }
            else if (ev.keyCode === 16 || ev.keyCode === 17 || ev.keyCode === 18) {
                return false;
            }
            this._finalizeComposition(false);
        }
        if (ev.keyCode === 229) {
            this._handleAnyTextareaChanges();
            return false;
        }
        return true;
    };
    CompositionHelper.prototype._finalizeComposition = function (waitForPropagation) {
        var _this = this;
        this._compositionView.classList.remove('active');
        this._isComposing = false;
        this._clearTextareaPosition();
        if (!waitForPropagation) {
            this._isSendingComposition = false;
            var input = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._terminal.handler(input);
        }
        else {
            var currentCompositionPosition_1 = {
                start: this._compositionPosition.start,
                end: this._compositionPosition.end
            };
            this._isSendingComposition = true;
            setTimeout(function () {
                if (_this._isSendingComposition) {
                    _this._isSendingComposition = false;
                    var input = void 0;
                    if (_this._isComposing) {
                        input = _this._textarea.value.substring(currentCompositionPosition_1.start, currentCompositionPosition_1.end);
                    }
                    else {
                        input = _this._textarea.value.substring(currentCompositionPosition_1.start);
                    }
                    _this._terminal.handler(input);
                }
            }, 0);
        }
    };
    CompositionHelper.prototype._handleAnyTextareaChanges = function () {
        var _this = this;
        var oldValue = this._textarea.value;
        setTimeout(function () {
            if (!_this._isComposing) {
                var newValue = _this._textarea.value;
                var diff = newValue.replace(oldValue, '');
                if (diff.length > 0) {
                    _this._terminal.handler(diff);
                }
            }
        }, 0);
    };
    CompositionHelper.prototype.updateCompositionElements = function (dontRecurse) {
        var _this = this;
        if (!this._isComposing) {
            return;
        }
        if (this._terminal.buffer.isCursorInViewport) {
            var cellHeight = Math.ceil(this._terminal.charMeasure.height * this._terminal.options.lineHeight);
            var cursorTop = this._terminal.buffer.y * cellHeight;
            var cursorLeft = this._terminal.buffer.x * this._terminal.charMeasure.width;
            this._compositionView.style.left = cursorLeft + 'px';
            this._compositionView.style.top = cursorTop + 'px';
            this._compositionView.style.height = cellHeight + 'px';
            this._compositionView.style.lineHeight = cellHeight + 'px';
            var compositionViewBounds = this._compositionView.getBoundingClientRect();
            this._textarea.style.left = cursorLeft + 'px';
            this._textarea.style.top = cursorTop + 'px';
            this._textarea.style.width = compositionViewBounds.width + 'px';
            this._textarea.style.height = compositionViewBounds.height + 'px';
            this._textarea.style.lineHeight = compositionViewBounds.height + 'px';
        }
        if (!dontRecurse) {
            setTimeout(function () { return _this.updateCompositionElements(true); }, 0);
        }
    };
    CompositionHelper.prototype._clearTextareaPosition = function () {
        this._textarea.style.left = '';
        this._textarea.style.top = '';
    };
    return CompositionHelper;
}());
exports.CompositionHelper = CompositionHelper;

},{}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = require("./common/Lifecycle");
var TextDecoder_1 = require("./core/input/TextDecoder");
function r(low, high) {
    var c = high - low;
    var arr = new Array(c);
    while (c--) {
        arr[c] = --high;
    }
    return arr;
}
var TransitionTable = (function () {
    function TransitionTable(length) {
        this.table = (typeof Uint8Array === 'undefined')
            ? new Array(length)
            : new Uint8Array(length);
    }
    TransitionTable.prototype.add = function (code, state, action, next) {
        this.table[state << 8 | code] = ((action | 0) << 4) | ((next === undefined) ? state : next);
    };
    TransitionTable.prototype.addMany = function (codes, state, action, next) {
        for (var i = 0; i < codes.length; i++) {
            this.add(codes[i], state, action, next);
        }
    };
    return TransitionTable;
}());
exports.TransitionTable = TransitionTable;
var PRINTABLES = r(0x20, 0x7f);
var EXECUTABLES = r(0x00, 0x18);
EXECUTABLES.push(0x19);
EXECUTABLES.push.apply(EXECUTABLES, r(0x1c, 0x20));
var NON_ASCII_PRINTABLE = 0xA0;
exports.VT500_TRANSITION_TABLE = (function () {
    var table = new TransitionTable(4095);
    var states = r(0, 13 + 1);
    var state;
    for (state in states) {
        for (var code = 0; code <= NON_ASCII_PRINTABLE; ++code) {
            table.add(code, state, 1, 0);
        }
    }
    table.addMany(PRINTABLES, 0, 2, 0);
    for (state in states) {
        table.addMany([0x18, 0x1a, 0x99, 0x9a], state, 3, 0);
        table.addMany(r(0x80, 0x90), state, 3, 0);
        table.addMany(r(0x90, 0x98), state, 3, 0);
        table.add(0x9c, state, 0, 0);
        table.add(0x1b, state, 11, 1);
        table.add(0x9d, state, 4, 8);
        table.addMany([0x98, 0x9e, 0x9f], state, 0, 7);
        table.add(0x9b, state, 11, 3);
        table.add(0x90, state, 11, 9);
    }
    table.addMany(EXECUTABLES, 0, 3, 0);
    table.addMany(EXECUTABLES, 1, 3, 1);
    table.add(0x7f, 1, 0, 1);
    table.addMany(EXECUTABLES, 8, 0, 8);
    table.addMany(EXECUTABLES, 3, 3, 3);
    table.add(0x7f, 3, 0, 3);
    table.addMany(EXECUTABLES, 4, 3, 4);
    table.add(0x7f, 4, 0, 4);
    table.addMany(EXECUTABLES, 6, 3, 6);
    table.addMany(EXECUTABLES, 5, 3, 5);
    table.add(0x7f, 5, 0, 5);
    table.addMany(EXECUTABLES, 2, 3, 2);
    table.add(0x7f, 2, 0, 2);
    table.add(0x5d, 1, 4, 8);
    table.addMany(PRINTABLES, 8, 5, 8);
    table.add(0x7f, 8, 5, 8);
    table.addMany([0x9c, 0x1b, 0x18, 0x1a, 0x07], 8, 6, 0);
    table.addMany(r(0x1c, 0x20), 8, 0, 8);
    table.addMany([0x58, 0x5e, 0x5f], 1, 0, 7);
    table.addMany(PRINTABLES, 7, 0, 7);
    table.addMany(EXECUTABLES, 7, 0, 7);
    table.add(0x9c, 7, 0, 0);
    table.add(0x7f, 7, 0, 7);
    table.add(0x5b, 1, 11, 3);
    table.addMany(r(0x40, 0x7f), 3, 7, 0);
    table.addMany(r(0x30, 0x3a), 3, 8, 4);
    table.add(0x3b, 3, 8, 4);
    table.addMany([0x3c, 0x3d, 0x3e, 0x3f], 3, 9, 4);
    table.addMany(r(0x30, 0x3a), 4, 8, 4);
    table.add(0x3b, 4, 8, 4);
    table.addMany(r(0x40, 0x7f), 4, 7, 0);
    table.addMany([0x3a, 0x3c, 0x3d, 0x3e, 0x3f], 4, 0, 6);
    table.addMany(r(0x20, 0x40), 6, 0, 6);
    table.add(0x7f, 6, 0, 6);
    table.addMany(r(0x40, 0x7f), 6, 0, 0);
    table.add(0x3a, 3, 0, 6);
    table.addMany(r(0x20, 0x30), 3, 9, 5);
    table.addMany(r(0x20, 0x30), 5, 9, 5);
    table.addMany(r(0x30, 0x40), 5, 0, 6);
    table.addMany(r(0x40, 0x7f), 5, 7, 0);
    table.addMany(r(0x20, 0x30), 4, 9, 5);
    table.addMany(r(0x20, 0x30), 1, 9, 2);
    table.addMany(r(0x20, 0x30), 2, 9, 2);
    table.addMany(r(0x30, 0x7f), 2, 10, 0);
    table.addMany(r(0x30, 0x50), 1, 10, 0);
    table.addMany(r(0x51, 0x58), 1, 10, 0);
    table.addMany([0x59, 0x5a, 0x5c], 1, 10, 0);
    table.addMany(r(0x60, 0x7f), 1, 10, 0);
    table.add(0x50, 1, 11, 9);
    table.addMany(EXECUTABLES, 9, 0, 9);
    table.add(0x7f, 9, 0, 9);
    table.addMany(r(0x1c, 0x20), 9, 0, 9);
    table.addMany(r(0x20, 0x30), 9, 9, 12);
    table.add(0x3a, 9, 0, 11);
    table.addMany(r(0x30, 0x3a), 9, 8, 10);
    table.add(0x3b, 9, 8, 10);
    table.addMany([0x3c, 0x3d, 0x3e, 0x3f], 9, 9, 10);
    table.addMany(EXECUTABLES, 11, 0, 11);
    table.addMany(r(0x20, 0x80), 11, 0, 11);
    table.addMany(r(0x1c, 0x20), 11, 0, 11);
    table.addMany(EXECUTABLES, 10, 0, 10);
    table.add(0x7f, 10, 0, 10);
    table.addMany(r(0x1c, 0x20), 10, 0, 10);
    table.addMany(r(0x30, 0x3a), 10, 8, 10);
    table.add(0x3b, 10, 8, 10);
    table.addMany([0x3a, 0x3c, 0x3d, 0x3e, 0x3f], 10, 0, 11);
    table.addMany(r(0x20, 0x30), 10, 9, 12);
    table.addMany(EXECUTABLES, 12, 0, 12);
    table.add(0x7f, 12, 0, 12);
    table.addMany(r(0x1c, 0x20), 12, 0, 12);
    table.addMany(r(0x20, 0x30), 12, 9, 12);
    table.addMany(r(0x30, 0x40), 12, 0, 11);
    table.addMany(r(0x40, 0x7f), 12, 12, 13);
    table.addMany(r(0x40, 0x7f), 10, 12, 13);
    table.addMany(r(0x40, 0x7f), 9, 12, 13);
    table.addMany(EXECUTABLES, 13, 13, 13);
    table.addMany(PRINTABLES, 13, 13, 13);
    table.add(0x7f, 13, 0, 13);
    table.addMany([0x1b, 0x9c], 13, 14, 0);
    table.add(NON_ASCII_PRINTABLE, 8, 5, 8);
    return table;
})();
var DcsDummy = (function () {
    function DcsDummy() {
    }
    DcsDummy.prototype.hook = function (collect, params, flag) { };
    DcsDummy.prototype.put = function (data, start, end) { };
    DcsDummy.prototype.unhook = function () { };
    return DcsDummy;
}());
var EscapeSequenceParser = (function (_super) {
    __extends(EscapeSequenceParser, _super);
    function EscapeSequenceParser(TRANSITIONS) {
        if (TRANSITIONS === void 0) { TRANSITIONS = exports.VT500_TRANSITION_TABLE; }
        var _this = _super.call(this) || this;
        _this.TRANSITIONS = TRANSITIONS;
        _this.initialState = 0;
        _this.currentState = _this.initialState;
        _this._osc = '';
        _this._params = [0];
        _this._collect = '';
        _this._printHandlerFb = function (data, start, end) { };
        _this._executeHandlerFb = function (code) { };
        _this._csiHandlerFb = function (collect, params, flag) { };
        _this._escHandlerFb = function (collect, flag) { };
        _this._oscHandlerFb = function (identifier, data) { };
        _this._dcsHandlerFb = new DcsDummy();
        _this._errorHandlerFb = function (state) { return state; };
        _this._printHandler = _this._printHandlerFb;
        _this._executeHandlers = Object.create(null);
        _this._csiHandlers = Object.create(null);
        _this._escHandlers = Object.create(null);
        _this._oscHandlers = Object.create(null);
        _this._dcsHandlers = Object.create(null);
        _this._activeDcsHandler = null;
        _this._errorHandler = _this._errorHandlerFb;
        _this.setEscHandler('\\', function () { });
        return _this;
    }
    EscapeSequenceParser.prototype.dispose = function () {
        this._printHandlerFb = null;
        this._executeHandlerFb = null;
        this._csiHandlerFb = null;
        this._escHandlerFb = null;
        this._oscHandlerFb = null;
        this._dcsHandlerFb = null;
        this._errorHandlerFb = null;
        this._printHandler = null;
        this._executeHandlers = null;
        this._escHandlers = null;
        this._csiHandlers = null;
        this._oscHandlers = null;
        this._dcsHandlers = null;
        this._activeDcsHandler = null;
        this._errorHandler = null;
    };
    EscapeSequenceParser.prototype.setPrintHandler = function (callback) {
        this._printHandler = callback;
    };
    EscapeSequenceParser.prototype.clearPrintHandler = function () {
        this._printHandler = this._printHandlerFb;
    };
    EscapeSequenceParser.prototype.setExecuteHandler = function (flag, callback) {
        this._executeHandlers[flag.charCodeAt(0)] = callback;
    };
    EscapeSequenceParser.prototype.clearExecuteHandler = function (flag) {
        if (this._executeHandlers[flag.charCodeAt(0)])
            delete this._executeHandlers[flag.charCodeAt(0)];
    };
    EscapeSequenceParser.prototype.setExecuteHandlerFallback = function (callback) {
        this._executeHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.addCsiHandler = function (flag, callback) {
        var index = flag.charCodeAt(0);
        if (this._csiHandlers[index] === undefined) {
            this._csiHandlers[index] = [];
        }
        var handlerList = this._csiHandlers[index];
        handlerList.push(callback);
        return {
            dispose: function () {
                var handlerIndex = handlerList.indexOf(callback);
                if (handlerIndex !== -1) {
                    handlerList.splice(handlerIndex, 1);
                }
            }
        };
    };
    EscapeSequenceParser.prototype.setCsiHandler = function (flag, callback) {
        this._csiHandlers[flag.charCodeAt(0)] = [callback];
    };
    EscapeSequenceParser.prototype.clearCsiHandler = function (flag) {
        if (this._csiHandlers[flag.charCodeAt(0)])
            delete this._csiHandlers[flag.charCodeAt(0)];
    };
    EscapeSequenceParser.prototype.setCsiHandlerFallback = function (callback) {
        this._csiHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.setEscHandler = function (collectAndFlag, callback) {
        this._escHandlers[collectAndFlag] = callback;
    };
    EscapeSequenceParser.prototype.clearEscHandler = function (collectAndFlag) {
        if (this._escHandlers[collectAndFlag])
            delete this._escHandlers[collectAndFlag];
    };
    EscapeSequenceParser.prototype.setEscHandlerFallback = function (callback) {
        this._escHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.addOscHandler = function (ident, callback) {
        if (this._oscHandlers[ident] === undefined) {
            this._oscHandlers[ident] = [];
        }
        var handlerList = this._oscHandlers[ident];
        handlerList.push(callback);
        return {
            dispose: function () {
                var handlerIndex = handlerList.indexOf(callback);
                if (handlerIndex !== -1) {
                    handlerList.splice(handlerIndex, 1);
                }
            }
        };
    };
    EscapeSequenceParser.prototype.setOscHandler = function (ident, callback) {
        this._oscHandlers[ident] = [callback];
    };
    EscapeSequenceParser.prototype.clearOscHandler = function (ident) {
        if (this._oscHandlers[ident])
            delete this._oscHandlers[ident];
    };
    EscapeSequenceParser.prototype.setOscHandlerFallback = function (callback) {
        this._oscHandlerFb = callback;
    };
    EscapeSequenceParser.prototype.setDcsHandler = function (collectAndFlag, handler) {
        this._dcsHandlers[collectAndFlag] = handler;
    };
    EscapeSequenceParser.prototype.clearDcsHandler = function (collectAndFlag) {
        if (this._dcsHandlers[collectAndFlag])
            delete this._dcsHandlers[collectAndFlag];
    };
    EscapeSequenceParser.prototype.setDcsHandlerFallback = function (handler) {
        this._dcsHandlerFb = handler;
    };
    EscapeSequenceParser.prototype.setErrorHandler = function (callback) {
        this._errorHandler = callback;
    };
    EscapeSequenceParser.prototype.clearErrorHandler = function () {
        this._errorHandler = this._errorHandlerFb;
    };
    EscapeSequenceParser.prototype.reset = function () {
        this.currentState = this.initialState;
        this._osc = '';
        this._params = [0];
        this._collect = '';
        this._activeDcsHandler = null;
    };
    EscapeSequenceParser.prototype.parse = function (data, length) {
        var code = 0;
        var transition = 0;
        var error = false;
        var currentState = this.currentState;
        var print = -1;
        var dcs = -1;
        var osc = this._osc;
        var collect = this._collect;
        var params = this._params;
        var table = this.TRANSITIONS.table;
        var dcsHandler = this._activeDcsHandler;
        var callback = null;
        for (var i = 0; i < length; ++i) {
            code = data[i];
            if (currentState === 0 && code > 0x1f && code < 0x80) {
                print = (~print) ? print : i;
                do
                    i++;
                while (i < length && data[i] > 0x1f && data[i] < 0x80);
                i--;
                continue;
            }
            if (currentState === 4 && (code > 0x2f && code < 0x39)) {
                params[params.length - 1] = params[params.length - 1] * 10 + code - 48;
                continue;
            }
            transition = table[currentState << 8 | (code < 0xa0 ? code : NON_ASCII_PRINTABLE)];
            switch (transition >> 4) {
                case 2:
                    print = (~print) ? print : i;
                    break;
                case 3:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    callback = this._executeHandlers[code];
                    if (callback)
                        callback();
                    else
                        this._executeHandlerFb(code);
                    break;
                case 0:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    else if (~dcs) {
                        dcsHandler.put(data, dcs, i);
                        dcs = -1;
                    }
                    break;
                case 1:
                    if (code > 0x9f) {
                        switch (currentState) {
                            case 0:
                                print = (~print) ? print : i;
                                break;
                            case 6:
                                transition |= 6;
                                break;
                            case 11:
                                transition |= 11;
                                break;
                            case 13:
                                dcs = (~dcs) ? dcs : i;
                                transition |= 13;
                                break;
                            default:
                                error = true;
                        }
                    }
                    else {
                        error = true;
                    }
                    if (error) {
                        var inject = this._errorHandler({
                            position: i,
                            code: code,
                            currentState: currentState,
                            print: print,
                            dcs: dcs,
                            osc: osc,
                            collect: collect,
                            params: params,
                            abort: false
                        });
                        if (inject.abort)
                            return;
                        error = false;
                    }
                    break;
                case 7:
                    var handlers = this._csiHandlers[code];
                    var j = handlers ? handlers.length - 1 : -1;
                    for (; j >= 0; j--) {
                        if (handlers[j](params, collect)) {
                            break;
                        }
                    }
                    if (j < 0) {
                        this._csiHandlerFb(collect, params, code);
                    }
                    break;
                case 8:
                    if (code === 0x3b)
                        params.push(0);
                    else
                        params[params.length - 1] = params[params.length - 1] * 10 + code - 48;
                    break;
                case 9:
                    collect += String.fromCharCode(code);
                    break;
                case 10:
                    callback = this._escHandlers[collect + String.fromCharCode(code)];
                    if (callback)
                        callback(collect, code);
                    else
                        this._escHandlerFb(collect, code);
                    break;
                case 11:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    osc = '';
                    params = [0];
                    collect = '';
                    dcs = -1;
                    break;
                case 12:
                    dcsHandler = this._dcsHandlers[collect + String.fromCharCode(code)];
                    if (!dcsHandler)
                        dcsHandler = this._dcsHandlerFb;
                    dcsHandler.hook(collect, params, code);
                    break;
                case 13:
                    dcs = (~dcs) ? dcs : i;
                    break;
                case 14:
                    if (dcsHandler) {
                        if (~dcs)
                            dcsHandler.put(data, dcs, i);
                        dcsHandler.unhook();
                        dcsHandler = null;
                    }
                    if (code === 0x1b)
                        transition |= 1;
                    osc = '';
                    params = [0];
                    collect = '';
                    dcs = -1;
                    break;
                case 4:
                    if (~print) {
                        this._printHandler(data, print, i);
                        print = -1;
                    }
                    osc = '';
                    break;
                case 5:
                    for (var j_1 = i + 1;; j_1++) {
                        if (j_1 >= length
                            || (code = data[j_1]) < 0x20
                            || (code > 0x7f && code <= 0x9f)) {
                            osc += TextDecoder_1.utf32ToString(data, i, j_1);
                            i = j_1 - 1;
                            break;
                        }
                    }
                    break;
                case 6:
                    if (osc && code !== 0x18 && code !== 0x1a) {
                        var idx = osc.indexOf(';');
                        if (idx === -1) {
                            this._oscHandlerFb(-1, osc);
                        }
                        else {
                            var identifier = parseInt(osc.substring(0, idx));
                            var content = osc.substring(idx + 1);
                            var handlers_1 = this._oscHandlers[identifier];
                            var j_2 = handlers_1 ? handlers_1.length - 1 : -1;
                            for (; j_2 >= 0; j_2--) {
                                if (handlers_1[j_2](content)) {
                                    break;
                                }
                            }
                            if (j_2 < 0) {
                                this._oscHandlerFb(identifier, content);
                            }
                        }
                    }
                    if (code === 0x1b)
                        transition |= 1;
                    osc = '';
                    params = [0];
                    collect = '';
                    dcs = -1;
                    break;
            }
            currentState = transition & 15;
        }
        if (currentState === 0 && ~print) {
            this._printHandler(data, print, length);
        }
        else if (currentState === 13 && ~dcs && dcsHandler) {
            dcsHandler.put(data, dcs, length);
        }
        this._osc = osc;
        this._collect = collect;
        this._params = params;
        this._activeDcsHandler = dcsHandler;
        this.currentState = currentState;
    };
    return EscapeSequenceParser;
}(Lifecycle_1.Disposable));
exports.EscapeSequenceParser = EscapeSequenceParser;

},{"./common/Lifecycle":20,"./core/input/TextDecoder":26}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EscapeSequences_1 = require("./common/data/EscapeSequences");
var Charsets_1 = require("./core/data/Charsets");
var Buffer_1 = require("./Buffer");
var CharWidth_1 = require("./CharWidth");
var EscapeSequenceParser_1 = require("./EscapeSequenceParser");
var Lifecycle_1 = require("./common/Lifecycle");
var TypedArrayUtils_1 = require("./common/TypedArrayUtils");
var TextDecoder_1 = require("./core/input/TextDecoder");
var GLEVEL = { '(': 0, ')': 1, '*': 2, '+': 3, '-': 1, '.': 2 };
var DECRQSS = (function () {
    function DECRQSS(_terminal) {
        this._terminal = _terminal;
        this._data = new Uint32Array(0);
    }
    DECRQSS.prototype.hook = function (collect, params, flag) {
        this._data = new Uint32Array(0);
    };
    DECRQSS.prototype.put = function (data, start, end) {
        this._data = TypedArrayUtils_1.concat(this._data, data.subarray(start, end));
    };
    DECRQSS.prototype.unhook = function () {
        var data = TextDecoder_1.utf32ToString(this._data);
        this._data = new Uint32Array(0);
        switch (data) {
            case '"q':
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r0\"q" + EscapeSequences_1.C0.ESC + "\\");
            case '"p':
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r61\"p" + EscapeSequences_1.C0.ESC + "\\");
            case 'r':
                var pt = '' + (this._terminal.buffer.scrollTop + 1) +
                    ';' + (this._terminal.buffer.scrollBottom + 1) + 'r';
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r" + pt + EscapeSequences_1.C0.ESC + "\\");
            case 'm':
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r0m" + EscapeSequences_1.C0.ESC + "\\");
            case ' q':
                var STYLES = { 'block': 2, 'underline': 4, 'bar': 6 };
                var style = STYLES[this._terminal.getOption('cursorStyle')];
                style -= this._terminal.getOption('cursorBlink');
                return this._terminal.handler(EscapeSequences_1.C0.ESC + "P1$r" + style + " q" + EscapeSequences_1.C0.ESC + "\\");
            default:
                this._terminal.error('Unknown DCS $q %s', data);
                this._terminal.handler(EscapeSequences_1.C0.ESC + "P0$r" + EscapeSequences_1.C0.ESC + "\\");
        }
    };
    return DECRQSS;
}());
var InputHandler = (function (_super) {
    __extends(InputHandler, _super);
    function InputHandler(_terminal, _parser) {
        if (_parser === void 0) { _parser = new EscapeSequenceParser_1.EscapeSequenceParser(); }
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._parser = _parser;
        _this._parseBuffer = new Uint32Array(4096);
        _this._stringDecoder = new TextDecoder_1.StringToUtf32();
        _this.register(_this._parser);
        _this._parser.setCsiHandlerFallback(function (collect, params, flag) {
            _this._terminal.error('Unknown CSI code: ', { collect: collect, params: params, flag: String.fromCharCode(flag) });
        });
        _this._parser.setEscHandlerFallback(function (collect, flag) {
            _this._terminal.error('Unknown ESC code: ', { collect: collect, flag: String.fromCharCode(flag) });
        });
        _this._parser.setExecuteHandlerFallback(function (code) {
            _this._terminal.error('Unknown EXECUTE code: ', { code: code });
        });
        _this._parser.setOscHandlerFallback(function (identifier, data) {
            _this._terminal.error('Unknown OSC code: ', { identifier: identifier, data: data });
        });
        _this._parser.setPrintHandler(function (data, start, end) { return _this.print(data, start, end); });
        _this._parser.setCsiHandler('@', function (params, collect) { return _this.insertChars(params); });
        _this._parser.setCsiHandler('A', function (params, collect) { return _this.cursorUp(params); });
        _this._parser.setCsiHandler('B', function (params, collect) { return _this.cursorDown(params); });
        _this._parser.setCsiHandler('C', function (params, collect) { return _this.cursorForward(params); });
        _this._parser.setCsiHandler('D', function (params, collect) { return _this.cursorBackward(params); });
        _this._parser.setCsiHandler('E', function (params, collect) { return _this.cursorNextLine(params); });
        _this._parser.setCsiHandler('F', function (params, collect) { return _this.cursorPrecedingLine(params); });
        _this._parser.setCsiHandler('G', function (params, collect) { return _this.cursorCharAbsolute(params); });
        _this._parser.setCsiHandler('H', function (params, collect) { return _this.cursorPosition(params); });
        _this._parser.setCsiHandler('I', function (params, collect) { return _this.cursorForwardTab(params); });
        _this._parser.setCsiHandler('J', function (params, collect) { return _this.eraseInDisplay(params); });
        _this._parser.setCsiHandler('K', function (params, collect) { return _this.eraseInLine(params); });
        _this._parser.setCsiHandler('L', function (params, collect) { return _this.insertLines(params); });
        _this._parser.setCsiHandler('M', function (params, collect) { return _this.deleteLines(params); });
        _this._parser.setCsiHandler('P', function (params, collect) { return _this.deleteChars(params); });
        _this._parser.setCsiHandler('S', function (params, collect) { return _this.scrollUp(params); });
        _this._parser.setCsiHandler('T', function (params, collect) { return _this.scrollDown(params, collect); });
        _this._parser.setCsiHandler('X', function (params, collect) { return _this.eraseChars(params); });
        _this._parser.setCsiHandler('Z', function (params, collect) { return _this.cursorBackwardTab(params); });
        _this._parser.setCsiHandler('`', function (params, collect) { return _this.charPosAbsolute(params); });
        _this._parser.setCsiHandler('a', function (params, collect) { return _this.hPositionRelative(params); });
        _this._parser.setCsiHandler('b', function (params, collect) { return _this.repeatPrecedingCharacter(params); });
        _this._parser.setCsiHandler('c', function (params, collect) { return _this.sendDeviceAttributes(params, collect); });
        _this._parser.setCsiHandler('d', function (params, collect) { return _this.linePosAbsolute(params); });
        _this._parser.setCsiHandler('e', function (params, collect) { return _this.vPositionRelative(params); });
        _this._parser.setCsiHandler('f', function (params, collect) { return _this.hVPosition(params); });
        _this._parser.setCsiHandler('g', function (params, collect) { return _this.tabClear(params); });
        _this._parser.setCsiHandler('h', function (params, collect) { return _this.setMode(params, collect); });
        _this._parser.setCsiHandler('l', function (params, collect) { return _this.resetMode(params, collect); });
        _this._parser.setCsiHandler('m', function (params, collect) { return _this.charAttributes(params); });
        _this._parser.setCsiHandler('n', function (params, collect) { return _this.deviceStatus(params, collect); });
        _this._parser.setCsiHandler('p', function (params, collect) { return _this.softReset(params, collect); });
        _this._parser.setCsiHandler('q', function (params, collect) { return _this.setCursorStyle(params, collect); });
        _this._parser.setCsiHandler('r', function (params, collect) { return _this.setScrollRegion(params, collect); });
        _this._parser.setCsiHandler('s', function (params, collect) { return _this.saveCursor(params); });
        _this._parser.setCsiHandler('u', function (params, collect) { return _this.restoreCursor(params); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.BEL, function () { return _this.bell(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.LF, function () { return _this.lineFeed(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.VT, function () { return _this.lineFeed(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.FF, function () { return _this.lineFeed(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.CR, function () { return _this.carriageReturn(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.BS, function () { return _this.backspace(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.HT, function () { return _this.tab(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.SO, function () { return _this.shiftOut(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C0.SI, function () { return _this.shiftIn(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C1.IND, function () { return _this.index(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C1.NEL, function () { return _this.nextLine(); });
        _this._parser.setExecuteHandler(EscapeSequences_1.C1.HTS, function () { return _this.tabSet(); });
        _this._parser.setOscHandler(0, function (data) { return _this.setTitle(data); });
        _this._parser.setOscHandler(2, function (data) { return _this.setTitle(data); });
        _this._parser.setEscHandler('7', function () { return _this.saveCursor([]); });
        _this._parser.setEscHandler('8', function () { return _this.restoreCursor([]); });
        _this._parser.setEscHandler('D', function () { return _this.index(); });
        _this._parser.setEscHandler('E', function () { return _this.nextLine(); });
        _this._parser.setEscHandler('H', function () { return _this.tabSet(); });
        _this._parser.setEscHandler('M', function () { return _this.reverseIndex(); });
        _this._parser.setEscHandler('=', function () { return _this.keypadApplicationMode(); });
        _this._parser.setEscHandler('>', function () { return _this.keypadNumericMode(); });
        _this._parser.setEscHandler('c', function () { return _this.reset(); });
        _this._parser.setEscHandler('n', function () { return _this.setgLevel(2); });
        _this._parser.setEscHandler('o', function () { return _this.setgLevel(3); });
        _this._parser.setEscHandler('|', function () { return _this.setgLevel(3); });
        _this._parser.setEscHandler('}', function () { return _this.setgLevel(2); });
        _this._parser.setEscHandler('~', function () { return _this.setgLevel(1); });
        _this._parser.setEscHandler('%@', function () { return _this.selectDefaultCharset(); });
        _this._parser.setEscHandler('%G', function () { return _this.selectDefaultCharset(); });
        var _loop_1 = function (flag) {
            this_1._parser.setEscHandler('(' + flag, function () { return _this.selectCharset('(' + flag); });
            this_1._parser.setEscHandler(')' + flag, function () { return _this.selectCharset(')' + flag); });
            this_1._parser.setEscHandler('*' + flag, function () { return _this.selectCharset('*' + flag); });
            this_1._parser.setEscHandler('+' + flag, function () { return _this.selectCharset('+' + flag); });
            this_1._parser.setEscHandler('-' + flag, function () { return _this.selectCharset('-' + flag); });
            this_1._parser.setEscHandler('.' + flag, function () { return _this.selectCharset('.' + flag); });
            this_1._parser.setEscHandler('/' + flag, function () { return _this.selectCharset('/' + flag); });
        };
        var this_1 = this;
        for (var flag in Charsets_1.CHARSETS) {
            _loop_1(flag);
        }
        _this._parser.setErrorHandler(function (state) {
            _this._terminal.error('Parsing error: ', state);
            return state;
        });
        _this._parser.setDcsHandler('$q', new DECRQSS(_this._terminal));
        return _this;
    }
    InputHandler.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._terminal = null;
    };
    InputHandler.prototype.parse = function (data) {
        if (!this._terminal) {
            return;
        }
        var buffer = this._terminal.buffer;
        var cursorStartX = buffer.x;
        var cursorStartY = buffer.y;
        if (this._terminal.debug) {
            this._terminal.log('data: ' + data);
        }
        if (this._parseBuffer.length < data.length) {
            this._parseBuffer = new Uint32Array(data.length);
        }
        for (var i = 0; i < data.length; ++i) {
            this._parseBuffer[i] = data.charCodeAt(i);
        }
        this._parser.parse(this._parseBuffer, this._stringDecoder.decode(data, this._parseBuffer));
        buffer = this._terminal.buffer;
        if (buffer.x !== cursorStartX || buffer.y !== cursorStartY) {
            this._terminal.emit('cursormove');
        }
    };
    InputHandler.prototype.print = function (data, start, end) {
        var code;
        var char;
        var chWidth;
        var buffer = this._terminal.buffer;
        var charset = this._terminal.charset;
        var screenReaderMode = this._terminal.options.screenReaderMode;
        var cols = this._terminal.cols;
        var wraparoundMode = this._terminal.wraparoundMode;
        var insertMode = this._terminal.insertMode;
        var curAttr = this._terminal.curAttr;
        var bufferRow = buffer.lines.get(buffer.y + buffer.ybase);
        this._terminal.updateRange(buffer.y);
        for (var pos = start; pos < end; ++pos) {
            code = data[pos];
            char = TextDecoder_1.stringFromCodePoint(code);
            chWidth = CharWidth_1.wcwidth(code);
            if (code < 127 && charset) {
                var ch = charset[char];
                if (ch) {
                    code = ch.charCodeAt(0);
                    char = ch;
                }
            }
            if (screenReaderMode) {
                this._terminal.emit('a11y.char', char);
            }
            if (!chWidth && buffer.x) {
                var chMinusOne = bufferRow.get(buffer.x - 1);
                if (chMinusOne) {
                    if (!chMinusOne[Buffer_1.CHAR_DATA_WIDTH_INDEX]) {
                        var chMinusTwo = bufferRow.get(buffer.x - 2);
                        if (chMinusTwo) {
                            chMinusTwo[Buffer_1.CHAR_DATA_CHAR_INDEX] += char;
                            chMinusTwo[Buffer_1.CHAR_DATA_CODE_INDEX] = code;
                            bufferRow.set(buffer.x - 2, chMinusTwo);
                        }
                    }
                    else {
                        chMinusOne[Buffer_1.CHAR_DATA_CHAR_INDEX] += char;
                        chMinusOne[Buffer_1.CHAR_DATA_CODE_INDEX] = code;
                        bufferRow.set(buffer.x - 1, chMinusOne);
                    }
                }
                continue;
            }
            if (buffer.x + chWidth - 1 >= cols) {
                if (wraparoundMode) {
                    buffer.x = 0;
                    buffer.y++;
                    if (buffer.y > buffer.scrollBottom) {
                        buffer.y--;
                        this._terminal.scroll(true);
                    }
                    else {
                        buffer.lines.get(buffer.y).isWrapped = true;
                    }
                    bufferRow = buffer.lines.get(buffer.y + buffer.ybase);
                }
                else {
                    if (chWidth === 2) {
                        continue;
                    }
                }
            }
            if (insertMode) {
                bufferRow.insertCells(buffer.x, chWidth, [curAttr, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
                var lastCell = bufferRow.get(cols - 1);
                if (lastCell[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                    bufferRow.set(cols - 1, [curAttr, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
                }
            }
            bufferRow.set(buffer.x++, [curAttr, char, chWidth, code]);
            if (chWidth > 0) {
                while (--chWidth) {
                    bufferRow.set(buffer.x++, [curAttr, '', 0, undefined]);
                }
            }
        }
        this._terminal.updateRange(buffer.y);
    };
    InputHandler.prototype.addCsiHandler = function (flag, callback) {
        return this._parser.addCsiHandler(flag, callback);
    };
    InputHandler.prototype.addOscHandler = function (ident, callback) {
        return this._parser.addOscHandler(ident, callback);
    };
    InputHandler.prototype.bell = function () {
        this._terminal.bell();
    };
    InputHandler.prototype.lineFeed = function () {
        var buffer = this._terminal.buffer;
        if (this._terminal.options.convertEol) {
            buffer.x = 0;
        }
        buffer.y++;
        if (buffer.y > buffer.scrollBottom) {
            buffer.y--;
            this._terminal.scroll();
        }
        if (buffer.x >= this._terminal.cols) {
            buffer.x--;
        }
        this._terminal.emit('linefeed');
    };
    InputHandler.prototype.carriageReturn = function () {
        this._terminal.buffer.x = 0;
    };
    InputHandler.prototype.backspace = function () {
        if (this._terminal.buffer.x > 0) {
            this._terminal.buffer.x--;
        }
    };
    InputHandler.prototype.tab = function () {
        var originalX = this._terminal.buffer.x;
        this._terminal.buffer.x = this._terminal.buffer.nextStop();
        if (this._terminal.options.screenReaderMode) {
            this._terminal.emit('a11y.tab', this._terminal.buffer.x - originalX);
        }
    };
    InputHandler.prototype.shiftOut = function () {
        this._terminal.setgLevel(1);
    };
    InputHandler.prototype.shiftIn = function () {
        this._terminal.setgLevel(0);
    };
    InputHandler.prototype.insertChars = function (params) {
        this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).insertCells(this._terminal.buffer.x, params[0] || 1, [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
        this._terminal.updateRange(this._terminal.buffer.y);
    };
    InputHandler.prototype.cursorUp = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y -= param;
        if (this._terminal.buffer.y < 0) {
            this._terminal.buffer.y = 0;
        }
    };
    InputHandler.prototype.cursorDown = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y += param;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x--;
        }
    };
    InputHandler.prototype.cursorForward = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x += param;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.cursorBackward = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x--;
        }
        this._terminal.buffer.x -= param;
        if (this._terminal.buffer.x < 0) {
            this._terminal.buffer.x = 0;
        }
    };
    InputHandler.prototype.cursorNextLine = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y += param;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        this._terminal.buffer.x = 0;
    };
    InputHandler.prototype.cursorPrecedingLine = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y -= param;
        if (this._terminal.buffer.y < 0) {
            this._terminal.buffer.y = 0;
        }
        this._terminal.buffer.x = 0;
    };
    InputHandler.prototype.cursorCharAbsolute = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x = param - 1;
    };
    InputHandler.prototype.cursorPosition = function (params) {
        var col;
        var row = params[0] - 1;
        if (params.length >= 2) {
            col = params[1] - 1;
        }
        else {
            col = 0;
        }
        if (row < 0) {
            row = 0;
        }
        else if (row >= this._terminal.rows) {
            row = this._terminal.rows - 1;
        }
        if (col < 0) {
            col = 0;
        }
        else if (col >= this._terminal.cols) {
            col = this._terminal.cols - 1;
        }
        this._terminal.buffer.x = col;
        this._terminal.buffer.y = row;
    };
    InputHandler.prototype.cursorForwardTab = function (params) {
        var param = params[0] || 1;
        while (param--) {
            this._terminal.buffer.x = this._terminal.buffer.nextStop();
        }
    };
    InputHandler.prototype._eraseInBufferLine = function (y, start, end, clearWrap) {
        if (clearWrap === void 0) { clearWrap = false; }
        var line = this._terminal.buffer.lines.get(this._terminal.buffer.ybase + y);
        line.replaceCells(start, end, [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
        if (clearWrap) {
            line.isWrapped = false;
        }
    };
    InputHandler.prototype._resetBufferLine = function (y) {
        this._eraseInBufferLine(y, 0, this._terminal.cols, true);
    };
    InputHandler.prototype.eraseInDisplay = function (params) {
        var j;
        switch (params[0]) {
            case 0:
                j = this._terminal.buffer.y;
                this._terminal.updateRange(j);
                this._eraseInBufferLine(j++, this._terminal.buffer.x, this._terminal.cols, this._terminal.buffer.x === 0);
                for (; j < this._terminal.rows; j++) {
                    this._resetBufferLine(j);
                }
                this._terminal.updateRange(j);
                break;
            case 1:
                j = this._terminal.buffer.y;
                this._terminal.updateRange(j);
                this._eraseInBufferLine(j, 0, this._terminal.buffer.x + 1, true);
                if (this._terminal.buffer.x + 1 >= this._terminal.cols) {
                    this._terminal.buffer.lines.get(j + 1).isWrapped = false;
                }
                while (j--) {
                    this._resetBufferLine(j);
                }
                this._terminal.updateRange(0);
                break;
            case 2:
                j = this._terminal.rows;
                this._terminal.updateRange(j - 1);
                while (j--) {
                    this._resetBufferLine(j);
                }
                this._terminal.updateRange(0);
                break;
            case 3:
                var scrollBackSize = this._terminal.buffer.lines.length - this._terminal.rows;
                if (scrollBackSize > 0) {
                    this._terminal.buffer.lines.trimStart(scrollBackSize);
                    this._terminal.buffer.ybase = Math.max(this._terminal.buffer.ybase - scrollBackSize, 0);
                    this._terminal.buffer.ydisp = Math.max(this._terminal.buffer.ydisp - scrollBackSize, 0);
                    this._terminal.emit('scroll', 0);
                }
                break;
        }
    };
    InputHandler.prototype.eraseInLine = function (params) {
        switch (params[0]) {
            case 0:
                this._eraseInBufferLine(this._terminal.buffer.y, this._terminal.buffer.x, this._terminal.cols);
                break;
            case 1:
                this._eraseInBufferLine(this._terminal.buffer.y, 0, this._terminal.buffer.x + 1);
                break;
            case 2:
                this._eraseInBufferLine(this._terminal.buffer.y, 0, this._terminal.cols);
                break;
        }
        this._terminal.updateRange(this._terminal.buffer.y);
    };
    InputHandler.prototype.insertLines = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        var buffer = this._terminal.buffer;
        var row = buffer.y + buffer.ybase;
        var scrollBottomRowsOffset = this._terminal.rows - 1 - buffer.scrollBottom;
        var scrollBottomAbsolute = this._terminal.rows - 1 + buffer.ybase - scrollBottomRowsOffset + 1;
        while (param--) {
            buffer.lines.splice(scrollBottomAbsolute - 1, 1);
            buffer.lines.splice(row, 0, buffer.getBlankLine(this._terminal.eraseAttr()));
        }
        this._terminal.updateRange(buffer.y);
        this._terminal.updateRange(buffer.scrollBottom);
    };
    InputHandler.prototype.deleteLines = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        var buffer = this._terminal.buffer;
        var row = buffer.y + buffer.ybase;
        var j;
        j = this._terminal.rows - 1 - buffer.scrollBottom;
        j = this._terminal.rows - 1 + buffer.ybase - j;
        while (param--) {
            buffer.lines.splice(row, 1);
            buffer.lines.splice(j, 0, buffer.getBlankLine(this._terminal.eraseAttr()));
        }
        this._terminal.updateRange(buffer.y);
        this._terminal.updateRange(buffer.scrollBottom);
    };
    InputHandler.prototype.deleteChars = function (params) {
        this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).deleteCells(this._terminal.buffer.x, params[0] || 1, [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
        this._terminal.updateRange(this._terminal.buffer.y);
    };
    InputHandler.prototype.scrollUp = function (params) {
        var param = params[0] || 1;
        var buffer = this._terminal.buffer;
        while (param--) {
            buffer.lines.splice(buffer.ybase + buffer.scrollTop, 1);
            buffer.lines.splice(buffer.ybase + buffer.scrollBottom, 0, buffer.getBlankLine(Buffer_1.DEFAULT_ATTR));
        }
        this._terminal.updateRange(buffer.scrollTop);
        this._terminal.updateRange(buffer.scrollBottom);
    };
    InputHandler.prototype.scrollDown = function (params, collect) {
        if (params.length < 2 && !collect) {
            var param = params[0] || 1;
            var buffer = this._terminal.buffer;
            while (param--) {
                buffer.lines.splice(buffer.ybase + buffer.scrollBottom, 1);
                buffer.lines.splice(buffer.ybase + buffer.scrollBottom, 0, buffer.getBlankLine(Buffer_1.DEFAULT_ATTR));
            }
            this._terminal.updateRange(buffer.scrollTop);
            this._terminal.updateRange(buffer.scrollBottom);
        }
    };
    InputHandler.prototype.eraseChars = function (params) {
        this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).replaceCells(this._terminal.buffer.x, this._terminal.buffer.x + (params[0] || 1), [this._terminal.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
    };
    InputHandler.prototype.cursorBackwardTab = function (params) {
        var param = params[0] || 1;
        var buffer = this._terminal.buffer;
        while (param--) {
            buffer.x = buffer.prevStop();
        }
    };
    InputHandler.prototype.charPosAbsolute = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x = param - 1;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.hPositionRelative = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.x += param;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.repeatPrecedingCharacter = function (params) {
        var buffer = this._terminal.buffer;
        var line = buffer.lines.get(buffer.ybase + buffer.y);
        line.replaceCells(buffer.x, buffer.x + (params[0] || 1), line.get(buffer.x - 1) || [Buffer_1.DEFAULT_ATTR, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE]);
    };
    InputHandler.prototype.sendDeviceAttributes = function (params, collect) {
        if (params[0] > 0) {
            return;
        }
        if (!collect) {
            if (this._terminal.is('xterm') || this._terminal.is('rxvt-unicode') || this._terminal.is('screen')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[?1;2c');
            }
            else if (this._terminal.is('linux')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[?6c');
            }
        }
        else if (collect === '>') {
            if (this._terminal.is('xterm')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[>0;276;0c');
            }
            else if (this._terminal.is('rxvt-unicode')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[>85;95;0c');
            }
            else if (this._terminal.is('linux')) {
                this._terminal.handler(params[0] + 'c');
            }
            else if (this._terminal.is('screen')) {
                this._terminal.handler(EscapeSequences_1.C0.ESC + '[>83;40003;0c');
            }
        }
    };
    InputHandler.prototype.linePosAbsolute = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y = param - 1;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
    };
    InputHandler.prototype.vPositionRelative = function (params) {
        var param = params[0];
        if (param < 1) {
            param = 1;
        }
        this._terminal.buffer.y += param;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x--;
        }
    };
    InputHandler.prototype.hVPosition = function (params) {
        if (params[0] < 1)
            params[0] = 1;
        if (params[1] < 1)
            params[1] = 1;
        this._terminal.buffer.y = params[0] - 1;
        if (this._terminal.buffer.y >= this._terminal.rows) {
            this._terminal.buffer.y = this._terminal.rows - 1;
        }
        this._terminal.buffer.x = params[1] - 1;
        if (this._terminal.buffer.x >= this._terminal.cols) {
            this._terminal.buffer.x = this._terminal.cols - 1;
        }
    };
    InputHandler.prototype.tabClear = function (params) {
        var param = params[0];
        if (param <= 0) {
            delete this._terminal.buffer.tabs[this._terminal.buffer.x];
        }
        else if (param === 3) {
            this._terminal.buffer.tabs = {};
        }
    };
    InputHandler.prototype.setMode = function (params, collect) {
        if (params.length > 1) {
            for (var i = 0; i < params.length; i++) {
                this.setMode([params[i]]);
            }
            return;
        }
        if (!collect) {
            switch (params[0]) {
                case 4:
                    this._terminal.insertMode = true;
                    break;
                case 20:
                    break;
            }
        }
        else if (collect === '?') {
            switch (params[0]) {
                case 1:
                    this._terminal.applicationCursor = true;
                    break;
                case 2:
                    this._terminal.setgCharset(0, Charsets_1.DEFAULT_CHARSET);
                    this._terminal.setgCharset(1, Charsets_1.DEFAULT_CHARSET);
                    this._terminal.setgCharset(2, Charsets_1.DEFAULT_CHARSET);
                    this._terminal.setgCharset(3, Charsets_1.DEFAULT_CHARSET);
                    break;
                case 3:
                    this._terminal.savedCols = this._terminal.cols;
                    this._terminal.resize(132, this._terminal.rows);
                    break;
                case 6:
                    this._terminal.originMode = true;
                    break;
                case 7:
                    this._terminal.wraparoundMode = true;
                    break;
                case 12:
                    break;
                case 66:
                    this._terminal.log('Serial port requested application keypad.');
                    this._terminal.applicationKeypad = true;
                    if (this._terminal.viewport) {
                        this._terminal.viewport.syncScrollArea();
                    }
                    break;
                case 9:
                case 1000:
                case 1002:
                case 1003:
                    this._terminal.x10Mouse = params[0] === 9;
                    this._terminal.vt200Mouse = params[0] === 1000;
                    this._terminal.normalMouse = params[0] > 1000;
                    this._terminal.mouseEvents = true;
                    if (this._terminal.element) {
                        this._terminal.element.classList.add('enable-mouse-events');
                    }
                    this._terminal.selectionManager.disable();
                    this._terminal.log('Binding to mouse events.');
                    break;
                case 1004:
                    this._terminal.sendFocus = true;
                    break;
                case 1005:
                    this._terminal.utfMouse = true;
                    break;
                case 1006:
                    this._terminal.sgrMouse = true;
                    break;
                case 1015:
                    this._terminal.urxvtMouse = true;
                    break;
                case 25:
                    this._terminal.cursorHidden = false;
                    break;
                case 1048:
                    this.saveCursor(params);
                    break;
                case 1049:
                    this.saveCursor(params);
                case 47:
                case 1047:
                    this._terminal.buffers.activateAltBuffer(this._terminal.eraseAttr());
                    this._terminal.refresh(0, this._terminal.rows - 1);
                    if (this._terminal.viewport) {
                        this._terminal.viewport.syncScrollArea();
                    }
                    this._terminal.showCursor();
                    break;
                case 2004:
                    this._terminal.bracketedPasteMode = true;
                    break;
            }
        }
    };
    InputHandler.prototype.resetMode = function (params, collect) {
        if (params.length > 1) {
            for (var i = 0; i < params.length; i++) {
                this.resetMode([params[i]]);
            }
            return;
        }
        if (!collect) {
            switch (params[0]) {
                case 4:
                    this._terminal.insertMode = false;
                    break;
                case 20:
                    break;
            }
        }
        else if (collect === '?') {
            switch (params[0]) {
                case 1:
                    this._terminal.applicationCursor = false;
                    break;
                case 3:
                    if (this._terminal.cols === 132 && this._terminal.savedCols) {
                        this._terminal.resize(this._terminal.savedCols, this._terminal.rows);
                    }
                    delete this._terminal.savedCols;
                    break;
                case 6:
                    this._terminal.originMode = false;
                    break;
                case 7:
                    this._terminal.wraparoundMode = false;
                    break;
                case 12:
                    break;
                case 66:
                    this._terminal.log('Switching back to normal keypad.');
                    this._terminal.applicationKeypad = false;
                    if (this._terminal.viewport) {
                        this._terminal.viewport.syncScrollArea();
                    }
                    break;
                case 9:
                case 1000:
                case 1002:
                case 1003:
                    this._terminal.x10Mouse = false;
                    this._terminal.vt200Mouse = false;
                    this._terminal.normalMouse = false;
                    this._terminal.mouseEvents = false;
                    if (this._terminal.element) {
                        this._terminal.element.classList.remove('enable-mouse-events');
                    }
                    this._terminal.selectionManager.enable();
                    break;
                case 1004:
                    this._terminal.sendFocus = false;
                    break;
                case 1005:
                    this._terminal.utfMouse = false;
                    break;
                case 1006:
                    this._terminal.sgrMouse = false;
                    break;
                case 1015:
                    this._terminal.urxvtMouse = false;
                    break;
                case 25:
                    this._terminal.cursorHidden = true;
                    break;
                case 1048:
                    this.restoreCursor(params);
                    break;
                case 1049:
                case 47:
                case 1047:
                    this._terminal.buffers.activateNormalBuffer();
                    if (params[0] === 1049) {
                        this.restoreCursor(params);
                    }
                    this._terminal.refresh(0, this._terminal.rows - 1);
                    if (this._terminal.viewport) {
                        this._terminal.viewport.syncScrollArea();
                    }
                    this._terminal.showCursor();
                    break;
                case 2004:
                    this._terminal.bracketedPasteMode = false;
                    break;
            }
        }
    };
    InputHandler.prototype.charAttributes = function (params) {
        if (params.length === 1 && params[0] === 0) {
            this._terminal.curAttr = Buffer_1.DEFAULT_ATTR;
            return;
        }
        var l = params.length;
        var flags = this._terminal.curAttr >> 18;
        var fg = (this._terminal.curAttr >> 9) & 0x1ff;
        var bg = this._terminal.curAttr & 0x1ff;
        var p;
        for (var i = 0; i < l; i++) {
            p = params[i];
            if (p >= 30 && p <= 37) {
                fg = p - 30;
            }
            else if (p >= 40 && p <= 47) {
                bg = p - 40;
            }
            else if (p >= 90 && p <= 97) {
                p += 8;
                fg = p - 90;
            }
            else if (p >= 100 && p <= 107) {
                p += 8;
                bg = p - 100;
            }
            else if (p === 0) {
                flags = Buffer_1.DEFAULT_ATTR >> 18;
                fg = (Buffer_1.DEFAULT_ATTR >> 9) & 0x1ff;
                bg = Buffer_1.DEFAULT_ATTR & 0x1ff;
            }
            else if (p === 1) {
                flags |= 1;
            }
            else if (p === 3) {
                flags |= 64;
            }
            else if (p === 4) {
                flags |= 2;
            }
            else if (p === 5) {
                flags |= 4;
            }
            else if (p === 7) {
                flags |= 8;
            }
            else if (p === 8) {
                flags |= 16;
            }
            else if (p === 2) {
                flags |= 32;
            }
            else if (p === 22) {
                flags &= ~1;
                flags &= ~32;
            }
            else if (p === 23) {
                flags &= ~64;
            }
            else if (p === 24) {
                flags &= ~2;
            }
            else if (p === 25) {
                flags &= ~4;
            }
            else if (p === 27) {
                flags &= ~8;
            }
            else if (p === 28) {
                flags &= ~16;
            }
            else if (p === 39) {
                fg = (Buffer_1.DEFAULT_ATTR >> 9) & 0x1ff;
            }
            else if (p === 49) {
                bg = Buffer_1.DEFAULT_ATTR & 0x1ff;
            }
            else if (p === 38) {
                if (params[i + 1] === 2) {
                    i += 2;
                    fg = this._terminal.matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
                    if (fg === -1)
                        fg = 0x1ff;
                    i += 2;
                }
                else if (params[i + 1] === 5) {
                    i += 2;
                    p = params[i] & 0xff;
                    fg = p;
                }
            }
            else if (p === 48) {
                if (params[i + 1] === 2) {
                    i += 2;
                    bg = this._terminal.matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
                    if (bg === -1)
                        bg = 0x1ff;
                    i += 2;
                }
                else if (params[i + 1] === 5) {
                    i += 2;
                    p = params[i] & 0xff;
                    bg = p;
                }
            }
            else if (p === 100) {
                fg = (Buffer_1.DEFAULT_ATTR >> 9) & 0x1ff;
                bg = Buffer_1.DEFAULT_ATTR & 0x1ff;
            }
            else {
                this._terminal.error('Unknown SGR attribute: %d.', p);
            }
        }
        this._terminal.curAttr = (flags << 18) | (fg << 9) | bg;
    };
    InputHandler.prototype.deviceStatus = function (params, collect) {
        if (!collect) {
            switch (params[0]) {
                case 5:
                    this._terminal.emit('data', EscapeSequences_1.C0.ESC + "[0n");
                    break;
                case 6:
                    var y = this._terminal.buffer.y + 1;
                    var x = this._terminal.buffer.x + 1;
                    this._terminal.emit('data', EscapeSequences_1.C0.ESC + "[" + y + ";" + x + "R");
                    break;
            }
        }
        else if (collect === '?') {
            switch (params[0]) {
                case 6:
                    var y = this._terminal.buffer.y + 1;
                    var x = this._terminal.buffer.x + 1;
                    this._terminal.emit('data', EscapeSequences_1.C0.ESC + "[?" + y + ";" + x + "R");
                    break;
                case 15:
                    break;
                case 25:
                    break;
                case 26:
                    break;
                case 53:
                    break;
            }
        }
    };
    InputHandler.prototype.softReset = function (params, collect) {
        if (collect === '!') {
            this._terminal.cursorHidden = false;
            this._terminal.insertMode = false;
            this._terminal.originMode = false;
            this._terminal.wraparoundMode = true;
            this._terminal.applicationKeypad = false;
            if (this._terminal.viewport) {
                this._terminal.viewport.syncScrollArea();
            }
            this._terminal.applicationCursor = false;
            this._terminal.buffer.scrollTop = 0;
            this._terminal.buffer.scrollBottom = this._terminal.rows - 1;
            this._terminal.curAttr = Buffer_1.DEFAULT_ATTR;
            this._terminal.buffer.x = this._terminal.buffer.y = 0;
            this._terminal.charset = null;
            this._terminal.glevel = 0;
            this._terminal.charsets = [null];
        }
    };
    InputHandler.prototype.setCursorStyle = function (params, collect) {
        if (collect === ' ') {
            var param = params[0] < 1 ? 1 : params[0];
            switch (param) {
                case 1:
                case 2:
                    this._terminal.setOption('cursorStyle', 'block');
                    break;
                case 3:
                case 4:
                    this._terminal.setOption('cursorStyle', 'underline');
                    break;
                case 5:
                case 6:
                    this._terminal.setOption('cursorStyle', 'bar');
                    break;
            }
            var isBlinking = param % 2 === 1;
            this._terminal.setOption('cursorBlink', isBlinking);
        }
    };
    InputHandler.prototype.setScrollRegion = function (params, collect) {
        if (collect)
            return;
        this._terminal.buffer.scrollTop = (params[0] || 1) - 1;
        this._terminal.buffer.scrollBottom = (params[1] && params[1] <= this._terminal.rows ? params[1] : this._terminal.rows) - 1;
        this._terminal.buffer.x = 0;
        this._terminal.buffer.y = 0;
    };
    InputHandler.prototype.saveCursor = function (params) {
        this._terminal.buffer.savedX = this._terminal.buffer.x;
        this._terminal.buffer.savedY = this._terminal.buffer.y;
        this._terminal.buffer.savedCurAttr = this._terminal.curAttr;
    };
    InputHandler.prototype.restoreCursor = function (params) {
        this._terminal.buffer.x = this._terminal.buffer.savedX || 0;
        this._terminal.buffer.y = this._terminal.buffer.savedY || 0;
        this._terminal.curAttr = this._terminal.buffer.savedCurAttr || Buffer_1.DEFAULT_ATTR;
    };
    InputHandler.prototype.setTitle = function (data) {
        this._terminal.handleTitle(data);
    };
    InputHandler.prototype.nextLine = function () {
        this._terminal.buffer.x = 0;
        this.index();
    };
    InputHandler.prototype.keypadApplicationMode = function () {
        this._terminal.log('Serial port requested application keypad.');
        this._terminal.applicationKeypad = true;
        if (this._terminal.viewport) {
            this._terminal.viewport.syncScrollArea();
        }
    };
    InputHandler.prototype.keypadNumericMode = function () {
        this._terminal.log('Switching back to normal keypad.');
        this._terminal.applicationKeypad = false;
        if (this._terminal.viewport) {
            this._terminal.viewport.syncScrollArea();
        }
    };
    InputHandler.prototype.selectDefaultCharset = function () {
        this._terminal.setgLevel(0);
        this._terminal.setgCharset(0, Charsets_1.DEFAULT_CHARSET);
    };
    InputHandler.prototype.selectCharset = function (collectAndFlag) {
        if (collectAndFlag.length !== 2)
            return this.selectDefaultCharset();
        if (collectAndFlag[0] === '/')
            return;
        this._terminal.setgCharset(GLEVEL[collectAndFlag[0]], Charsets_1.CHARSETS[collectAndFlag[1]] || Charsets_1.DEFAULT_CHARSET);
    };
    InputHandler.prototype.index = function () {
        this._terminal.index();
    };
    InputHandler.prototype.tabSet = function () {
        this._terminal.tabSet();
    };
    InputHandler.prototype.reverseIndex = function () {
        this._terminal.reverseIndex();
    };
    InputHandler.prototype.reset = function () {
        this._parser.reset();
        this._terminal.reset();
    };
    InputHandler.prototype.setgLevel = function (level) {
        this._terminal.setgLevel(level);
    };
    return InputHandler;
}(Lifecycle_1.Disposable));
exports.InputHandler = InputHandler;

},{"./Buffer":2,"./CharWidth":6,"./EscapeSequenceParser":8,"./common/Lifecycle":20,"./common/TypedArrayUtils":21,"./common/data/EscapeSequences":22,"./core/data/Charsets":24,"./core/input/TextDecoder":26}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MouseZoneManager_1 = require("./ui/MouseZoneManager");
var EventEmitter_1 = require("./common/EventEmitter");
var Buffer_1 = require("./Buffer");
var CharWidth_1 = require("./CharWidth");
var Linkifier = (function (_super) {
    __extends(Linkifier, _super);
    function Linkifier(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._linkMatchers = [];
        _this._nextLinkMatcherId = 0;
        _this._rowsToLinkify = {
            start: null,
            end: null
        };
        return _this;
    }
    Linkifier.prototype.attachToDom = function (mouseZoneManager) {
        this._mouseZoneManager = mouseZoneManager;
    };
    Linkifier.prototype.linkifyRows = function (start, end) {
        var _this = this;
        if (!this._mouseZoneManager) {
            return;
        }
        if (this._rowsToLinkify.start === null) {
            this._rowsToLinkify.start = start;
            this._rowsToLinkify.end = end;
        }
        else {
            this._rowsToLinkify.start = Math.min(this._rowsToLinkify.start, start);
            this._rowsToLinkify.end = Math.max(this._rowsToLinkify.end, end);
        }
        this._mouseZoneManager.clearAll(start, end);
        if (this._rowsTimeoutId) {
            clearTimeout(this._rowsTimeoutId);
        }
        this._rowsTimeoutId = setTimeout(function () { return _this._linkifyRows(); }, Linkifier.TIME_BEFORE_LINKIFY);
    };
    Linkifier.prototype._linkifyRows = function () {
        this._rowsTimeoutId = null;
        var buffer = this._terminal.buffer;
        var absoluteRowIndexStart = buffer.ydisp + this._rowsToLinkify.start;
        if (absoluteRowIndexStart >= buffer.lines.length) {
            return;
        }
        var absoluteRowIndexEnd = buffer.ydisp + Math.min(this._rowsToLinkify.end, this._terminal.rows) + 1;
        var overscanLineLimit = Math.ceil(Linkifier.OVERSCAN_CHAR_LIMIT / this._terminal.cols);
        var iterator = this._terminal.buffer.iterator(false, absoluteRowIndexStart, absoluteRowIndexEnd, overscanLineLimit, overscanLineLimit);
        while (iterator.hasNext()) {
            var lineData = iterator.next();
            for (var i = 0; i < this._linkMatchers.length; i++) {
                this._doLinkifyRow(lineData.range.first, lineData.content, this._linkMatchers[i]);
            }
        }
        this._rowsToLinkify.start = null;
        this._rowsToLinkify.end = null;
    };
    Linkifier.prototype.registerLinkMatcher = function (regex, handler, options) {
        if (options === void 0) { options = {}; }
        if (!handler) {
            throw new Error('handler must be defined');
        }
        var matcher = {
            id: this._nextLinkMatcherId++,
            regex: regex,
            handler: handler,
            matchIndex: options.matchIndex,
            validationCallback: options.validationCallback,
            hoverTooltipCallback: options.tooltipCallback,
            hoverLeaveCallback: options.leaveCallback,
            willLinkActivate: options.willLinkActivate,
            priority: options.priority || 0
        };
        this._addLinkMatcherToList(matcher);
        return matcher.id;
    };
    Linkifier.prototype._addLinkMatcherToList = function (matcher) {
        if (this._linkMatchers.length === 0) {
            this._linkMatchers.push(matcher);
            return;
        }
        for (var i = this._linkMatchers.length - 1; i >= 0; i--) {
            if (matcher.priority <= this._linkMatchers[i].priority) {
                this._linkMatchers.splice(i + 1, 0, matcher);
                return;
            }
        }
        this._linkMatchers.splice(0, 0, matcher);
    };
    Linkifier.prototype.deregisterLinkMatcher = function (matcherId) {
        for (var i = 0; i < this._linkMatchers.length; i++) {
            if (this._linkMatchers[i].id === matcherId) {
                this._linkMatchers.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    Linkifier.prototype._doLinkifyRow = function (rowIndex, text, matcher) {
        var _this = this;
        var rex = new RegExp(matcher.regex.source, matcher.regex.flags + 'g');
        var match;
        var stringIndex = -1;
        var _loop_1 = function () {
            var uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];
            if (!uri) {
                if (this_1._terminal.debug) {
                    console.log({ match: match, matcher: matcher });
                    throw new Error('match found without corresponding matchIndex');
                }
                return "break";
            }
            stringIndex = text.indexOf(uri, stringIndex + 1);
            rex.lastIndex = stringIndex + uri.length;
            if (stringIndex < 0) {
                return "break";
            }
            var bufferIndex = this_1._terminal.buffer.stringIndexToBufferIndex(rowIndex, stringIndex);
            if (bufferIndex[0] < 0) {
                return "break";
            }
            var line = this_1._terminal.buffer.lines.get(bufferIndex[0]);
            var char = line.get(bufferIndex[1]);
            var fg;
            if (char) {
                var attr = char[Buffer_1.CHAR_DATA_ATTR_INDEX];
                fg = (attr >> 9) & 0x1ff;
            }
            if (matcher.validationCallback) {
                matcher.validationCallback(uri, function (isValid) {
                    if (_this._rowsTimeoutId) {
                        return;
                    }
                    if (isValid) {
                        _this._addLink(bufferIndex[1], bufferIndex[0] - _this._terminal.buffer.ydisp, uri, matcher, fg);
                    }
                });
            }
            else {
                this_1._addLink(bufferIndex[1], bufferIndex[0] - this_1._terminal.buffer.ydisp, uri, matcher, fg);
            }
        };
        var this_1 = this;
        while ((match = rex.exec(text)) !== null) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    Linkifier.prototype._addLink = function (x, y, uri, matcher, fg) {
        var _this = this;
        var width = CharWidth_1.getStringCellWidth(uri);
        var x1 = x % this._terminal.cols;
        var y1 = y + Math.floor(x / this._terminal.cols);
        var x2 = (x1 + width) % this._terminal.cols;
        var y2 = y1 + Math.floor((x1 + width) / this._terminal.cols);
        if (x2 === 0) {
            x2 = this._terminal.cols;
            y2--;
        }
        this._mouseZoneManager.add(new MouseZoneManager_1.MouseZone(x1 + 1, y1 + 1, x2 + 1, y2 + 1, function (e) {
            if (matcher.handler) {
                return matcher.handler(e, uri);
            }
            window.open(uri, '_blank');
        }, function (e) {
            _this.emit("linkhover", _this._createLinkHoverEvent(x1, y1, x2, y2, fg));
            _this._terminal.element.classList.add('xterm-cursor-pointer');
        }, function (e) {
            _this.emit("linktooltip", _this._createLinkHoverEvent(x1, y1, x2, y2, fg));
            if (matcher.hoverTooltipCallback) {
                matcher.hoverTooltipCallback(e, uri);
            }
        }, function () {
            _this.emit("linkleave", _this._createLinkHoverEvent(x1, y1, x2, y2, fg));
            _this._terminal.element.classList.remove('xterm-cursor-pointer');
            if (matcher.hoverLeaveCallback) {
                matcher.hoverLeaveCallback();
            }
        }, function (e) {
            if (matcher.willLinkActivate) {
                return matcher.willLinkActivate(e, uri);
            }
            return true;
        }));
    };
    Linkifier.prototype._createLinkHoverEvent = function (x1, y1, x2, y2, fg) {
        return { x1: x1, y1: y1, x2: x2, y2: y2, cols: this._terminal.cols, fg: fg };
    };
    Linkifier.TIME_BEFORE_LINKIFY = 200;
    Linkifier.OVERSCAN_CHAR_LIMIT = 2000;
    return Linkifier;
}(EventEmitter_1.EventEmitter));
exports.Linkifier = Linkifier;

},{"./Buffer":2,"./CharWidth":6,"./common/EventEmitter":19,"./ui/MouseZoneManager":53}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MouseHelper_1 = require("./ui/MouseHelper");
var Browser = require("./core/Platform");
var EventEmitter_1 = require("./common/EventEmitter");
var SelectionModel_1 = require("./SelectionModel");
var Buffer_1 = require("./Buffer");
var AltClickHandler_1 = require("./handlers/AltClickHandler");
var DRAG_SCROLL_MAX_THRESHOLD = 50;
var DRAG_SCROLL_MAX_SPEED = 15;
var DRAG_SCROLL_INTERVAL = 50;
var ALT_CLICK_MOVE_CURSOR_TIME = 500;
var WORD_SEPARATORS = ' ()[]{}\'"';
var NON_BREAKING_SPACE_CHAR = String.fromCharCode(160);
var ALL_NON_BREAKING_SPACE_REGEX = new RegExp(NON_BREAKING_SPACE_CHAR, 'g');
var SelectionManager = (function (_super) {
    __extends(SelectionManager, _super);
    function SelectionManager(_terminal, _charMeasure) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._charMeasure = _charMeasure;
        _this._enabled = true;
        _this._initListeners();
        _this.enable();
        _this._model = new SelectionModel_1.SelectionModel(_terminal);
        _this._activeSelectionMode = 0;
        return _this;
    }
    SelectionManager.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._removeMouseDownListeners();
    };
    Object.defineProperty(SelectionManager.prototype, "_buffer", {
        get: function () {
            return this._terminal.buffers.active;
        },
        enumerable: true,
        configurable: true
    });
    SelectionManager.prototype._initListeners = function () {
        var _this = this;
        this._mouseMoveListener = function (event) { return _this._onMouseMove(event); };
        this._mouseUpListener = function (event) { return _this._onMouseUp(event); };
        this._trimListener = function (amount) { return _this._onTrim(amount); };
        this.initBuffersListeners();
    };
    SelectionManager.prototype.initBuffersListeners = function () {
        var _this = this;
        this._terminal.buffer.lines.on('trim', this._trimListener);
        this._terminal.buffers.on('activate', function (e) { return _this._onBufferActivate(e); });
    };
    SelectionManager.prototype.disable = function () {
        this.clearSelection();
        this._enabled = false;
    };
    SelectionManager.prototype.enable = function () {
        this._enabled = true;
    };
    Object.defineProperty(SelectionManager.prototype, "selectionStart", {
        get: function () { return this._model.finalSelectionStart; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionManager.prototype, "selectionEnd", {
        get: function () { return this._model.finalSelectionEnd; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionManager.prototype, "hasSelection", {
        get: function () {
            var start = this._model.finalSelectionStart;
            var end = this._model.finalSelectionEnd;
            if (!start || !end) {
                return false;
            }
            return start[0] !== end[0] || start[1] !== end[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionManager.prototype, "selectionText", {
        get: function () {
            var start = this._model.finalSelectionStart;
            var end = this._model.finalSelectionEnd;
            if (!start || !end) {
                return '';
            }
            var result = [];
            if (this._activeSelectionMode === 3) {
                if (start[0] === end[0]) {
                    return '';
                }
                for (var i = start[1]; i <= end[1]; i++) {
                    var lineText = this._buffer.translateBufferLineToString(i, true, start[0], end[0]);
                    result.push(lineText);
                }
            }
            else {
                var startRowEndCol = start[1] === end[1] ? end[0] : undefined;
                result.push(this._buffer.translateBufferLineToString(start[1], true, start[0], startRowEndCol));
                for (var i = start[1] + 1; i <= end[1] - 1; i++) {
                    var bufferLine = this._buffer.lines.get(i);
                    var lineText = this._buffer.translateBufferLineToString(i, true);
                    if (bufferLine.isWrapped) {
                        result[result.length - 1] += lineText;
                    }
                    else {
                        result.push(lineText);
                    }
                }
                if (start[1] !== end[1]) {
                    var bufferLine = this._buffer.lines.get(end[1]);
                    var lineText = this._buffer.translateBufferLineToString(end[1], true, 0, end[0]);
                    if (bufferLine.isWrapped) {
                        result[result.length - 1] += lineText;
                    }
                    else {
                        result.push(lineText);
                    }
                }
            }
            var formattedResult = result.map(function (line) {
                return line.replace(ALL_NON_BREAKING_SPACE_REGEX, ' ');
            }).join(Browser.isMSWindows ? '\r\n' : '\n');
            return formattedResult;
        },
        enumerable: true,
        configurable: true
    });
    SelectionManager.prototype.clearSelection = function () {
        this._model.clearSelection();
        this._removeMouseDownListeners();
        this.refresh();
    };
    SelectionManager.prototype.refresh = function (isNewSelection) {
        var _this = this;
        if (!this._refreshAnimationFrame) {
            this._refreshAnimationFrame = window.requestAnimationFrame(function () { return _this._refresh(); });
        }
        if (Browser.isLinux && isNewSelection) {
            var selectionText = this.selectionText;
            if (selectionText.length) {
                this.emit('newselection', this.selectionText);
            }
        }
    };
    SelectionManager.prototype._refresh = function () {
        this._refreshAnimationFrame = null;
        this.emit('refresh', {
            start: this._model.finalSelectionStart,
            end: this._model.finalSelectionEnd,
            columnSelectMode: this._activeSelectionMode === 3
        });
    };
    SelectionManager.prototype.isClickInSelection = function (event) {
        var coords = this._getMouseBufferCoords(event);
        var start = this._model.finalSelectionStart;
        var end = this._model.finalSelectionEnd;
        if (!start || !end) {
            return false;
        }
        return this._areCoordsInSelection(coords, start, end);
    };
    SelectionManager.prototype._areCoordsInSelection = function (coords, start, end) {
        return (coords[1] > start[1] && coords[1] < end[1]) ||
            (start[1] === end[1] && coords[1] === start[1] && coords[0] >= start[0] && coords[0] < end[0]) ||
            (start[1] < end[1] && coords[1] === end[1] && coords[0] < end[0]) ||
            (start[1] < end[1] && coords[1] === start[1] && coords[0] >= start[0]);
    };
    SelectionManager.prototype.selectWordAtCursor = function (event) {
        var coords = this._getMouseBufferCoords(event);
        if (coords) {
            this._selectWordAt(coords, false);
            this._model.selectionEnd = null;
            this.refresh(true);
        }
    };
    SelectionManager.prototype.selectAll = function () {
        this._model.isSelectAllActive = true;
        this.refresh();
        this._terminal.emit('selection');
    };
    SelectionManager.prototype.selectLines = function (start, end) {
        this._model.clearSelection();
        start = Math.max(start, 0);
        end = Math.min(end, this._terminal.buffer.lines.length - 1);
        this._model.selectionStart = [0, start];
        this._model.selectionEnd = [this._terminal.cols, end];
        this.refresh();
        this._terminal.emit('selection');
    };
    SelectionManager.prototype._onTrim = function (amount) {
        var needsRefresh = this._model.onTrim(amount);
        if (needsRefresh) {
            this.refresh();
        }
    };
    SelectionManager.prototype._getMouseBufferCoords = function (event) {
        var coords = this._terminal.mouseHelper.getCoords(event, this._terminal.screenElement, this._charMeasure, this._terminal.cols, this._terminal.rows, true);
        if (!coords) {
            return null;
        }
        coords[0]--;
        coords[1]--;
        coords[1] += this._terminal.buffer.ydisp;
        return coords;
    };
    SelectionManager.prototype._getMouseEventScrollAmount = function (event) {
        var offset = MouseHelper_1.MouseHelper.getCoordsRelativeToElement(event, this._terminal.screenElement)[1];
        var terminalHeight = this._terminal.rows * Math.ceil(this._charMeasure.height * this._terminal.options.lineHeight);
        if (offset >= 0 && offset <= terminalHeight) {
            return 0;
        }
        if (offset > terminalHeight) {
            offset -= terminalHeight;
        }
        offset = Math.min(Math.max(offset, -DRAG_SCROLL_MAX_THRESHOLD), DRAG_SCROLL_MAX_THRESHOLD);
        offset /= DRAG_SCROLL_MAX_THRESHOLD;
        return (offset / Math.abs(offset)) + Math.round(offset * (DRAG_SCROLL_MAX_SPEED - 1));
    };
    SelectionManager.prototype.shouldForceSelection = function (event) {
        if (Browser.isMac) {
            return event.altKey && this._terminal.options.macOptionClickForcesSelection;
        }
        return event.shiftKey;
    };
    SelectionManager.prototype.onMouseDown = function (event) {
        this._mouseDownTimeStamp = event.timeStamp;
        if (event.button === 2 && this.hasSelection) {
            return;
        }
        if (event.button !== 0) {
            return;
        }
        if (!this._enabled) {
            if (!this.shouldForceSelection(event)) {
                return;
            }
            event.stopPropagation();
        }
        event.preventDefault();
        this._dragScrollAmount = 0;
        if (this._enabled && event.shiftKey) {
            this._onIncrementalClick(event);
        }
        else {
            if (event.detail === 1) {
                this._onSingleClick(event);
            }
            else if (event.detail === 2) {
                this._onDoubleClick(event);
            }
            else if (event.detail === 3) {
                this._onTripleClick(event);
            }
        }
        this._addMouseDownListeners();
        this.refresh(true);
    };
    SelectionManager.prototype._addMouseDownListeners = function () {
        var _this = this;
        this._terminal.element.ownerDocument.addEventListener('mousemove', this._mouseMoveListener);
        this._terminal.element.ownerDocument.addEventListener('mouseup', this._mouseUpListener);
        this._dragScrollIntervalTimer = setInterval(function () { return _this._dragScroll(); }, DRAG_SCROLL_INTERVAL);
    };
    SelectionManager.prototype._removeMouseDownListeners = function () {
        if (this._terminal.element.ownerDocument) {
            this._terminal.element.ownerDocument.removeEventListener('mousemove', this._mouseMoveListener);
            this._terminal.element.ownerDocument.removeEventListener('mouseup', this._mouseUpListener);
        }
        clearInterval(this._dragScrollIntervalTimer);
        this._dragScrollIntervalTimer = null;
    };
    SelectionManager.prototype._onIncrementalClick = function (event) {
        if (this._model.selectionStart) {
            this._model.selectionEnd = this._getMouseBufferCoords(event);
        }
    };
    SelectionManager.prototype._onSingleClick = function (event) {
        this._model.selectionStartLength = 0;
        this._model.isSelectAllActive = false;
        this._activeSelectionMode = this.shouldColumnSelect(event) ? 3 : 0;
        this._model.selectionStart = this._getMouseBufferCoords(event);
        if (!this._model.selectionStart) {
            return;
        }
        this._model.selectionEnd = null;
        var line = this._buffer.lines.get(this._model.selectionStart[1]);
        if (!line) {
            return;
        }
        if (line.length >= this._model.selectionStart[0]) {
            return;
        }
        var char = line.get(this._model.selectionStart[0]);
        if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
            this._model.selectionStart[0]++;
        }
    };
    SelectionManager.prototype._onDoubleClick = function (event) {
        var coords = this._getMouseBufferCoords(event);
        if (coords) {
            this._activeSelectionMode = 1;
            this._selectWordAt(coords, true);
        }
    };
    SelectionManager.prototype._onTripleClick = function (event) {
        var coords = this._getMouseBufferCoords(event);
        if (coords) {
            this._activeSelectionMode = 2;
            this._selectLineAt(coords[1]);
        }
    };
    SelectionManager.prototype.shouldColumnSelect = function (event) {
        return event.altKey && !(Browser.isMac && this._terminal.options.macOptionClickForcesSelection);
    };
    SelectionManager.prototype._onMouseMove = function (event) {
        event.stopImmediatePropagation();
        var previousSelectionEnd = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
        this._model.selectionEnd = this._getMouseBufferCoords(event);
        if (!this._model.selectionEnd) {
            this.refresh(true);
            return;
        }
        if (this._activeSelectionMode === 2) {
            if (this._model.selectionEnd[1] < this._model.selectionStart[1]) {
                this._model.selectionEnd[0] = 0;
            }
            else {
                this._model.selectionEnd[0] = this._terminal.cols;
            }
        }
        else if (this._activeSelectionMode === 1) {
            this._selectToWordAt(this._model.selectionEnd);
        }
        this._dragScrollAmount = this._getMouseEventScrollAmount(event);
        if (this._activeSelectionMode !== 3) {
            if (this._dragScrollAmount > 0) {
                this._model.selectionEnd[0] = this._terminal.cols;
            }
            else if (this._dragScrollAmount < 0) {
                this._model.selectionEnd[0] = 0;
            }
        }
        if (this._model.selectionEnd[1] < this._buffer.lines.length) {
            var char = this._buffer.lines.get(this._model.selectionEnd[1]).get(this._model.selectionEnd[0]);
            if (char && char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                this._model.selectionEnd[0]++;
            }
        }
        if (!previousSelectionEnd ||
            previousSelectionEnd[0] !== this._model.selectionEnd[0] ||
            previousSelectionEnd[1] !== this._model.selectionEnd[1]) {
            this.refresh(true);
        }
    };
    SelectionManager.prototype._dragScroll = function () {
        if (this._dragScrollAmount) {
            this._terminal.scrollLines(this._dragScrollAmount, false);
            if (this._dragScrollAmount > 0) {
                if (this._activeSelectionMode !== 3) {
                    this._model.selectionEnd[0] = this._terminal.cols;
                }
                this._model.selectionEnd[1] = Math.min(this._terminal.buffer.ydisp + this._terminal.rows, this._terminal.buffer.lines.length - 1);
            }
            else {
                if (this._activeSelectionMode !== 3) {
                    this._model.selectionEnd[0] = 0;
                }
                this._model.selectionEnd[1] = this._terminal.buffer.ydisp;
            }
            this.refresh();
        }
    };
    SelectionManager.prototype._onMouseUp = function (event) {
        var timeElapsed = event.timeStamp - this._mouseDownTimeStamp;
        this._removeMouseDownListeners();
        if (this.selectionText.length <= 1 && timeElapsed < ALT_CLICK_MOVE_CURSOR_TIME) {
            (new AltClickHandler_1.AltClickHandler(event, this._terminal)).move();
        }
        else if (this.hasSelection) {
            this._terminal.emit('selection');
        }
    };
    SelectionManager.prototype._onBufferActivate = function (e) {
        this.clearSelection();
        e.inactiveBuffer.lines.off('trim', this._trimListener);
        e.activeBuffer.lines.on('trim', this._trimListener);
    };
    SelectionManager.prototype._convertViewportColToCharacterIndex = function (bufferLine, coords) {
        var charIndex = coords[0];
        for (var i = 0; coords[0] >= i; i++) {
            var char = bufferLine.get(i);
            if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                charIndex--;
            }
            else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1 && coords[0] !== i) {
                charIndex += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
            }
        }
        return charIndex;
    };
    SelectionManager.prototype.setSelection = function (col, row, length) {
        this._model.clearSelection();
        this._removeMouseDownListeners();
        this._model.selectionStart = [col, row];
        this._model.selectionStartLength = length;
        this.refresh();
    };
    SelectionManager.prototype._getWordAt = function (coords, allowWhitespaceOnlySelection, followWrappedLinesAbove, followWrappedLinesBelow) {
        if (followWrappedLinesAbove === void 0) { followWrappedLinesAbove = true; }
        if (followWrappedLinesBelow === void 0) { followWrappedLinesBelow = true; }
        if (coords[0] >= this._terminal.cols) {
            return null;
        }
        var bufferLine = this._buffer.lines.get(coords[1]);
        if (!bufferLine) {
            return null;
        }
        var line = this._buffer.translateBufferLineToString(coords[1], false);
        var startIndex = this._convertViewportColToCharacterIndex(bufferLine, coords);
        var endIndex = startIndex;
        var charOffset = coords[0] - startIndex;
        var leftWideCharCount = 0;
        var rightWideCharCount = 0;
        var leftLongCharOffset = 0;
        var rightLongCharOffset = 0;
        if (line.charAt(startIndex) === ' ') {
            while (startIndex > 0 && line.charAt(startIndex - 1) === ' ') {
                startIndex--;
            }
            while (endIndex < line.length && line.charAt(endIndex + 1) === ' ') {
                endIndex++;
            }
        }
        else {
            var startCol = coords[0];
            var endCol = coords[0];
            if (bufferLine.get(startCol)[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                leftWideCharCount++;
                startCol--;
            }
            if (bufferLine.get(endCol)[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                rightWideCharCount++;
                endCol++;
            }
            if (bufferLine.get(endCol)[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                rightLongCharOffset += bufferLine.get(endCol)[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                endIndex += bufferLine.get(endCol)[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
            }
            while (startCol > 0 && startIndex > 0 && !this._isCharWordSeparator(bufferLine.get(startCol - 1))) {
                var char = bufferLine.get(startCol - 1);
                if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                    leftWideCharCount++;
                    startCol--;
                }
                else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                    leftLongCharOffset += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                    startIndex -= char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                }
                startIndex--;
                startCol--;
            }
            while (endCol < bufferLine.length && endIndex + 1 < line.length && !this._isCharWordSeparator(bufferLine.get(endCol + 1))) {
                var char = bufferLine.get(endCol + 1);
                if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                    rightWideCharCount++;
                    endCol++;
                }
                else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                    rightLongCharOffset += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                    endIndex += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                }
                endIndex++;
                endCol++;
            }
        }
        endIndex++;
        var start = startIndex
            + charOffset
            - leftWideCharCount
            + leftLongCharOffset;
        var length = Math.min(this._terminal.cols, endIndex
            - startIndex
            + leftWideCharCount
            + rightWideCharCount
            - leftLongCharOffset
            - rightLongCharOffset);
        if (!allowWhitespaceOnlySelection && line.slice(startIndex, endIndex).trim() === '') {
            return null;
        }
        if (followWrappedLinesAbove) {
            if (start === 0 && bufferLine.get(0)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                var previousBufferLine = this._buffer.lines.get(coords[1] - 1);
                if (previousBufferLine && bufferLine.isWrapped && previousBufferLine.get(this._terminal.cols - 1)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                    var previousLineWordPosition = this._getWordAt([this._terminal.cols - 1, coords[1] - 1], false, true, false);
                    if (previousLineWordPosition) {
                        var offset = this._terminal.cols - previousLineWordPosition.start;
                        start -= offset;
                        length += offset;
                    }
                }
            }
        }
        if (followWrappedLinesBelow) {
            if (start + length === this._terminal.cols && bufferLine.get(this._terminal.cols - 1)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                var nextBufferLine = this._buffer.lines.get(coords[1] + 1);
                if (nextBufferLine && nextBufferLine.isWrapped && nextBufferLine.get(0)[Buffer_1.CHAR_DATA_CODE_INDEX] !== 32) {
                    var nextLineWordPosition = this._getWordAt([0, coords[1] + 1], false, false, true);
                    if (nextLineWordPosition) {
                        length += nextLineWordPosition.length;
                    }
                }
            }
        }
        return { start: start, length: length };
    };
    SelectionManager.prototype._selectWordAt = function (coords, allowWhitespaceOnlySelection) {
        var wordPosition = this._getWordAt(coords, allowWhitespaceOnlySelection);
        if (wordPosition) {
            while (wordPosition.start < 0) {
                wordPosition.start += this._terminal.cols;
                coords[1]--;
            }
            this._model.selectionStart = [wordPosition.start, coords[1]];
            this._model.selectionStartLength = wordPosition.length;
        }
    };
    SelectionManager.prototype._selectToWordAt = function (coords) {
        var wordPosition = this._getWordAt(coords, true);
        if (wordPosition) {
            var endRow = coords[1];
            while (wordPosition.start < 0) {
                wordPosition.start += this._terminal.cols;
                endRow--;
            }
            if (!this._model.areSelectionValuesReversed()) {
                while (wordPosition.start + wordPosition.length > this._terminal.cols) {
                    wordPosition.length -= this._terminal.cols;
                    endRow++;
                }
            }
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? wordPosition.start : wordPosition.start + wordPosition.length, endRow];
        }
    };
    SelectionManager.prototype._isCharWordSeparator = function (charData) {
        if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
            return false;
        }
        return WORD_SEPARATORS.indexOf(charData[Buffer_1.CHAR_DATA_CHAR_INDEX]) >= 0;
    };
    SelectionManager.prototype._selectLineAt = function (line) {
        var wrappedRange = this._buffer.getWrappedRangeForLine(line);
        this._model.selectionStart = [0, wrappedRange.first];
        this._model.selectionEnd = [this._terminal.cols, wrappedRange.last];
        this._model.selectionStartLength = 0;
    };
    return SelectionManager;
}(EventEmitter_1.EventEmitter));
exports.SelectionManager = SelectionManager;

},{"./Buffer":2,"./SelectionModel":12,"./common/EventEmitter":19,"./core/Platform":23,"./handlers/AltClickHandler":27,"./ui/MouseHelper":52}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SelectionModel = (function () {
    function SelectionModel(_terminal) {
        this._terminal = _terminal;
        this.clearSelection();
    }
    SelectionModel.prototype.clearSelection = function () {
        this.selectionStart = null;
        this.selectionEnd = null;
        this.isSelectAllActive = false;
        this.selectionStartLength = 0;
    };
    Object.defineProperty(SelectionModel.prototype, "finalSelectionStart", {
        get: function () {
            if (this.isSelectAllActive) {
                return [0, 0];
            }
            if (!this.selectionEnd || !this.selectionStart) {
                return this.selectionStart;
            }
            return this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionModel.prototype, "finalSelectionEnd", {
        get: function () {
            if (this.isSelectAllActive) {
                return [this._terminal.cols, this._terminal.buffer.ybase + this._terminal.rows - 1];
            }
            if (!this.selectionStart) {
                return null;
            }
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                var startPlusLength = this.selectionStart[0] + this.selectionStartLength;
                if (startPlusLength > this._terminal.cols) {
                    return [startPlusLength % this._terminal.cols, this.selectionStart[1] + Math.floor(startPlusLength / this._terminal.cols)];
                }
                return [startPlusLength, this.selectionStart[1]];
            }
            if (this.selectionStartLength) {
                if (this.selectionEnd[1] === this.selectionStart[1]) {
                    return [Math.max(this.selectionStart[0] + this.selectionStartLength, this.selectionEnd[0]), this.selectionEnd[1]];
                }
            }
            return this.selectionEnd;
        },
        enumerable: true,
        configurable: true
    });
    SelectionModel.prototype.areSelectionValuesReversed = function () {
        var start = this.selectionStart;
        var end = this.selectionEnd;
        if (!start || !end) {
            return false;
        }
        return start[1] > end[1] || (start[1] === end[1] && start[0] > end[0]);
    };
    SelectionModel.prototype.onTrim = function (amount) {
        if (this.selectionStart) {
            this.selectionStart[1] -= amount;
        }
        if (this.selectionEnd) {
            this.selectionEnd[1] -= amount;
        }
        if (this.selectionEnd && this.selectionEnd[1] < 0) {
            this.clearSelection();
            return true;
        }
        if (this.selectionStart && this.selectionStart[1] < 0) {
            this.selectionStart[1] = 0;
        }
        return false;
    };
    return SelectionModel;
}());
exports.SelectionModel = SelectionModel;

},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_BELL_SOUND = 'data:audio/wav;base64,UklGRigBAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQBAADpAFgCwAMlBZoG/wdmCcoKRAypDQ8PbRDBEQQTOxRtFYcWlBePGIUZXhoiG88bcBz7HHIdzh0WHlMeZx51HmkeUx4WHs8dah0AHXwc3hs9G4saxRnyGBIYGBcQFv8U4RPAEoYRQBACD70NWwwHC6gJOwjWBloF7gOBAhABkf8b/qv8R/ve+Xf4Ife79W/0JfPZ8Z/wde9N7ijtE+wU6xvqM+lb6H7nw+YX5mrlxuQz5Mzje+Ma49fioeKD4nXiYeJy4pHitOL04j/jn+MN5IPkFOWs5U3mDefM55/ogOl36m7rdOyE7abuyu8D8Unyj/Pg9D/2qfcb+Yn6/vuK/Qj/lAAlAg==';
var SoundManager = (function () {
    function SoundManager(_terminal) {
        this._terminal = _terminal;
    }
    Object.defineProperty(SoundManager, "audioContext", {
        get: function () {
            if (!SoundManager._audioContext) {
                var audioContextCtor = window.AudioContext || window.webkitAudioContext;
                if (!audioContextCtor) {
                    console.warn('Web Audio API is not supported by this browser. Consider upgrading to the latest version');
                    return null;
                }
                SoundManager._audioContext = new audioContextCtor();
            }
            return SoundManager._audioContext;
        },
        enumerable: true,
        configurable: true
    });
    SoundManager.prototype.playBellSound = function () {
        var ctx = SoundManager.audioContext;
        if (!ctx) {
            return;
        }
        var bellAudioSource = ctx.createBufferSource();
        ctx.decodeAudioData(this._base64ToArrayBuffer(this._removeMimeType(this._terminal.options.bellSound)), function (buffer) {
            bellAudioSource.buffer = buffer;
            bellAudioSource.connect(ctx.destination);
            bellAudioSource.start(0);
        });
    };
    SoundManager.prototype._base64ToArrayBuffer = function (base64) {
        var binaryString = window.atob(base64);
        var len = binaryString.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    };
    SoundManager.prototype._removeMimeType = function (dataURI) {
        var splitUri = dataURI.split(',');
        return splitUri[1];
    };
    return SoundManager;
}());
exports.SoundManager = SoundManager;

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blankLine = 'Blank line';
exports.promptLabel = 'Terminal input';
exports.tooMuchOutput = 'Too much output to announce, navigate to rows manually to read';

},{}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BufferSet_1 = require("./BufferSet");
var Buffer_1 = require("./Buffer");
var CompositionHelper_1 = require("./CompositionHelper");
var EventEmitter_1 = require("./common/EventEmitter");
var Viewport_1 = require("./Viewport");
var Clipboard_1 = require("./ui/Clipboard");
var EscapeSequences_1 = require("./common/data/EscapeSequences");
var InputHandler_1 = require("./InputHandler");
var Renderer_1 = require("./renderer/Renderer");
var Linkifier_1 = require("./Linkifier");
var SelectionManager_1 = require("./SelectionManager");
var CharMeasure_1 = require("./ui/CharMeasure");
var Browser = require("./core/Platform");
var Lifecycle_1 = require("./ui/Lifecycle");
var Strings = require("./Strings");
var MouseHelper_1 = require("./ui/MouseHelper");
var SoundManager_1 = require("./SoundManager");
var ColorManager_1 = require("./renderer/ColorManager");
var MouseZoneManager_1 = require("./ui/MouseZoneManager");
var AccessibilityManager_1 = require("./AccessibilityManager");
var ScreenDprMonitor_1 = require("./ui/ScreenDprMonitor");
var CharAtlasCache_1 = require("./renderer/atlas/CharAtlasCache");
var DomRenderer_1 = require("./renderer/dom/DomRenderer");
var Keyboard_1 = require("./core/input/Keyboard");
var Clone_1 = require("./common/Clone");
var document = (typeof window !== 'undefined') ? window.document : null;
var WRITE_BUFFER_PAUSE_THRESHOLD = 5;
var WRITE_BATCH_SIZE = 300;
var MINIMUM_COLS = 2;
var MINIMUM_ROWS = 1;
var CONSTRUCTOR_ONLY_OPTIONS = ['cols', 'rows'];
var DEFAULT_OPTIONS = {
    cols: 80,
    rows: 24,
    convertEol: false,
    termName: 'xterm',
    cursorBlink: false,
    cursorStyle: 'block',
    bellSound: SoundManager_1.DEFAULT_BELL_SOUND,
    bellStyle: 'none',
    drawBoldTextInBrightColors: true,
    enableBold: true,
    experimentalCharAtlas: 'static',
    fontFamily: 'courier-new, courier, monospace',
    fontSize: 15,
    fontWeight: 'normal',
    fontWeightBold: 'bold',
    lineHeight: 1.0,
    letterSpacing: 0,
    scrollback: 1000,
    screenKeys: false,
    screenReaderMode: false,
    debug: false,
    macOptionIsMeta: false,
    macOptionClickForcesSelection: false,
    cancelEvents: false,
    disableStdin: false,
    useFlowControl: false,
    allowTransparency: false,
    tabStopWidth: 8,
    theme: null,
    rightClickSelectsWord: Browser.isMac,
    rendererType: 'canvas'
};
var Terminal = (function (_super) {
    __extends(Terminal, _super);
    function Terminal(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.browser = Browser;
        _this._blankLine = null;
        _this.options = Clone_1.clone(options);
        _this._setup();
        return _this;
    }
    Terminal.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._customKeyEventHandler = null;
        CharAtlasCache_1.removeTerminalFromCache(this);
        this.handler = function () { };
        this.write = function () { };
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
    };
    Terminal.prototype.destroy = function () {
        this.dispose();
    };
    Terminal.prototype._setup = function () {
        var _this = this;
        Object.keys(DEFAULT_OPTIONS).forEach(function (key) {
            if (_this.options[key] === null || _this.options[key] === undefined) {
                _this.options[key] = DEFAULT_OPTIONS[key];
            }
        });
        this._parent = document ? document.body : null;
        this.cols = Math.max(this.options.cols, MINIMUM_COLS);
        this.rows = Math.max(this.options.rows, MINIMUM_ROWS);
        if (this.options.handler) {
            this.on('data', this.options.handler);
        }
        this.cursorState = 0;
        this.cursorHidden = false;
        this._customKeyEventHandler = null;
        this.applicationKeypad = false;
        this.applicationCursor = false;
        this.originMode = false;
        this.insertMode = false;
        this.wraparoundMode = true;
        this.bracketedPasteMode = false;
        this.charset = null;
        this.gcharset = null;
        this.glevel = 0;
        this.charsets = [null];
        this.curAttr = Buffer_1.DEFAULT_ATTR;
        this.params = [];
        this.currentParam = 0;
        this.writeBuffer = [];
        this._writeInProgress = false;
        this._xoffSentToCatchUp = false;
        this._userScrolling = false;
        this._inputHandler = new InputHandler_1.InputHandler(this);
        this.register(this._inputHandler);
        this.renderer = this.renderer || null;
        this.selectionManager = this.selectionManager || null;
        this.linkifier = this.linkifier || new Linkifier_1.Linkifier(this);
        this._mouseZoneManager = this._mouseZoneManager || null;
        this.soundManager = this.soundManager || new SoundManager_1.SoundManager(this);
        this.buffers = new BufferSet_1.BufferSet(this);
        if (this.selectionManager) {
            this.selectionManager.clearSelection();
            this.selectionManager.initBuffersListeners();
        }
    };
    Object.defineProperty(Terminal.prototype, "buffer", {
        get: function () {
            return this.buffers.active;
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.eraseAttr = function () {
        return (Buffer_1.DEFAULT_ATTR & ~0x1ff) | (this.curAttr & 0x1ff);
    };
    Terminal.prototype.focus = function () {
        if (this.textarea) {
            this.textarea.focus();
        }
    };
    Object.defineProperty(Terminal.prototype, "isFocused", {
        get: function () {
            return document.activeElement === this.textarea && document.hasFocus();
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.getOption = function (key) {
        if (!(key in DEFAULT_OPTIONS)) {
            throw new Error('No option with key "' + key + '"');
        }
        return this.options[key];
    };
    Terminal.prototype.setOption = function (key, value) {
        if (!(key in DEFAULT_OPTIONS)) {
            throw new Error('No option with key "' + key + '"');
        }
        if (CONSTRUCTOR_ONLY_OPTIONS.indexOf(key) !== -1) {
            console.error("Option \"" + key + "\" can only be set in the constructor");
        }
        if (this.options[key] === value) {
            return;
        }
        switch (key) {
            case 'bellStyle':
                if (!value) {
                    value = 'none';
                }
                break;
            case 'cursorStyle':
                if (!value) {
                    value = 'block';
                }
                break;
            case 'fontWeight':
                if (!value) {
                    value = 'normal';
                }
                break;
            case 'fontWeightBold':
                if (!value) {
                    value = 'bold';
                }
                break;
            case 'lineHeight':
                if (value < 1) {
                    console.warn(key + " cannot be less than 1, value: " + value);
                    return;
                }
            case 'rendererType':
                if (!value) {
                    value = 'canvas';
                }
                break;
            case 'tabStopWidth':
                if (value < 1) {
                    console.warn(key + " cannot be less than 1, value: " + value);
                    return;
                }
                break;
            case 'theme':
                if (this.renderer) {
                    this._setTheme(value);
                    return;
                }
                break;
            case 'scrollback':
                value = Math.min(value, Buffer_1.MAX_BUFFER_SIZE);
                if (value < 0) {
                    console.warn(key + " cannot be less than 0, value: " + value);
                    return;
                }
                if (this.options[key] !== value) {
                    var newBufferLength = this.rows + value;
                    if (this.buffer.lines.length > newBufferLength) {
                        var amountToTrim = this.buffer.lines.length - newBufferLength;
                        var needsRefresh = (this.buffer.ydisp - amountToTrim < 0);
                        this.buffer.lines.trimStart(amountToTrim);
                        this.buffer.ybase = Math.max(this.buffer.ybase - amountToTrim, 0);
                        this.buffer.ydisp = Math.max(this.buffer.ydisp - amountToTrim, 0);
                        if (needsRefresh) {
                            this.refresh(0, this.rows - 1);
                        }
                    }
                }
                break;
        }
        this.options[key] = value;
        switch (key) {
            case 'fontFamily':
            case 'fontSize':
                if (this.renderer) {
                    this.renderer.clear();
                    this.charMeasure.measure(this.options);
                }
                break;
            case 'drawBoldTextInBrightColors':
            case 'experimentalCharAtlas':
            case 'enableBold':
            case 'letterSpacing':
            case 'lineHeight':
            case 'fontWeight':
            case 'fontWeightBold':
                if (this.renderer) {
                    this.renderer.clear();
                    this.renderer.onResize(this.cols, this.rows);
                    this.refresh(0, this.rows - 1);
                }
                break;
            case 'rendererType':
                if (this.renderer) {
                    this.unregister(this.renderer);
                    this.renderer.dispose();
                    this.renderer = null;
                }
                this._setupRenderer();
                this.renderer.onCharSizeChanged();
                if (this._theme) {
                    this.renderer.setTheme(this._theme);
                }
                this.mouseHelper.setRenderer(this.renderer);
                break;
            case 'scrollback':
                this.buffers.resize(this.cols, this.rows);
                if (this.viewport) {
                    this.viewport.syncScrollArea();
                }
                break;
            case 'screenReaderMode':
                if (value) {
                    if (!this._accessibilityManager) {
                        this._accessibilityManager = new AccessibilityManager_1.AccessibilityManager(this);
                    }
                }
                else {
                    if (this._accessibilityManager) {
                        this._accessibilityManager.dispose();
                        this._accessibilityManager = null;
                    }
                }
                break;
            case 'tabStopWidth':
                this.buffers.setupTabStops();
                break;
        }
        if (this.renderer) {
            this.renderer.onOptionsChanged();
        }
    };
    Terminal.prototype._onTextAreaFocus = function (ev) {
        if (this.sendFocus) {
            this.handler(EscapeSequences_1.C0.ESC + '[I');
        }
        this.updateCursorStyle(ev);
        this.element.classList.add('focus');
        this.showCursor();
        this.emit('focus');
    };
    Terminal.prototype.blur = function () {
        return this.textarea.blur();
    };
    Terminal.prototype._onTextAreaBlur = function () {
        this.textarea.value = '';
        this.refresh(this.buffer.y, this.buffer.y);
        if (this.sendFocus) {
            this.handler(EscapeSequences_1.C0.ESC + '[O');
        }
        this.element.classList.remove('focus');
        this.emit('blur');
    };
    Terminal.prototype._initGlobal = function () {
        var _this = this;
        this._bindKeys();
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'copy', function (event) {
            if (!_this.hasSelection()) {
                return;
            }
            Clipboard_1.copyHandler(event, _this, _this.selectionManager);
        }));
        var pasteHandlerWrapper = function (event) { return Clipboard_1.pasteHandler(event, _this); };
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'paste', pasteHandlerWrapper));
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'paste', pasteHandlerWrapper));
        if (Browser.isFirefox) {
            this.register(Lifecycle_1.addDisposableDomListener(this.element, 'mousedown', function (event) {
                if (event.button === 2) {
                    Clipboard_1.rightClickHandler(event, _this, _this.selectionManager, _this.options.rightClickSelectsWord);
                }
            }));
        }
        else {
            this.register(Lifecycle_1.addDisposableDomListener(this.element, 'contextmenu', function (event) {
                Clipboard_1.rightClickHandler(event, _this, _this.selectionManager, _this.options.rightClickSelectsWord);
            }));
        }
        if (Browser.isLinux) {
            this.register(Lifecycle_1.addDisposableDomListener(this.element, 'auxclick', function (event) {
                if (event.button === 1) {
                    Clipboard_1.moveTextAreaUnderMouseCursor(event, _this);
                }
            }));
        }
    };
    Terminal.prototype._bindKeys = function () {
        var _this = this;
        var self = this;
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'keydown', function (ev) {
            if (document.activeElement !== this) {
                return;
            }
            self._keyDown(ev);
        }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'keypress', function (ev) {
            if (document.activeElement !== this) {
                return;
            }
            self._keyPress(ev);
        }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'keyup', function (ev) {
            if (!wasModifierKeyOnlyEvent(ev)) {
                _this.focus();
            }
            self._keyUp(ev);
        }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'keydown', function (ev) { return _this._keyDown(ev); }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'keypress', function (ev) { return _this._keyPress(ev); }, true));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'compositionstart', function () { return _this._compositionHelper.compositionstart(); }));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'compositionupdate', function (e) { return _this._compositionHelper.compositionupdate(e); }));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'compositionend', function () { return _this._compositionHelper.compositionend(); }));
        this.register(this.addDisposableListener('refresh', function () { return _this._compositionHelper.updateCompositionElements(); }));
        this.register(this.addDisposableListener('refresh', function (data) { return _this._queueLinkification(data.start, data.end); }));
    };
    Terminal.prototype.open = function (parent) {
        var _this = this;
        this._parent = parent || this._parent;
        if (!this._parent) {
            throw new Error('Terminal requires a parent element.');
        }
        this._context = this._parent.ownerDocument.defaultView;
        this._document = this._parent.ownerDocument;
        this._screenDprMonitor = new ScreenDprMonitor_1.ScreenDprMonitor();
        this._screenDprMonitor.setListener(function () { return _this.emit('dprchange', window.devicePixelRatio); });
        this.register(this._screenDprMonitor);
        this.element = this._document.createElement('div');
        this.element.dir = 'ltr';
        this.element.classList.add('terminal');
        this.element.classList.add('xterm');
        this.element.setAttribute('tabindex', '0');
        this._parent.appendChild(this.element);
        var fragment = document.createDocumentFragment();
        this._viewportElement = document.createElement('div');
        this._viewportElement.classList.add('xterm-viewport');
        fragment.appendChild(this._viewportElement);
        this._viewportScrollArea = document.createElement('div');
        this._viewportScrollArea.classList.add('xterm-scroll-area');
        this._viewportElement.appendChild(this._viewportScrollArea);
        this.screenElement = document.createElement('div');
        this.screenElement.classList.add('xterm-screen');
        this._helperContainer = document.createElement('div');
        this._helperContainer.classList.add('xterm-helpers');
        this.screenElement.appendChild(this._helperContainer);
        fragment.appendChild(this.screenElement);
        this._mouseZoneManager = new MouseZoneManager_1.MouseZoneManager(this);
        this.register(this._mouseZoneManager);
        this.register(this.addDisposableListener('scroll', function () { return _this._mouseZoneManager.clearAll(); }));
        this.linkifier.attachToDom(this._mouseZoneManager);
        this.textarea = document.createElement('textarea');
        this.textarea.classList.add('xterm-helper-textarea');
        this.textarea.setAttribute('aria-label', Strings.promptLabel);
        this.textarea.setAttribute('aria-multiline', 'false');
        this.textarea.setAttribute('autocorrect', 'off');
        this.textarea.setAttribute('autocapitalize', 'off');
        this.textarea.setAttribute('spellcheck', 'false');
        this.textarea.tabIndex = 0;
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'focus', function (ev) { return _this._onTextAreaFocus(ev); }));
        this.register(Lifecycle_1.addDisposableDomListener(this.textarea, 'blur', function () { return _this._onTextAreaBlur(); }));
        this._helperContainer.appendChild(this.textarea);
        this._compositionView = document.createElement('div');
        this._compositionView.classList.add('composition-view');
        this._compositionHelper = new CompositionHelper_1.CompositionHelper(this.textarea, this._compositionView, this);
        this._helperContainer.appendChild(this._compositionView);
        this.charMeasure = new CharMeasure_1.CharMeasure(document, this._helperContainer);
        this.element.appendChild(fragment);
        this._setupRenderer();
        this._theme = this.options.theme;
        this.options.theme = null;
        this.viewport = new Viewport_1.Viewport(this, this._viewportElement, this._viewportScrollArea, this.charMeasure);
        this.viewport.onThemeChanged(this.renderer.colorManager.colors);
        this.register(this.viewport);
        this.register(this.addDisposableListener('cursormove', function () { return _this.renderer.onCursorMove(); }));
        this.register(this.addDisposableListener('resize', function () { return _this.renderer.onResize(_this.cols, _this.rows); }));
        this.register(this.addDisposableListener('blur', function () { return _this.renderer.onBlur(); }));
        this.register(this.addDisposableListener('focus', function () { return _this.renderer.onFocus(); }));
        this.register(this.addDisposableListener('dprchange', function () { return _this.renderer.onWindowResize(window.devicePixelRatio); }));
        this.register(Lifecycle_1.addDisposableDomListener(window, 'resize', function () { return _this.renderer.onWindowResize(window.devicePixelRatio); }));
        this.register(this.charMeasure.addDisposableListener('charsizechanged', function () { return _this.renderer.onCharSizeChanged(); }));
        this.register(this.renderer.addDisposableListener('resize', function (dimensions) { return _this.viewport.syncScrollArea(); }));
        this.selectionManager = new SelectionManager_1.SelectionManager(this, this.charMeasure);
        this.register(Lifecycle_1.addDisposableDomListener(this.element, 'mousedown', function (e) { return _this.selectionManager.onMouseDown(e); }));
        this.register(this.selectionManager.addDisposableListener('refresh', function (data) { return _this.renderer.onSelectionChanged(data.start, data.end, data.columnSelectMode); }));
        this.register(this.selectionManager.addDisposableListener('newselection', function (text) {
            _this.textarea.value = text;
            _this.textarea.focus();
            _this.textarea.select();
        }));
        this.register(this.addDisposableListener('scroll', function () {
            _this.viewport.syncScrollArea();
            _this.selectionManager.refresh();
        }));
        this.register(Lifecycle_1.addDisposableDomListener(this._viewportElement, 'scroll', function () { return _this.selectionManager.refresh(); }));
        this.mouseHelper = new MouseHelper_1.MouseHelper(this.renderer);
        this.element.classList.toggle('enable-mouse-events', this.mouseEvents);
        if (this.options.screenReaderMode) {
            this._accessibilityManager = new AccessibilityManager_1.AccessibilityManager(this);
        }
        this.charMeasure.measure(this.options);
        this.refresh(0, this.rows - 1);
        this._initGlobal();
        this.bindMouse();
    };
    Terminal.prototype._setupRenderer = function () {
        switch (this.options.rendererType) {
            case 'canvas':
                this.renderer = new Renderer_1.Renderer(this, this.options.theme);
                break;
            case 'dom':
                this.renderer = new DomRenderer_1.DomRenderer(this, this.options.theme);
                break;
            default: throw new Error("Unrecognized rendererType \"" + this.options.rendererType + "\"");
        }
        this.register(this.renderer);
    };
    Terminal.prototype._setTheme = function (theme) {
        this._theme = theme;
        var colors = this.renderer.setTheme(theme);
        if (this.viewport) {
            this.viewport.onThemeChanged(colors);
        }
    };
    Terminal.prototype.bindMouse = function () {
        var _this = this;
        var el = this.element;
        var self = this;
        var pressed = 32;
        function sendButton(ev) {
            var button;
            var pos;
            button = getButton(ev);
            pos = self.mouseHelper.getRawByteCoords(ev, self.screenElement, self.charMeasure, self.cols, self.rows);
            if (!pos)
                return;
            sendEvent(button, pos);
            switch (ev.overrideType || ev.type) {
                case 'mousedown':
                    pressed = button;
                    break;
                case 'mouseup':
                    pressed = 32;
                    break;
                case 'wheel':
                    break;
            }
        }
        function sendMove(ev) {
            var button = pressed;
            var pos = self.mouseHelper.getRawByteCoords(ev, self.screenElement, self.charMeasure, self.cols, self.rows);
            if (!pos)
                return;
            button += 32;
            sendEvent(button, pos);
        }
        function encode(data, ch) {
            if (!self.utfMouse) {
                if (ch === 255) {
                    data.push(0);
                    return;
                }
                if (ch > 127)
                    ch = 127;
                data.push(ch);
            }
            else {
                if (ch === 2047) {
                    data.push(0);
                    return;
                }
                if (ch < 127) {
                    data.push(ch);
                }
                else {
                    if (ch > 2047)
                        ch = 2047;
                    data.push(0xC0 | (ch >> 6));
                    data.push(0x80 | (ch & 0x3F));
                }
            }
        }
        function sendEvent(button, pos) {
            if (self._vt300Mouse) {
                button &= 3;
                pos.x -= 32;
                pos.y -= 32;
                var data_1 = EscapeSequences_1.C0.ESC + '[24';
                if (button === 0)
                    data_1 += '1';
                else if (button === 1)
                    data_1 += '3';
                else if (button === 2)
                    data_1 += '5';
                else if (button === 3)
                    return;
                else
                    data_1 += '0';
                data_1 += '~[' + pos.x + ',' + pos.y + ']\r';
                self.handler(data_1);
                return;
            }
            if (self._decLocator) {
                button &= 3;
                pos.x -= 32;
                pos.y -= 32;
                if (button === 0)
                    button = 2;
                else if (button === 1)
                    button = 4;
                else if (button === 2)
                    button = 6;
                else if (button === 3)
                    button = 3;
                self.handler(EscapeSequences_1.C0.ESC + '['
                    + button
                    + ';'
                    + (button === 3 ? 4 : 0)
                    + ';'
                    + pos.y
                    + ';'
                    + pos.x
                    + ';'
                    + pos.page || 0
                    + '&w');
                return;
            }
            if (self.urxvtMouse) {
                pos.x -= 32;
                pos.y -= 32;
                pos.x++;
                pos.y++;
                self.handler(EscapeSequences_1.C0.ESC + '[' + button + ';' + pos.x + ';' + pos.y + 'M');
                return;
            }
            if (self.sgrMouse) {
                pos.x -= 32;
                pos.y -= 32;
                self.handler(EscapeSequences_1.C0.ESC + '[<'
                    + (((button & 3) === 3 ? button & ~3 : button) - 32)
                    + ';'
                    + pos.x
                    + ';'
                    + pos.y
                    + ((button & 3) === 3 ? 'm' : 'M'));
                return;
            }
            var data = [];
            encode(data, button);
            encode(data, pos.x);
            encode(data, pos.y);
            self.handler(EscapeSequences_1.C0.ESC + '[M' + String.fromCharCode.apply(String, data));
        }
        function getButton(ev) {
            var button;
            var shift;
            var meta;
            var ctrl;
            var mod;
            switch (ev.overrideType || ev.type) {
                case 'mousedown':
                    button = ev.button !== null && ev.button !== undefined
                        ? +ev.button
                        : ev.which !== null && ev.which !== undefined
                            ? ev.which - 1
                            : null;
                    if (Browser.isMSIE) {
                        button = button === 1 ? 0 : button === 4 ? 1 : button;
                    }
                    break;
                case 'mouseup':
                    button = 3;
                    break;
                case 'DOMMouseScroll':
                    button = ev.detail < 0
                        ? 64
                        : 65;
                    break;
                case 'wheel':
                    button = ev.deltaY < 0
                        ? 64
                        : 65;
                    break;
            }
            shift = ev.shiftKey ? 4 : 0;
            meta = ev.metaKey ? 8 : 0;
            ctrl = ev.ctrlKey ? 16 : 0;
            mod = shift | meta | ctrl;
            if (self.vt200Mouse) {
                mod &= ctrl;
            }
            else if (!self.normalMouse) {
                mod = 0;
            }
            button = (32 + (mod << 2)) + button;
            return button;
        }
        this.register(Lifecycle_1.addDisposableDomListener(el, 'mousedown', function (ev) {
            ev.preventDefault();
            _this.focus();
            if (!_this.mouseEvents || _this.selectionManager.shouldForceSelection(ev)) {
                return;
            }
            sendButton(ev);
            if (_this.vt200Mouse) {
                ev.overrideType = 'mouseup';
                sendButton(ev);
                return _this.cancel(ev);
            }
            var moveHandler;
            if (_this.normalMouse) {
                moveHandler = function (event) {
                    if (!_this.normalMouse) {
                        return;
                    }
                    sendMove(event);
                };
                _this._document.addEventListener('mousemove', moveHandler);
            }
            var handler = function (ev) {
                if (_this.normalMouse && !_this.x10Mouse) {
                    sendButton(ev);
                }
                if (moveHandler) {
                    _this._document.removeEventListener('mousemove', moveHandler);
                    moveHandler = null;
                }
                _this._document.removeEventListener('mouseup', handler);
                return _this.cancel(ev);
            };
            _this._document.addEventListener('mouseup', handler);
            return _this.cancel(ev);
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'wheel', function (ev) {
            if (!_this.mouseEvents) {
                if (!_this.buffer.hasScrollback) {
                    var amount = _this.viewport.getLinesScrolled(ev);
                    if (amount === 0) {
                        return;
                    }
                    var sequence = EscapeSequences_1.C0.ESC + (_this.applicationCursor ? 'O' : '[') + (ev.deltaY < 0 ? 'A' : 'B');
                    var data = '';
                    for (var i = 0; i < Math.abs(amount); i++) {
                        data += sequence;
                    }
                    _this.handler(data);
                }
                return;
            }
            if (_this.x10Mouse || _this._vt300Mouse || _this._decLocator)
                return;
            sendButton(ev);
            ev.preventDefault();
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'wheel', function (ev) {
            if (_this.mouseEvents)
                return;
            _this.viewport.onWheel(ev);
            return _this.cancel(ev);
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'touchstart', function (ev) {
            if (_this.mouseEvents)
                return;
            _this.viewport.onTouchStart(ev);
            return _this.cancel(ev);
        }));
        this.register(Lifecycle_1.addDisposableDomListener(el, 'touchmove', function (ev) {
            if (_this.mouseEvents)
                return;
            _this.viewport.onTouchMove(ev);
            return _this.cancel(ev);
        }));
    };
    Terminal.prototype.refresh = function (start, end) {
        if (this.renderer) {
            this.renderer.refreshRows(start, end);
        }
    };
    Terminal.prototype._queueLinkification = function (start, end) {
        if (this.linkifier) {
            this.linkifier.linkifyRows(start, end);
        }
    };
    Terminal.prototype.updateCursorStyle = function (ev) {
        if (this.selectionManager && this.selectionManager.shouldColumnSelect(ev)) {
            this.element.classList.add('column-select');
        }
        else {
            this.element.classList.remove('column-select');
        }
    };
    Terminal.prototype.showCursor = function () {
        if (!this.cursorState) {
            this.cursorState = 1;
            this.refresh(this.buffer.y, this.buffer.y);
        }
    };
    Terminal.prototype.scroll = function (isWrapped) {
        if (isWrapped === void 0) { isWrapped = false; }
        var newLine;
        newLine = this._blankLine;
        if (!newLine || newLine.length !== this.cols || newLine.get(0)[Buffer_1.CHAR_DATA_ATTR_INDEX] !== this.eraseAttr()) {
            newLine = this.buffer.getBlankLine(this.eraseAttr(), isWrapped);
            this._blankLine = newLine;
        }
        newLine.isWrapped = isWrapped;
        var topRow = this.buffer.ybase + this.buffer.scrollTop;
        var bottomRow = this.buffer.ybase + this.buffer.scrollBottom;
        if (this.buffer.scrollTop === 0) {
            var willBufferBeTrimmed = this.buffer.lines.isFull;
            if (bottomRow === this.buffer.lines.length - 1) {
                if (willBufferBeTrimmed) {
                    this.buffer.lines.recycle().copyFrom(newLine);
                }
                else {
                    this.buffer.lines.push(newLine.clone());
                }
            }
            else {
                this.buffer.lines.splice(bottomRow + 1, 0, newLine.clone());
            }
            if (!willBufferBeTrimmed) {
                this.buffer.ybase++;
                if (!this._userScrolling) {
                    this.buffer.ydisp++;
                }
            }
            else {
                if (this._userScrolling) {
                    this.buffer.ydisp = Math.max(this.buffer.ydisp - 1, 0);
                }
            }
        }
        else {
            var scrollRegionHeight = bottomRow - topRow + 1;
            this.buffer.lines.shiftElements(topRow + 1, scrollRegionHeight - 1, -1);
            this.buffer.lines.set(bottomRow, newLine.clone());
        }
        if (!this._userScrolling) {
            this.buffer.ydisp = this.buffer.ybase;
        }
        this.updateRange(this.buffer.scrollTop);
        this.updateRange(this.buffer.scrollBottom);
        this.emit('scroll', this.buffer.ydisp);
    };
    Terminal.prototype.scrollLines = function (disp, suppressScrollEvent) {
        if (disp < 0) {
            if (this.buffer.ydisp === 0) {
                return;
            }
            this._userScrolling = true;
        }
        else if (disp + this.buffer.ydisp >= this.buffer.ybase) {
            this._userScrolling = false;
        }
        var oldYdisp = this.buffer.ydisp;
        this.buffer.ydisp = Math.max(Math.min(this.buffer.ydisp + disp, this.buffer.ybase), 0);
        if (oldYdisp === this.buffer.ydisp) {
            return;
        }
        if (!suppressScrollEvent) {
            this.emit('scroll', this.buffer.ydisp);
        }
        this.refresh(0, this.rows - 1);
    };
    Terminal.prototype.scrollPages = function (pageCount) {
        this.scrollLines(pageCount * (this.rows - 1));
    };
    Terminal.prototype.scrollToTop = function () {
        this.scrollLines(-this.buffer.ydisp);
    };
    Terminal.prototype.scrollToBottom = function () {
        this.scrollLines(this.buffer.ybase - this.buffer.ydisp);
    };
    Terminal.prototype.scrollToLine = function (line) {
        var scrollAmount = line - this.buffer.ydisp;
        if (scrollAmount !== 0) {
            this.scrollLines(scrollAmount);
        }
    };
    Terminal.prototype.write = function (data) {
        var _this = this;
        if (this._isDisposed) {
            return;
        }
        if (!data) {
            return;
        }
        this.writeBuffer.push(data);
        if (this.options.useFlowControl && !this._xoffSentToCatchUp && this.writeBuffer.length >= WRITE_BUFFER_PAUSE_THRESHOLD) {
            this.handler(EscapeSequences_1.C0.DC3);
            this._xoffSentToCatchUp = true;
        }
        if (!this._writeInProgress && this.writeBuffer.length > 0) {
            this._writeInProgress = true;
            setTimeout(function () {
                _this._innerWrite();
            });
        }
    };
    Terminal.prototype._innerWrite = function () {
        var _this = this;
        if (this._isDisposed) {
            this.writeBuffer = [];
        }
        var writeBatch = this.writeBuffer.splice(0, WRITE_BATCH_SIZE);
        while (writeBatch.length > 0) {
            var data = writeBatch.shift();
            if (this._xoffSentToCatchUp && writeBatch.length === 0 && this.writeBuffer.length === 0) {
                this.handler(EscapeSequences_1.C0.DC1);
                this._xoffSentToCatchUp = false;
            }
            this._refreshStart = this.buffer.y;
            this._refreshEnd = this.buffer.y;
            this._inputHandler.parse(data);
            this.updateRange(this.buffer.y);
            this.refresh(this._refreshStart, this._refreshEnd);
        }
        if (this.writeBuffer.length > 0) {
            setTimeout(function () { return _this._innerWrite(); }, 0);
        }
        else {
            this._writeInProgress = false;
        }
    };
    Terminal.prototype.writeln = function (data) {
        this.write(data + '\r\n');
    };
    Terminal.prototype.attachCustomKeyEventHandler = function (customKeyEventHandler) {
        this._customKeyEventHandler = customKeyEventHandler;
    };
    Terminal.prototype.addCsiHandler = function (flag, callback) {
        return this._inputHandler.addCsiHandler(flag, callback);
    };
    Terminal.prototype.addOscHandler = function (ident, callback) {
        return this._inputHandler.addOscHandler(ident, callback);
    };
    Terminal.prototype.registerLinkMatcher = function (regex, handler, options) {
        var matcherId = this.linkifier.registerLinkMatcher(regex, handler, options);
        this.refresh(0, this.rows - 1);
        return matcherId;
    };
    Terminal.prototype.deregisterLinkMatcher = function (matcherId) {
        if (this.linkifier.deregisterLinkMatcher(matcherId)) {
            this.refresh(0, this.rows - 1);
        }
    };
    Terminal.prototype.registerCharacterJoiner = function (handler) {
        var joinerId = this.renderer.registerCharacterJoiner(handler);
        this.refresh(0, this.rows - 1);
        return joinerId;
    };
    Terminal.prototype.deregisterCharacterJoiner = function (joinerId) {
        if (this.renderer.deregisterCharacterJoiner(joinerId)) {
            this.refresh(0, this.rows - 1);
        }
    };
    Object.defineProperty(Terminal.prototype, "markers", {
        get: function () {
            return this.buffer.markers;
        },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.addMarker = function (cursorYOffset) {
        if (this.buffer !== this.buffers.normal) {
            return;
        }
        return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + cursorYOffset);
    };
    Terminal.prototype.hasSelection = function () {
        return this.selectionManager ? this.selectionManager.hasSelection : false;
    };
    Terminal.prototype.getSelection = function () {
        return this.selectionManager ? this.selectionManager.selectionText : '';
    };
    Terminal.prototype.clearSelection = function () {
        if (this.selectionManager) {
            this.selectionManager.clearSelection();
        }
    };
    Terminal.prototype.selectAll = function () {
        if (this.selectionManager) {
            this.selectionManager.selectAll();
        }
    };
    Terminal.prototype.selectLines = function (start, end) {
        if (this.selectionManager) {
            this.selectionManager.selectLines(start, end);
        }
    };
    Terminal.prototype._keyDown = function (event) {
        if (this._customKeyEventHandler && this._customKeyEventHandler(event) === false) {
            return false;
        }
        if (!this._compositionHelper.keydown(event)) {
            if (this.buffer.ybase !== this.buffer.ydisp) {
                this.scrollToBottom();
            }
            return false;
        }
        var result = Keyboard_1.evaluateKeyboardEvent(event, this.applicationCursor, this.browser.isMac, this.options.macOptionIsMeta);
        this.updateCursorStyle(event);
        if (result.type === 3 || result.type === 2) {
            var scrollCount = this.rows - 1;
            this.scrollLines(result.type === 2 ? -scrollCount : scrollCount);
            return this.cancel(event, true);
        }
        if (result.type === 1) {
            this.selectAll();
        }
        if (this._isThirdLevelShift(this.browser, event)) {
            return true;
        }
        if (result.cancel) {
            this.cancel(event, true);
        }
        if (!result.key) {
            return true;
        }
        this.emit('keydown', event);
        this.emit('key', result.key, event);
        this.showCursor();
        this.handler(result.key);
        return this.cancel(event, true);
    };
    Terminal.prototype._isThirdLevelShift = function (browser, ev) {
        var thirdLevelKey = (browser.isMac && !this.options.macOptionIsMeta && ev.altKey && !ev.ctrlKey && !ev.metaKey) ||
            (browser.isMSWindows && ev.altKey && ev.ctrlKey && !ev.metaKey);
        if (ev.type === 'keypress') {
            return thirdLevelKey;
        }
        return thirdLevelKey && (!ev.keyCode || ev.keyCode > 47);
    };
    Terminal.prototype.setgLevel = function (g) {
        this.glevel = g;
        this.charset = this.charsets[g];
    };
    Terminal.prototype.setgCharset = function (g, charset) {
        this.charsets[g] = charset;
        if (this.glevel === g) {
            this.charset = charset;
        }
    };
    Terminal.prototype._keyUp = function (ev) {
        this.updateCursorStyle(ev);
    };
    Terminal.prototype._keyPress = function (ev) {
        var key;
        if (this._customKeyEventHandler && this._customKeyEventHandler(ev) === false) {
            return false;
        }
        this.cancel(ev);
        if (ev.charCode) {
            key = ev.charCode;
        }
        else if (ev.which === null || ev.which === undefined) {
            key = ev.keyCode;
        }
        else if (ev.which !== 0 && ev.charCode !== 0) {
            key = ev.which;
        }
        else {
            return false;
        }
        if (!key || ((ev.altKey || ev.ctrlKey || ev.metaKey) && !this._isThirdLevelShift(this.browser, ev))) {
            return false;
        }
        key = String.fromCharCode(key);
        this.emit('keypress', key, ev);
        this.emit('key', key, ev);
        this.showCursor();
        this.handler(key);
        return true;
    };
    Terminal.prototype.bell = function () {
        var _this = this;
        this.emit('bell');
        if (this._soundBell()) {
            this.soundManager.playBellSound();
        }
        if (this._visualBell()) {
            this.element.classList.add('visual-bell-active');
            clearTimeout(this._visualBellTimer);
            this._visualBellTimer = window.setTimeout(function () {
                _this.element.classList.remove('visual-bell-active');
            }, 200);
        }
    };
    Terminal.prototype.log = function (text, data) {
        if (!this.options.debug)
            return;
        if (!this._context.console || !this._context.console.log)
            return;
        this._context.console.log(text, data);
    };
    Terminal.prototype.error = function (text, data) {
        if (!this.options.debug)
            return;
        if (!this._context.console || !this._context.console.error)
            return;
        this._context.console.error(text, data);
    };
    Terminal.prototype.resize = function (x, y) {
        if (isNaN(x) || isNaN(y)) {
            return;
        }
        if (x === this.cols && y === this.rows) {
            if (this.charMeasure && (!this.charMeasure.width || !this.charMeasure.height)) {
                this.charMeasure.measure(this.options);
            }
            return;
        }
        if (x < MINIMUM_COLS)
            x = MINIMUM_COLS;
        if (y < MINIMUM_ROWS)
            y = MINIMUM_ROWS;
        this.buffers.resize(x, y);
        this.cols = x;
        this.rows = y;
        this.buffers.setupTabStops(this.cols);
        if (this.charMeasure) {
            this.charMeasure.measure(this.options);
        }
        this.refresh(0, this.rows - 1);
        this.emit('resize', { cols: x, rows: y });
    };
    Terminal.prototype.updateRange = function (y) {
        if (y < this._refreshStart)
            this._refreshStart = y;
        if (y > this._refreshEnd)
            this._refreshEnd = y;
    };
    Terminal.prototype.maxRange = function () {
        this._refreshStart = 0;
        this._refreshEnd = this.rows - 1;
    };
    Terminal.prototype.clear = function () {
        if (this.buffer.ybase === 0 && this.buffer.y === 0) {
            return;
        }
        this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y));
        this.buffer.lines.length = 1;
        this.buffer.ydisp = 0;
        this.buffer.ybase = 0;
        this.buffer.y = 0;
        for (var i = 1; i < this.rows; i++) {
            this.buffer.lines.push(this.buffer.getBlankLine(Buffer_1.DEFAULT_ATTR));
        }
        this.refresh(0, this.rows - 1);
        this.emit('scroll', this.buffer.ydisp);
    };
    Terminal.prototype.ch = function (cur) {
        if (cur) {
            return [this.eraseAttr(), Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
        }
        return [Buffer_1.DEFAULT_ATTR, Buffer_1.NULL_CELL_CHAR, Buffer_1.NULL_CELL_WIDTH, Buffer_1.NULL_CELL_CODE];
    };
    Terminal.prototype.is = function (term) {
        return (this.options.termName + '').indexOf(term) === 0;
    };
    Terminal.prototype.handler = function (data) {
        if (this.options.disableStdin) {
            return;
        }
        if (this.selectionManager && this.selectionManager.hasSelection) {
            this.selectionManager.clearSelection();
        }
        if (this.buffer.ybase !== this.buffer.ydisp) {
            this.scrollToBottom();
        }
        this.emit('data', data);
    };
    Terminal.prototype.handleTitle = function (title) {
        this.emit('title', title);
    };
    Terminal.prototype.index = function () {
        this.buffer.y++;
        if (this.buffer.y > this.buffer.scrollBottom) {
            this.buffer.y--;
            this.scroll();
        }
        if (this.buffer.x >= this.cols) {
            this.buffer.x--;
        }
    };
    Terminal.prototype.reverseIndex = function () {
        if (this.buffer.y === this.buffer.scrollTop) {
            var scrollRegionHeight = this.buffer.scrollBottom - this.buffer.scrollTop;
            this.buffer.lines.shiftElements(this.buffer.y + this.buffer.ybase, scrollRegionHeight, 1);
            this.buffer.lines.set(this.buffer.y + this.buffer.ybase, this.buffer.getBlankLine(this.eraseAttr()));
            this.updateRange(this.buffer.scrollTop);
            this.updateRange(this.buffer.scrollBottom);
        }
        else {
            this.buffer.y--;
        }
    };
    Terminal.prototype.reset = function () {
        this.options.rows = this.rows;
        this.options.cols = this.cols;
        var customKeyEventHandler = this._customKeyEventHandler;
        var inputHandler = this._inputHandler;
        var cursorState = this.cursorState;
        this._setup();
        this._customKeyEventHandler = customKeyEventHandler;
        this._inputHandler = inputHandler;
        this.cursorState = cursorState;
        this.refresh(0, this.rows - 1);
        if (this.viewport) {
            this.viewport.syncScrollArea();
        }
    };
    Terminal.prototype.tabSet = function () {
        this.buffer.tabs[this.buffer.x] = true;
    };
    Terminal.prototype.cancel = function (ev, force) {
        if (!this.options.cancelEvents && !force) {
            return;
        }
        ev.preventDefault();
        ev.stopPropagation();
        return false;
    };
    Terminal.prototype.matchColor = function (r1, g1, b1) {
        var hash = (r1 << 16) | (g1 << 8) | b1;
        if (matchColorCache[hash] !== null && matchColorCache[hash] !== undefined) {
            return matchColorCache[hash];
        }
        var ldiff = Infinity;
        var li = -1;
        var i = 0;
        var c;
        var r2;
        var g2;
        var b2;
        var diff;
        for (; i < ColorManager_1.DEFAULT_ANSI_COLORS.length; i++) {
            c = ColorManager_1.DEFAULT_ANSI_COLORS[i].rgba;
            r2 = c >>> 24;
            g2 = c >>> 16 & 0xFF;
            b2 = c >>> 8 & 0xFF;
            diff = matchColorDistance(r1, g1, b1, r2, g2, b2);
            if (diff === 0) {
                li = i;
                break;
            }
            if (diff < ldiff) {
                ldiff = diff;
                li = i;
            }
        }
        return matchColorCache[hash] = li;
    };
    Terminal.prototype._visualBell = function () {
        return false;
    };
    Terminal.prototype._soundBell = function () {
        return this.options.bellStyle === 'sound';
    };
    return Terminal;
}(EventEmitter_1.EventEmitter));
exports.Terminal = Terminal;
function wasModifierKeyOnlyEvent(ev) {
    return ev.keyCode === 16 ||
        ev.keyCode === 17 ||
        ev.keyCode === 18;
}
var matchColorCache = {};
function matchColorDistance(r1, g1, b1, r2, g2, b2) {
    return Math.pow(30 * (r1 - r2), 2)
        + Math.pow(59 * (g1 - g2), 2)
        + Math.pow(11 * (b1 - b2), 2);
}

},{"./AccessibilityManager":1,"./Buffer":2,"./BufferSet":5,"./CompositionHelper":7,"./InputHandler":9,"./Linkifier":10,"./SelectionManager":11,"./SoundManager":13,"./Strings":14,"./Viewport":16,"./common/Clone":18,"./common/EventEmitter":19,"./common/data/EscapeSequences":22,"./core/Platform":23,"./core/input/Keyboard":25,"./renderer/ColorManager":31,"./renderer/Renderer":35,"./renderer/atlas/CharAtlasCache":39,"./renderer/dom/DomRenderer":47,"./ui/CharMeasure":49,"./ui/Clipboard":50,"./ui/Lifecycle":51,"./ui/MouseHelper":52,"./ui/MouseZoneManager":53,"./ui/ScreenDprMonitor":55}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = require("./common/Lifecycle");
var Lifecycle_2 = require("./ui/Lifecycle");
var FALLBACK_SCROLL_BAR_WIDTH = 15;
var Viewport = (function (_super) {
    __extends(Viewport, _super);
    function Viewport(_terminal, _viewportElement, _scrollArea, _charMeasure) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._viewportElement = _viewportElement;
        _this._scrollArea = _scrollArea;
        _this._charMeasure = _charMeasure;
        _this.scrollBarWidth = 0;
        _this._currentRowHeight = 0;
        _this._lastRecordedBufferLength = 0;
        _this._lastRecordedViewportHeight = 0;
        _this._lastRecordedBufferHeight = 0;
        _this._lastScrollTop = 0;
        _this._wheelPartialScroll = 0;
        _this._refreshAnimationFrame = null;
        _this._ignoreNextScrollEvent = false;
        _this.scrollBarWidth = (_this._viewportElement.offsetWidth - _this._scrollArea.offsetWidth) || FALLBACK_SCROLL_BAR_WIDTH;
        _this.register(Lifecycle_2.addDisposableDomListener(_this._viewportElement, 'scroll', _this._onScroll.bind(_this)));
        setTimeout(function () { return _this.syncScrollArea(); }, 0);
        return _this;
    }
    Viewport.prototype.onThemeChanged = function (colors) {
        this._viewportElement.style.backgroundColor = colors.background.css;
    };
    Viewport.prototype._refresh = function () {
        var _this = this;
        if (this._refreshAnimationFrame === null) {
            this._refreshAnimationFrame = requestAnimationFrame(function () { return _this._innerRefresh(); });
        }
    };
    Viewport.prototype._innerRefresh = function () {
        if (this._charMeasure.height > 0) {
            this._currentRowHeight = this._terminal.renderer.dimensions.scaledCellHeight / window.devicePixelRatio;
            this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            var newBufferHeight = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._terminal.renderer.dimensions.canvasHeight);
            if (this._lastRecordedBufferHeight !== newBufferHeight) {
                this._lastRecordedBufferHeight = newBufferHeight;
                this._scrollArea.style.height = this._lastRecordedBufferHeight + 'px';
            }
        }
        var scrollTop = this._terminal.buffer.ydisp * this._currentRowHeight;
        if (this._viewportElement.scrollTop !== scrollTop) {
            this._ignoreNextScrollEvent = true;
            this._viewportElement.scrollTop = scrollTop;
        }
        this._refreshAnimationFrame = null;
    };
    Viewport.prototype.syncScrollArea = function () {
        if (this._lastRecordedBufferLength !== this._terminal.buffer.lines.length) {
            this._lastRecordedBufferLength = this._terminal.buffer.lines.length;
            this._refresh();
            return;
        }
        if (this._lastRecordedViewportHeight !== this._terminal.renderer.dimensions.canvasHeight) {
            this._refresh();
            return;
        }
        var newScrollTop = this._terminal.buffer.ydisp * this._currentRowHeight;
        if (this._lastScrollTop !== newScrollTop) {
            this._refresh();
            return;
        }
        if (this._lastScrollTop !== this._viewportElement.scrollTop) {
            this._refresh();
            return;
        }
        if (this._terminal.renderer.dimensions.scaledCellHeight / window.devicePixelRatio !== this._currentRowHeight) {
            this._refresh();
            return;
        }
    };
    Viewport.prototype._onScroll = function (ev) {
        this._lastScrollTop = this._viewportElement.scrollTop;
        if (!this._viewportElement.offsetParent) {
            return;
        }
        if (this._ignoreNextScrollEvent) {
            this._ignoreNextScrollEvent = false;
            return;
        }
        var newRow = Math.round(this._lastScrollTop / this._currentRowHeight);
        var diff = newRow - this._terminal.buffer.ydisp;
        this._terminal.scrollLines(diff, true);
    };
    Viewport.prototype.onWheel = function (ev) {
        var amount = this._getPixelsScrolled(ev);
        if (amount === 0) {
            return;
        }
        this._viewportElement.scrollTop += amount;
        ev.preventDefault();
    };
    Viewport.prototype._getPixelsScrolled = function (ev) {
        if (ev.deltaY === 0) {
            return 0;
        }
        var amount = ev.deltaY;
        if (ev.deltaMode === WheelEvent.DOM_DELTA_LINE) {
            amount *= this._currentRowHeight;
        }
        else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            amount *= this._currentRowHeight * this._terminal.rows;
        }
        return amount;
    };
    Viewport.prototype.getLinesScrolled = function (ev) {
        if (ev.deltaY === 0) {
            return 0;
        }
        var amount = ev.deltaY;
        if (ev.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
            amount /= this._currentRowHeight + 0.0;
            this._wheelPartialScroll += amount;
            amount = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1);
            this._wheelPartialScroll %= 1;
        }
        else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            amount *= this._terminal.rows;
        }
        return amount;
    };
    Viewport.prototype.onTouchStart = function (ev) {
        this._lastTouchY = ev.touches[0].pageY;
    };
    Viewport.prototype.onTouchMove = function (ev) {
        var deltaY = this._lastTouchY - ev.touches[0].pageY;
        this._lastTouchY = ev.touches[0].pageY;
        if (deltaY === 0) {
            return;
        }
        this._viewportElement.scrollTop += deltaY;
        ev.preventDefault();
    };
    return Viewport;
}(Lifecycle_1.Disposable));
exports.Viewport = Viewport;

},{"./common/Lifecycle":20,"./ui/Lifecycle":51}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = require("./EventEmitter");
var CircularList = (function (_super) {
    __extends(CircularList, _super);
    function CircularList(_maxLength) {
        var _this = _super.call(this) || this;
        _this._maxLength = _maxLength;
        _this._array = new Array(_this._maxLength);
        _this._startIndex = 0;
        _this._length = 0;
        return _this;
    }
    Object.defineProperty(CircularList.prototype, "maxLength", {
        get: function () {
            return this._maxLength;
        },
        set: function (newMaxLength) {
            if (this._maxLength === newMaxLength) {
                return;
            }
            var newArray = new Array(newMaxLength);
            for (var i = 0; i < Math.min(newMaxLength, this.length); i++) {
                newArray[i] = this._array[this._getCyclicIndex(i)];
            }
            this._array = newArray;
            this._maxLength = newMaxLength;
            this._startIndex = 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CircularList.prototype, "length", {
        get: function () {
            return this._length;
        },
        set: function (newLength) {
            if (newLength > this._length) {
                for (var i = this._length; i < newLength; i++) {
                    this._array[i] = undefined;
                }
            }
            this._length = newLength;
        },
        enumerable: true,
        configurable: true
    });
    CircularList.prototype.get = function (index) {
        return this._array[this._getCyclicIndex(index)];
    };
    CircularList.prototype.set = function (index, value) {
        this._array[this._getCyclicIndex(index)] = value;
    };
    CircularList.prototype.push = function (value) {
        this._array[this._getCyclicIndex(this._length)] = value;
        if (this._length === this._maxLength) {
            this._startIndex = ++this._startIndex % this._maxLength;
            this.emitMayRemoveListeners('trim', 1);
        }
        else {
            this._length++;
        }
    };
    CircularList.prototype.recycle = function () {
        if (this._length !== this._maxLength) {
            throw new Error('Can only recycle when the buffer is full');
        }
        this._startIndex = ++this._startIndex % this._maxLength;
        this.emitMayRemoveListeners('trim', 1);
        return this._array[this._getCyclicIndex(this._length - 1)];
    };
    Object.defineProperty(CircularList.prototype, "isFull", {
        get: function () {
            return this._length === this._maxLength;
        },
        enumerable: true,
        configurable: true
    });
    CircularList.prototype.pop = function () {
        return this._array[this._getCyclicIndex(this._length-- - 1)];
    };
    CircularList.prototype.splice = function (start, deleteCount) {
        var items = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            items[_i - 2] = arguments[_i];
        }
        if (deleteCount) {
            for (var i = start; i < this._length - deleteCount; i++) {
                this._array[this._getCyclicIndex(i)] = this._array[this._getCyclicIndex(i + deleteCount)];
            }
            this._length -= deleteCount;
        }
        for (var i = this._length - 1; i >= start; i--) {
            this._array[this._getCyclicIndex(i + items.length)] = this._array[this._getCyclicIndex(i)];
        }
        for (var i = 0; i < items.length; i++) {
            this._array[this._getCyclicIndex(start + i)] = items[i];
        }
        if (this._length + items.length > this._maxLength) {
            var countToTrim = (this._length + items.length) - this._maxLength;
            this._startIndex += countToTrim;
            this._length = this._maxLength;
            this.emitMayRemoveListeners('trim', countToTrim);
        }
        else {
            this._length += items.length;
        }
    };
    CircularList.prototype.trimStart = function (count) {
        if (count > this._length) {
            count = this._length;
        }
        this._startIndex += count;
        this._length -= count;
        this.emitMayRemoveListeners('trim', count);
    };
    CircularList.prototype.shiftElements = function (start, count, offset) {
        if (count <= 0) {
            return;
        }
        if (start < 0 || start >= this._length) {
            throw new Error('start argument out of range');
        }
        if (start + offset < 0) {
            throw new Error('Cannot shift elements in list beyond index 0');
        }
        if (offset > 0) {
            for (var i = count - 1; i >= 0; i--) {
                this.set(start + i + offset, this.get(start + i));
            }
            var expandListBy = (start + count + offset) - this._length;
            if (expandListBy > 0) {
                this._length += expandListBy;
                while (this._length > this._maxLength) {
                    this._length--;
                    this._startIndex++;
                    this.emitMayRemoveListeners('trim', 1);
                }
            }
        }
        else {
            for (var i = 0; i < count; i++) {
                this.set(start + i + offset, this.get(start + i));
            }
        }
    };
    CircularList.prototype._getCyclicIndex = function (index) {
        return (this._startIndex + index) % this._maxLength;
    };
    return CircularList;
}(EventEmitter_1.EventEmitter));
exports.CircularList = CircularList;

},{"./EventEmitter":19}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function clone(val, depth) {
    if (depth === void 0) { depth = 5; }
    if (typeof val !== 'object') {
        return val;
    }
    if (val === null) {
        return null;
    }
    var clonedObject = Array.isArray(val) ? [] : {};
    for (var key in val) {
        clonedObject[key] = depth <= 1 ? val[key] : clone(val[key], depth - 1);
    }
    return clonedObject;
}
exports.clone = clone;

},{}],19:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = require("./Lifecycle");
var EventEmitter = (function (_super) {
    __extends(EventEmitter, _super);
    function EventEmitter() {
        var _this = _super.call(this) || this;
        _this._events = _this._events || {};
        return _this;
    }
    EventEmitter.prototype.on = function (type, listener) {
        this._events[type] = this._events[type] || [];
        this._events[type].push(listener);
    };
    EventEmitter.prototype.addDisposableListener = function (type, handler) {
        var _this = this;
        this.on(type, handler);
        var disposed = false;
        return {
            dispose: function () {
                if (disposed) {
                    return;
                }
                _this.off(type, handler);
                disposed = true;
            }
        };
    };
    EventEmitter.prototype.off = function (type, listener) {
        if (!this._events[type]) {
            return;
        }
        var obj = this._events[type];
        var i = obj.length;
        while (i--) {
            if (obj[i] === listener) {
                obj.splice(i, 1);
                return;
            }
        }
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
        if (this._events[type]) {
            delete this._events[type];
        }
    };
    EventEmitter.prototype.emit = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._events[type]) {
            return;
        }
        var obj = this._events[type];
        for (var i = 0; i < obj.length; i++) {
            obj[i].apply(this, args);
        }
    };
    EventEmitter.prototype.emitMayRemoveListeners = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._events[type]) {
            return;
        }
        var obj = this._events[type];
        var length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            obj[i].apply(this, args);
            i -= length - obj.length;
            length = obj.length;
        }
    };
    EventEmitter.prototype.listeners = function (type) {
        return this._events[type] || [];
    };
    EventEmitter.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._events = {};
    };
    return EventEmitter;
}(Lifecycle_1.Disposable));
exports.EventEmitter = EventEmitter;

},{"./Lifecycle":20}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Disposable = (function () {
    function Disposable() {
        this._disposables = [];
        this._isDisposed = false;
    }
    Disposable.prototype.dispose = function () {
        this._isDisposed = true;
        this._disposables.forEach(function (d) { return d.dispose(); });
        this._disposables.length = 0;
    };
    Disposable.prototype.register = function (d) {
        this._disposables.push(d);
    };
    Disposable.prototype.unregister = function (d) {
        var index = this._disposables.indexOf(d);
        if (index !== -1) {
            this._disposables.splice(index, 1);
        }
    };
    return Disposable;
}());
exports.Disposable = Disposable;

},{}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function fill(array, value, start, end) {
    if (array.fill) {
        return array.fill(value, start, end);
    }
    return fillFallback(array, value, start, end);
}
exports.fill = fill;
function fillFallback(array, value, start, end) {
    if (start === void 0) { start = 0; }
    if (end === void 0) { end = array.length; }
    if (start >= array.length) {
        return array;
    }
    start = (array.length + start) % array.length;
    if (end >= array.length) {
        end = array.length;
    }
    else {
        end = (array.length + end) % array.length;
    }
    for (var i = start; i < end; ++i) {
        array[i] = value;
    }
    return array;
}
exports.fillFallback = fillFallback;
function concat(a, b) {
    var result = new a.constructor(a.length + b.length);
    result.set(a);
    result.set(b, a.length);
    return result;
}
exports.concat = concat;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var C0;
(function (C0) {
    C0.NUL = '\x00';
    C0.SOH = '\x01';
    C0.STX = '\x02';
    C0.ETX = '\x03';
    C0.EOT = '\x04';
    C0.ENQ = '\x05';
    C0.ACK = '\x06';
    C0.BEL = '\x07';
    C0.BS = '\x08';
    C0.HT = '\x09';
    C0.LF = '\x0a';
    C0.VT = '\x0b';
    C0.FF = '\x0c';
    C0.CR = '\x0d';
    C0.SO = '\x0e';
    C0.SI = '\x0f';
    C0.DLE = '\x10';
    C0.DC1 = '\x11';
    C0.DC2 = '\x12';
    C0.DC3 = '\x13';
    C0.DC4 = '\x14';
    C0.NAK = '\x15';
    C0.SYN = '\x16';
    C0.ETB = '\x17';
    C0.CAN = '\x18';
    C0.EM = '\x19';
    C0.SUB = '\x1a';
    C0.ESC = '\x1b';
    C0.FS = '\x1c';
    C0.GS = '\x1d';
    C0.RS = '\x1e';
    C0.US = '\x1f';
    C0.SP = '\x20';
    C0.DEL = '\x7f';
})(C0 = exports.C0 || (exports.C0 = {}));
var C1;
(function (C1) {
    C1.PAD = '\x80';
    C1.HOP = '\x81';
    C1.BPH = '\x82';
    C1.NBH = '\x83';
    C1.IND = '\x84';
    C1.NEL = '\x85';
    C1.SSA = '\x86';
    C1.ESA = '\x87';
    C1.HTS = '\x88';
    C1.HTJ = '\x89';
    C1.VTS = '\x8a';
    C1.PLD = '\x8b';
    C1.PLU = '\x8c';
    C1.RI = '\x8d';
    C1.SS2 = '\x8e';
    C1.SS3 = '\x8f';
    C1.DCS = '\x90';
    C1.PU1 = '\x91';
    C1.PU2 = '\x92';
    C1.STS = '\x93';
    C1.CCH = '\x94';
    C1.MW = '\x95';
    C1.SPA = '\x96';
    C1.EPA = '\x97';
    C1.SOS = '\x98';
    C1.SGCI = '\x99';
    C1.SCI = '\x9a';
    C1.CSI = '\x9b';
    C1.ST = '\x9c';
    C1.OSC = '\x9d';
    C1.PM = '\x9e';
    C1.APC = '\x9f';
})(C1 = exports.C1 || (exports.C1 = {}));

},{}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = (typeof navigator === 'undefined') ? true : false;
var userAgent = (isNode) ? 'node' : navigator.userAgent;
var platform = (isNode) ? 'node' : navigator.platform;
exports.isFirefox = !!~userAgent.indexOf('Firefox');
exports.isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
exports.isMSIE = !!~userAgent.indexOf('MSIE') || !!~userAgent.indexOf('Trident');
exports.isMac = contains(['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'], platform);
exports.isIpad = platform === 'iPad';
exports.isIphone = platform === 'iPhone';
exports.isMSWindows = contains(['Windows', 'Win16', 'Win32', 'WinCE'], platform);
exports.isLinux = platform.indexOf('Linux') >= 0;
function contains(arr, el) {
    return arr.indexOf(el) >= 0;
}

},{}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHARSETS = {};
exports.DEFAULT_CHARSET = exports.CHARSETS['B'];
exports.CHARSETS['0'] = {
    '`': '\u25c6',
    'a': '\u2592',
    'b': '\u0009',
    'c': '\u000c',
    'd': '\u000d',
    'e': '\u000a',
    'f': '\u00b0',
    'g': '\u00b1',
    'h': '\u2424',
    'i': '\u000b',
    'j': '\u2518',
    'k': '\u2510',
    'l': '\u250c',
    'm': '\u2514',
    'n': '\u253c',
    'o': '\u23ba',
    'p': '\u23bb',
    'q': '\u2500',
    'r': '\u23bc',
    's': '\u23bd',
    't': '\u251c',
    'u': '\u2524',
    'v': '\u2534',
    'w': '\u252c',
    'x': '\u2502',
    'y': '\u2264',
    'z': '\u2265',
    '{': '\u03c0',
    '|': '\u2260',
    '}': '\u00a3',
    '~': '\u00b7'
};
exports.CHARSETS['A'] = {
    '#': ''
};
exports.CHARSETS['B'] = null;
exports.CHARSETS['4'] = {
    '#': '',
    '@': '',
    '[': 'ij',
    '\\': '',
    ']': '|',
    '{': '',
    '|': 'f',
    '}': '',
    '~': ''
};
exports.CHARSETS['C'] =
    exports.CHARSETS['5'] = {
        '[': '',
        '\\': '',
        ']': '',
        '^': '',
        '`': '',
        '{': '',
        '|': '',
        '}': '',
        '~': ''
    };
exports.CHARSETS['R'] = {
    '#': '',
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '{': '',
    '|': '',
    '}': '',
    '~': ''
};
exports.CHARSETS['Q'] = {
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '^': '',
    '`': '',
    '{': '',
    '|': '',
    '}': '',
    '~': ''
};
exports.CHARSETS['K'] = {
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '{': '',
    '|': '',
    '}': '',
    '~': ''
};
exports.CHARSETS['Y'] = {
    '#': '',
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '`': '',
    '{': '',
    '|': '',
    '}': '',
    '~': ''
};
exports.CHARSETS['E'] =
    exports.CHARSETS['6'] = {
        '@': '',
        '[': '',
        '\\': '',
        ']': '',
        '^': '',
        '`': '',
        '{': '',
        '|': '',
        '}': '',
        '~': ''
    };
exports.CHARSETS['Z'] = {
    '#': '',
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '{': '',
    '|': '',
    '}': ''
};
exports.CHARSETS['H'] =
    exports.CHARSETS['7'] = {
        '@': '',
        '[': '',
        '\\': '',
        ']': '',
        '^': '',
        '`': '',
        '{': '',
        '|': '',
        '}': '',
        '~': ''
    };
exports.CHARSETS['='] = {
    '#': '',
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '^': '',
    '_': '',
    '`': '',
    '{': '',
    '|': '',
    '}': '',
    '~': ''
};

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EscapeSequences_1 = require("../../common/data/EscapeSequences");
var KEYCODE_KEY_MAPPINGS = {
    48: ['0', ')'],
    49: ['1', '!'],
    50: ['2', '@'],
    51: ['3', '#'],
    52: ['4', '$'],
    53: ['5', '%'],
    54: ['6', '^'],
    55: ['7', '&'],
    56: ['8', '*'],
    57: ['9', '('],
    186: [';', ':'],
    187: ['=', '+'],
    188: [',', '<'],
    189: ['-', '_'],
    190: ['.', '>'],
    191: ['/', '?'],
    192: ['`', '~'],
    219: ['[', '{'],
    220: ['\\', '|'],
    221: [']', '}'],
    222: ['\'', '"']
};
function evaluateKeyboardEvent(ev, applicationCursorMode, isMac, macOptionIsMeta) {
    var result = {
        type: 0,
        cancel: false,
        key: undefined
    };
    var modifiers = (ev.shiftKey ? 1 : 0) | (ev.altKey ? 2 : 0) | (ev.ctrlKey ? 4 : 0) | (ev.metaKey ? 8 : 0);
    switch (ev.keyCode) {
        case 0:
            if (ev.key === 'UIKeyInputUpArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OA';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[A';
                }
            }
            else if (ev.key === 'UIKeyInputLeftArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OD';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[D';
                }
            }
            else if (ev.key === 'UIKeyInputRightArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OC';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[C';
                }
            }
            else if (ev.key === 'UIKeyInputDownArrow') {
                if (applicationCursorMode) {
                    result.key = EscapeSequences_1.C0.ESC + 'OB';
                }
                else {
                    result.key = EscapeSequences_1.C0.ESC + '[B';
                }
            }
            break;
        case 8:
            if (ev.shiftKey) {
                result.key = EscapeSequences_1.C0.BS;
                break;
            }
            else if (ev.altKey) {
                result.key = EscapeSequences_1.C0.ESC + EscapeSequences_1.C0.DEL;
                break;
            }
            result.key = EscapeSequences_1.C0.DEL;
            break;
        case 9:
            if (ev.shiftKey) {
                result.key = EscapeSequences_1.C0.ESC + '[Z';
                break;
            }
            result.key = EscapeSequences_1.C0.HT;
            result.cancel = true;
            break;
        case 13:
            result.key = EscapeSequences_1.C0.CR;
            result.cancel = true;
            break;
        case 27:
            result.key = EscapeSequences_1.C0.ESC;
            result.cancel = true;
            break;
        case 37:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'D';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3D') {
                    result.key = isMac ? EscapeSequences_1.C0.ESC + 'b' : EscapeSequences_1.C0.ESC + '[1;5D';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OD';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[D';
            }
            break;
        case 39:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'C';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3C') {
                    result.key = isMac ? EscapeSequences_1.C0.ESC + 'f' : EscapeSequences_1.C0.ESC + '[1;5C';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OC';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[C';
            }
            break;
        case 38:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'A';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3A') {
                    result.key = EscapeSequences_1.C0.ESC + '[1;5A';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OA';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[A';
            }
            break;
        case 40:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'B';
                if (result.key === EscapeSequences_1.C0.ESC + '[1;3B') {
                    result.key = EscapeSequences_1.C0.ESC + '[1;5B';
                }
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OB';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[B';
            }
            break;
        case 45:
            if (!ev.shiftKey && !ev.ctrlKey) {
                result.key = EscapeSequences_1.C0.ESC + '[2~';
            }
            break;
        case 46:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[3;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[3~';
            }
            break;
        case 36:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'H';
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OH';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[H';
            }
            break;
        case 35:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'F';
            }
            else if (applicationCursorMode) {
                result.key = EscapeSequences_1.C0.ESC + 'OF';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[F';
            }
            break;
        case 33:
            if (ev.shiftKey) {
                result.type = 2;
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[5~';
            }
            break;
        case 34:
            if (ev.shiftKey) {
                result.type = 3;
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[6~';
            }
            break;
        case 112:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'P';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OP';
            }
            break;
        case 113:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'Q';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OQ';
            }
            break;
        case 114:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'R';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OR';
            }
            break;
        case 115:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'S';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + 'OS';
            }
            break;
        case 116:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[15;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[15~';
            }
            break;
        case 117:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[17;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[17~';
            }
            break;
        case 118:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[18;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[18~';
            }
            break;
        case 119:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[19;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[19~';
            }
            break;
        case 120:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[20;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[20~';
            }
            break;
        case 121:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[21;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[21~';
            }
            break;
        case 122:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[23;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[23~';
            }
            break;
        case 123:
            if (modifiers) {
                result.key = EscapeSequences_1.C0.ESC + '[24;' + (modifiers + 1) + '~';
            }
            else {
                result.key = EscapeSequences_1.C0.ESC + '[24~';
            }
            break;
        default:
            if (ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey) {
                if (ev.keyCode >= 65 && ev.keyCode <= 90) {
                    result.key = String.fromCharCode(ev.keyCode - 64);
                }
                else if (ev.keyCode === 32) {
                    result.key = String.fromCharCode(0);
                }
                else if (ev.keyCode >= 51 && ev.keyCode <= 55) {
                    result.key = String.fromCharCode(ev.keyCode - 51 + 27);
                }
                else if (ev.keyCode === 56) {
                    result.key = String.fromCharCode(127);
                }
                else if (ev.keyCode === 219) {
                    result.key = String.fromCharCode(27);
                }
                else if (ev.keyCode === 220) {
                    result.key = String.fromCharCode(28);
                }
                else if (ev.keyCode === 221) {
                    result.key = String.fromCharCode(29);
                }
            }
            else if ((!isMac || macOptionIsMeta) && ev.altKey && !ev.metaKey) {
                var keyMapping = KEYCODE_KEY_MAPPINGS[ev.keyCode];
                var key = keyMapping && keyMapping[!ev.shiftKey ? 0 : 1];
                if (key) {
                    result.key = EscapeSequences_1.C0.ESC + key;
                }
                else if (ev.keyCode >= 65 && ev.keyCode <= 90) {
                    var keyCode = ev.ctrlKey ? ev.keyCode - 64 : ev.keyCode + 32;
                    result.key = EscapeSequences_1.C0.ESC + String.fromCharCode(keyCode);
                }
            }
            else if (isMac && !ev.altKey && !ev.ctrlKey && ev.metaKey) {
                if (ev.keyCode === 65) {
                    result.type = 1;
                }
            }
            else if (ev.key && !ev.ctrlKey && !ev.altKey && !ev.metaKey && ev.keyCode >= 48 && ev.key.length === 1) {
                result.key = ev.key;
            }
            break;
    }
    return result;
}
exports.evaluateKeyboardEvent = evaluateKeyboardEvent;

},{"../../common/data/EscapeSequences":22}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var StringToUtf32 = (function () {
    function StringToUtf32() {
        this._interim = 0;
    }
    StringToUtf32.prototype.clear = function () {
        this._interim = 0;
    };
    StringToUtf32.prototype.decode = function (input, target) {
        var length = input.length;
        if (!length) {
            return 0;
        }
        var size = 0;
        var startPos = 0;
        if (this._interim) {
            var second = input.charCodeAt(startPos++);
            if (0xDC00 <= second && second <= 0xDFFF) {
                target[size++] = (this._interim - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
            else {
                target[size++] = this._interim;
                target[size++] = second;
            }
            this._interim = 0;
        }
        for (var i = startPos; i < length; ++i) {
            var code = input.charCodeAt(i);
            if (0xD800 <= code && code <= 0xDBFF) {
                if (++i >= length) {
                    this._interim = code;
                    return size;
                }
                var second = input.charCodeAt(i);
                if (0xDC00 <= second && second <= 0xDFFF) {
                    target[size++] = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                }
                else {
                    target[size++] = code;
                    target[size++] = second;
                }
                continue;
            }
            target[size++] = code;
        }
        return size;
    };
    return StringToUtf32;
}());
exports.StringToUtf32 = StringToUtf32;
function stringFromCodePoint(codePoint) {
    if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        return String.fromCharCode((codePoint >> 10) + 0xD800) + String.fromCharCode((codePoint % 0x400) + 0xDC00);
    }
    return String.fromCharCode(codePoint);
}
exports.stringFromCodePoint = stringFromCodePoint;
function utf32ToString(data, start, end) {
    if (start === void 0) { start = 0; }
    if (end === void 0) { end = data.length; }
    var result = '';
    for (var i = start; i < end; ++i) {
        var codepoint = data[i];
        if (codepoint > 0xFFFF) {
            codepoint -= 0x10000;
            result += String.fromCharCode((codepoint >> 10) + 0xD800) + String.fromCharCode((codepoint % 0x400) + 0xDC00);
        }
        else {
            result += String.fromCharCode(codepoint);
        }
    }
    return result;
}
exports.utf32ToString = utf32ToString;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EscapeSequences_1 = require("../common/data/EscapeSequences");
var AltClickHandler = (function () {
    function AltClickHandler(_mouseEvent, _terminal) {
        var _a;
        this._mouseEvent = _mouseEvent;
        this._terminal = _terminal;
        this._lines = this._terminal.buffer.lines;
        this._startCol = this._terminal.buffer.x;
        this._startRow = this._terminal.buffer.y;
        var coordinates = this._terminal.mouseHelper.getCoords(this._mouseEvent, this._terminal.element, this._terminal.charMeasure, this._terminal.cols, this._terminal.rows, false);
        if (coordinates) {
            _a = coordinates.map(function (coordinate) {
                return coordinate - 1;
            }), this._endCol = _a[0], this._endRow = _a[1];
        }
    }
    AltClickHandler.prototype.move = function () {
        if (this._mouseEvent.altKey && this._endCol !== undefined && this._endRow !== undefined) {
            this._terminal.handler(this._arrowSequences());
        }
    };
    AltClickHandler.prototype._arrowSequences = function () {
        if (!this._terminal.buffer.hasScrollback) {
            return this._resetStartingRow() + this._moveToRequestedRow() + this._moveToRequestedCol();
        }
        return this._moveHorizontallyOnly();
    };
    AltClickHandler.prototype._resetStartingRow = function () {
        if (this._moveToRequestedRow().length === 0) {
            return '';
        }
        return repeat(this._bufferLine(this._startCol, this._startRow, this._startCol, this._startRow - this._wrappedRowsForRow(this._startRow), false).length, this._sequence("D"));
    };
    AltClickHandler.prototype._moveToRequestedRow = function () {
        var startRow = this._startRow - this._wrappedRowsForRow(this._startRow);
        var endRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        var rowsToMove = Math.abs(startRow - endRow) - this._wrappedRowsCount();
        return repeat(rowsToMove, this._sequence(this._verticalDirection()));
    };
    AltClickHandler.prototype._moveToRequestedCol = function () {
        var startRow;
        if (this._moveToRequestedRow().length > 0) {
            startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        }
        else {
            startRow = this._startRow;
        }
        var endRow = this._endRow;
        var direction = this._horizontalDirection();
        return repeat(this._bufferLine(this._startCol, startRow, this._endCol, endRow, direction === "C").length, this._sequence(direction));
    };
    AltClickHandler.prototype._moveHorizontallyOnly = function () {
        var direction = this._horizontalDirection();
        return repeat(Math.abs(this._startCol - this._endCol), this._sequence(direction));
    };
    AltClickHandler.prototype._wrappedRowsCount = function () {
        var wrappedRows = 0;
        var startRow = this._startRow - this._wrappedRowsForRow(this._startRow);
        var endRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        for (var i = 0; i < Math.abs(startRow - endRow); i++) {
            var direction = this._verticalDirection() === "A" ? -1 : 1;
            if (this._lines.get(startRow + (direction * i)).isWrapped) {
                wrappedRows++;
            }
        }
        return wrappedRows;
    };
    AltClickHandler.prototype._wrappedRowsForRow = function (currentRow) {
        var rowCount = 0;
        var lineWraps = this._lines.get(currentRow).isWrapped;
        while (lineWraps && currentRow >= 0 && currentRow < this._terminal.rows) {
            rowCount++;
            currentRow--;
            lineWraps = this._lines.get(currentRow).isWrapped;
        }
        return rowCount;
    };
    AltClickHandler.prototype._horizontalDirection = function () {
        var startRow;
        if (this._moveToRequestedRow().length > 0) {
            startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
        }
        else {
            startRow = this._startRow;
        }
        if ((this._startCol < this._endCol &&
            startRow <= this._endRow) ||
            (this._startCol >= this._endCol &&
                startRow < this._endRow)) {
            return "C";
        }
        return "D";
    };
    AltClickHandler.prototype._verticalDirection = function () {
        if (this._startRow > this._endRow) {
            return "A";
        }
        return "B";
    };
    AltClickHandler.prototype._bufferLine = function (startCol, startRow, endCol, endRow, forward) {
        var currentCol = startCol;
        var currentRow = startRow;
        var bufferStr = '';
        while (currentCol !== endCol || currentRow !== endRow) {
            currentCol += forward ? 1 : -1;
            if (forward && currentCol > this._terminal.cols - 1) {
                bufferStr += this._terminal.buffer.translateBufferLineToString(currentRow, false, startCol, currentCol);
                currentCol = 0;
                startCol = 0;
                currentRow++;
            }
            else if (!forward && currentCol < 0) {
                bufferStr += this._terminal.buffer.translateBufferLineToString(currentRow, false, 0, startCol + 1);
                currentCol = this._terminal.cols - 1;
                startCol = currentCol;
                currentRow--;
            }
        }
        return bufferStr + this._terminal.buffer.translateBufferLineToString(currentRow, false, startCol, currentCol);
    };
    AltClickHandler.prototype._sequence = function (direction) {
        var mod = this._terminal.applicationCursor ? 'O' : '[';
        return EscapeSequences_1.C0.ESC + mod + direction;
    };
    return AltClickHandler;
}());
exports.AltClickHandler = AltClickHandler;
function repeat(count, str) {
    count = Math.floor(count);
    var rpt = '';
    for (var i = 0; i < count; i++) {
        rpt += str;
    }
    return rpt;
}

},{"../common/data/EscapeSequences":22}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Terminal_1 = require("../Terminal");
var Strings = require("../Strings");
var Terminal = (function () {
    function Terminal(options) {
        this._core = new Terminal_1.Terminal(options);
    }
    Object.defineProperty(Terminal.prototype, "element", {
        get: function () { return this._core.element; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "textarea", {
        get: function () { return this._core.textarea; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "rows", {
        get: function () { return this._core.rows; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "cols", {
        get: function () { return this._core.cols; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Terminal.prototype, "markers", {
        get: function () { return this._core.markers; },
        enumerable: true,
        configurable: true
    });
    Terminal.prototype.blur = function () {
        this._core.blur();
    };
    Terminal.prototype.focus = function () {
        this._core.focus();
    };
    Terminal.prototype.on = function (type, listener) {
        this._core.on(type, listener);
    };
    Terminal.prototype.off = function (type, listener) {
        this._core.off(type, listener);
    };
    Terminal.prototype.emit = function (type, data) {
        this._core.emit(type, data);
    };
    Terminal.prototype.addDisposableListener = function (type, handler) {
        return this._core.addDisposableListener(type, handler);
    };
    Terminal.prototype.resize = function (columns, rows) {
        this._core.resize(columns, rows);
    };
    Terminal.prototype.writeln = function (data) {
        this._core.writeln(data);
    };
    Terminal.prototype.open = function (parent) {
        this._core.open(parent);
    };
    Terminal.prototype.attachCustomKeyEventHandler = function (customKeyEventHandler) {
        this._core.attachCustomKeyEventHandler(customKeyEventHandler);
    };
    Terminal.prototype.addCsiHandler = function (flag, callback) {
        return this._core.addCsiHandler(flag, callback);
    };
    Terminal.prototype.addOscHandler = function (ident, callback) {
        return this._core.addOscHandler(ident, callback);
    };
    Terminal.prototype.registerLinkMatcher = function (regex, handler, options) {
        return this._core.registerLinkMatcher(regex, handler, options);
    };
    Terminal.prototype.deregisterLinkMatcher = function (matcherId) {
        this._core.deregisterLinkMatcher(matcherId);
    };
    Terminal.prototype.registerCharacterJoiner = function (handler) {
        return this._core.registerCharacterJoiner(handler);
    };
    Terminal.prototype.deregisterCharacterJoiner = function (joinerId) {
        this._core.deregisterCharacterJoiner(joinerId);
    };
    Terminal.prototype.addMarker = function (cursorYOffset) {
        return this._core.addMarker(cursorYOffset);
    };
    Terminal.prototype.hasSelection = function () {
        return this._core.hasSelection();
    };
    Terminal.prototype.getSelection = function () {
        return this._core.getSelection();
    };
    Terminal.prototype.clearSelection = function () {
        this._core.clearSelection();
    };
    Terminal.prototype.selectAll = function () {
        this._core.selectAll();
    };
    Terminal.prototype.selectLines = function (start, end) {
        this._core.selectLines(start, end);
    };
    Terminal.prototype.dispose = function () {
        this._core.dispose();
    };
    Terminal.prototype.destroy = function () {
        this._core.destroy();
    };
    Terminal.prototype.scrollLines = function (amount) {
        this._core.scrollLines(amount);
    };
    Terminal.prototype.scrollPages = function (pageCount) {
        this._core.scrollPages(pageCount);
    };
    Terminal.prototype.scrollToTop = function () {
        this._core.scrollToTop();
    };
    Terminal.prototype.scrollToBottom = function () {
        this._core.scrollToBottom();
    };
    Terminal.prototype.scrollToLine = function (line) {
        this._core.scrollToLine(line);
    };
    Terminal.prototype.clear = function () {
        this._core.clear();
    };
    Terminal.prototype.write = function (data) {
        this._core.write(data);
    };
    Terminal.prototype.getOption = function (key) {
        return this._core.getOption(key);
    };
    Terminal.prototype.setOption = function (key, value) {
        this._core.setOption(key, value);
    };
    Terminal.prototype.refresh = function (start, end) {
        this._core.refresh(start, end);
    };
    Terminal.prototype.reset = function () {
        this._core.reset();
    };
    Terminal.applyAddon = function (addon) {
        addon.apply(Terminal);
    };
    Object.defineProperty(Terminal, "strings", {
        get: function () {
            return Strings;
        },
        enumerable: true,
        configurable: true
    });
    return Terminal;
}());
exports.Terminal = Terminal;

},{"../Strings":14,"../Terminal":15}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = require("./atlas/Types");
var CharAtlasCache_1 = require("./atlas/CharAtlasCache");
var Buffer_1 = require("../Buffer");
var CharAtlasUtils_1 = require("./atlas/CharAtlasUtils");
var BaseRenderLayer = (function () {
    function BaseRenderLayer(_container, id, zIndex, _alpha, _colors) {
        this._container = _container;
        this._alpha = _alpha;
        this._colors = _colors;
        this._scaledCharWidth = 0;
        this._scaledCharHeight = 0;
        this._scaledCellWidth = 0;
        this._scaledCellHeight = 0;
        this._scaledCharLeft = 0;
        this._scaledCharTop = 0;
        this._currentGlyphIdentifier = {
            chars: '',
            code: 0,
            bg: 0,
            fg: 0,
            bold: false,
            dim: false,
            italic: false
        };
        this._canvas = document.createElement('canvas');
        this._canvas.classList.add("xterm-" + id + "-layer");
        this._canvas.style.zIndex = zIndex.toString();
        this._initCanvas();
        this._container.appendChild(this._canvas);
    }
    BaseRenderLayer.prototype.dispose = function () {
        this._container.removeChild(this._canvas);
        if (this._charAtlas) {
            this._charAtlas.dispose();
        }
    };
    BaseRenderLayer.prototype._initCanvas = function () {
        this._ctx = this._canvas.getContext('2d', { alpha: this._alpha });
        if (!this._alpha) {
            this.clearAll();
        }
    };
    BaseRenderLayer.prototype.onOptionsChanged = function (terminal) { };
    BaseRenderLayer.prototype.onBlur = function (terminal) { };
    BaseRenderLayer.prototype.onFocus = function (terminal) { };
    BaseRenderLayer.prototype.onCursorMove = function (terminal) { };
    BaseRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) { };
    BaseRenderLayer.prototype.onSelectionChanged = function (terminal, start, end, columnSelectMode) {
        if (columnSelectMode === void 0) { columnSelectMode = false; }
    };
    BaseRenderLayer.prototype.onThemeChanged = function (terminal, colorSet) {
        this._refreshCharAtlas(terminal, colorSet);
    };
    BaseRenderLayer.prototype.setTransparency = function (terminal, alpha) {
        if (alpha === this._alpha) {
            return;
        }
        var oldCanvas = this._canvas;
        this._alpha = alpha;
        this._canvas = this._canvas.cloneNode();
        this._initCanvas();
        this._container.replaceChild(this._canvas, oldCanvas);
        this._refreshCharAtlas(terminal, this._colors);
        this.onGridChanged(terminal, 0, terminal.rows - 1);
    };
    BaseRenderLayer.prototype._refreshCharAtlas = function (terminal, colorSet) {
        if (this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0) {
            return;
        }
        this._charAtlas = CharAtlasCache_1.acquireCharAtlas(terminal, colorSet, this._scaledCharWidth, this._scaledCharHeight);
        this._charAtlas.warmUp();
    };
    BaseRenderLayer.prototype.resize = function (terminal, dim) {
        this._scaledCellWidth = dim.scaledCellWidth;
        this._scaledCellHeight = dim.scaledCellHeight;
        this._scaledCharWidth = dim.scaledCharWidth;
        this._scaledCharHeight = dim.scaledCharHeight;
        this._scaledCharLeft = dim.scaledCharLeft;
        this._scaledCharTop = dim.scaledCharTop;
        this._canvas.width = dim.scaledCanvasWidth;
        this._canvas.height = dim.scaledCanvasHeight;
        this._canvas.style.width = dim.canvasWidth + "px";
        this._canvas.style.height = dim.canvasHeight + "px";
        if (!this._alpha) {
            this.clearAll();
        }
        this._refreshCharAtlas(terminal, this._colors);
    };
    BaseRenderLayer.prototype.fillCells = function (x, y, width, height) {
        this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
    };
    BaseRenderLayer.prototype.fillBottomLineAtCells = function (x, y, width) {
        if (width === void 0) { width = 1; }
        this._ctx.fillRect(x * this._scaledCellWidth, (y + 1) * this._scaledCellHeight - window.devicePixelRatio - 1, width * this._scaledCellWidth, window.devicePixelRatio);
    };
    BaseRenderLayer.prototype.fillLeftLineAtCell = function (x, y) {
        this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, window.devicePixelRatio, this._scaledCellHeight);
    };
    BaseRenderLayer.prototype.strokeRectAtCell = function (x, y, width, height) {
        this._ctx.lineWidth = window.devicePixelRatio;
        this._ctx.strokeRect(x * this._scaledCellWidth + window.devicePixelRatio / 2, y * this._scaledCellHeight + (window.devicePixelRatio / 2), width * this._scaledCellWidth - window.devicePixelRatio, (height * this._scaledCellHeight) - window.devicePixelRatio);
    };
    BaseRenderLayer.prototype.clearAll = function () {
        if (this._alpha) {
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        }
        else {
            this._ctx.fillStyle = this._colors.background.css;
            this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
        }
    };
    BaseRenderLayer.prototype.clearCells = function (x, y, width, height) {
        if (this._alpha) {
            this._ctx.clearRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
        }
        else {
            this._ctx.fillStyle = this._colors.background.css;
            this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
        }
    };
    BaseRenderLayer.prototype.fillCharTrueColor = function (terminal, charData, x, y) {
        this._ctx.font = this._getFont(terminal, false, false);
        this._ctx.textBaseline = 'middle';
        this._clipRow(terminal, y);
        this._ctx.fillText(charData[Buffer_1.CHAR_DATA_CHAR_INDEX], x * this._scaledCellWidth + this._scaledCharLeft, (y + 0.5) * this._scaledCellHeight + this._scaledCharTop);
    };
    BaseRenderLayer.prototype.drawChars = function (terminal, chars, code, width, x, y, fg, bg, bold, dim, italic) {
        var drawInBrightColor = terminal.options.drawBoldTextInBrightColors && bold && fg < 8 && fg !== Types_1.INVERTED_DEFAULT_COLOR;
        fg += drawInBrightColor ? 8 : 0;
        this._currentGlyphIdentifier.chars = chars;
        this._currentGlyphIdentifier.code = code;
        this._currentGlyphIdentifier.bg = bg;
        this._currentGlyphIdentifier.fg = fg;
        this._currentGlyphIdentifier.bold = bold && terminal.options.enableBold;
        this._currentGlyphIdentifier.dim = dim;
        this._currentGlyphIdentifier.italic = italic;
        var atlasDidDraw = this._charAtlas && this._charAtlas.draw(this._ctx, this._currentGlyphIdentifier, x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop);
        if (!atlasDidDraw) {
            this._drawUncachedChars(terminal, chars, width, fg, x, y, bold && terminal.options.enableBold, dim, italic);
        }
    };
    BaseRenderLayer.prototype._drawUncachedChars = function (terminal, chars, width, fg, x, y, bold, dim, italic) {
        this._ctx.save();
        this._ctx.font = this._getFont(terminal, bold, italic);
        this._ctx.textBaseline = 'middle';
        if (fg === Types_1.INVERTED_DEFAULT_COLOR) {
            this._ctx.fillStyle = this._colors.background.css;
        }
        else if (CharAtlasUtils_1.is256Color(fg)) {
            this._ctx.fillStyle = this._colors.ansi[fg].css;
        }
        else {
            this._ctx.fillStyle = this._colors.foreground.css;
        }
        this._clipRow(terminal, y);
        if (dim) {
            this._ctx.globalAlpha = Types_1.DIM_OPACITY;
        }
        this._ctx.fillText(chars, x * this._scaledCellWidth + this._scaledCharLeft, (y + 0.5) * this._scaledCellHeight + this._scaledCharTop);
        this._ctx.restore();
    };
    BaseRenderLayer.prototype._clipRow = function (terminal, y) {
        this._ctx.beginPath();
        this._ctx.rect(0, y * this._scaledCellHeight, terminal.cols * this._scaledCellWidth, this._scaledCellHeight);
        this._ctx.clip();
    };
    BaseRenderLayer.prototype._getFont = function (terminal, isBold, isItalic) {
        var fontWeight = isBold ? terminal.options.fontWeightBold : terminal.options.fontWeight;
        var fontStyle = isItalic ? 'italic' : '';
        return fontStyle + " " + fontWeight + " " + terminal.options.fontSize * window.devicePixelRatio + "px " + terminal.options.fontFamily;
    };
    return BaseRenderLayer;
}());
exports.BaseRenderLayer = BaseRenderLayer;

},{"../Buffer":2,"./atlas/CharAtlasCache":39,"./atlas/CharAtlasUtils":41,"./atlas/Types":46}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("../Buffer");
var CharacterJoinerRegistry = (function () {
    function CharacterJoinerRegistry(_terminal) {
        this._terminal = _terminal;
        this._characterJoiners = [];
        this._nextCharacterJoinerId = 0;
    }
    CharacterJoinerRegistry.prototype.registerCharacterJoiner = function (handler) {
        var joiner = {
            id: this._nextCharacterJoinerId++,
            handler: handler
        };
        this._characterJoiners.push(joiner);
        return joiner.id;
    };
    CharacterJoinerRegistry.prototype.deregisterCharacterJoiner = function (joinerId) {
        for (var i = 0; i < this._characterJoiners.length; i++) {
            if (this._characterJoiners[i].id === joinerId) {
                this._characterJoiners.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    CharacterJoinerRegistry.prototype.getJoinedCharacters = function (row) {
        if (this._characterJoiners.length === 0) {
            return [];
        }
        var line = this._terminal.buffer.lines.get(row);
        if (line.length === 0) {
            return [];
        }
        var ranges = [];
        var lineStr = this._terminal.buffer.translateBufferLineToString(row, true);
        var rangeStartColumn = 0;
        var currentStringIndex = 0;
        var rangeStartStringIndex = 0;
        var rangeAttr = line.get(0)[Buffer_1.CHAR_DATA_ATTR_INDEX] >> 9;
        for (var x = 0; x < this._terminal.cols; x++) {
            var charData = line.get(x);
            var chars = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX] >> 9;
            if (width === 0) {
                continue;
            }
            if (attr !== rangeAttr) {
                if (x - rangeStartColumn > 1) {
                    var joinedRanges = this._getJoinedRanges(lineStr, rangeStartStringIndex, currentStringIndex, line, rangeStartColumn);
                    for (var i = 0; i < joinedRanges.length; i++) {
                        ranges.push(joinedRanges[i]);
                    }
                }
                rangeStartColumn = x;
                rangeStartStringIndex = currentStringIndex;
                rangeAttr = attr;
            }
            currentStringIndex += chars.length;
        }
        if (this._terminal.cols - rangeStartColumn > 1) {
            var joinedRanges = this._getJoinedRanges(lineStr, rangeStartStringIndex, currentStringIndex, line, rangeStartColumn);
            for (var i = 0; i < joinedRanges.length; i++) {
                ranges.push(joinedRanges[i]);
            }
        }
        return ranges;
    };
    CharacterJoinerRegistry.prototype._getJoinedRanges = function (line, startIndex, endIndex, lineData, startCol) {
        var text = line.substring(startIndex, endIndex);
        var joinedRanges = this._characterJoiners[0].handler(text);
        for (var i = 1; i < this._characterJoiners.length; i++) {
            var joinerRanges = this._characterJoiners[i].handler(text);
            for (var j = 0; j < joinerRanges.length; j++) {
                CharacterJoinerRegistry._mergeRanges(joinedRanges, joinerRanges[j]);
            }
        }
        this._stringRangesToCellRanges(joinedRanges, lineData, startCol);
        return joinedRanges;
    };
    CharacterJoinerRegistry.prototype._stringRangesToCellRanges = function (ranges, line, startCol) {
        var currentRangeIndex = 0;
        var currentRangeStarted = false;
        var currentStringIndex = 0;
        var currentRange = ranges[currentRangeIndex];
        if (!currentRange) {
            return;
        }
        for (var x = startCol; x < this._terminal.cols; x++) {
            var charData = line.get(x);
            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            var length_1 = charData[Buffer_1.CHAR_DATA_CHAR_INDEX].length;
            if (width === 0) {
                continue;
            }
            if (!currentRangeStarted && currentRange[0] <= currentStringIndex) {
                currentRange[0] = x;
                currentRangeStarted = true;
            }
            if (currentRange[1] <= currentStringIndex) {
                currentRange[1] = x;
                currentRange = ranges[++currentRangeIndex];
                if (!currentRange) {
                    break;
                }
                if (currentRange[0] <= currentStringIndex) {
                    currentRange[0] = x;
                    currentRangeStarted = true;
                }
                else {
                    currentRangeStarted = false;
                }
            }
            currentStringIndex += length_1;
        }
        if (currentRange) {
            currentRange[1] = this._terminal.cols;
        }
    };
    CharacterJoinerRegistry._mergeRanges = function (ranges, newRange) {
        var inRange = false;
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (!inRange) {
                if (newRange[1] <= range[0]) {
                    ranges.splice(i, 0, newRange);
                    return ranges;
                }
                if (newRange[1] <= range[1]) {
                    range[0] = Math.min(newRange[0], range[0]);
                    return ranges;
                }
                if (newRange[0] < range[1]) {
                    range[0] = Math.min(newRange[0], range[0]);
                    inRange = true;
                }
                continue;
            }
            else {
                if (newRange[1] <= range[0]) {
                    ranges[i - 1][1] = newRange[1];
                    return ranges;
                }
                if (newRange[1] <= range[1]) {
                    ranges[i - 1][1] = Math.max(newRange[1], range[1]);
                    ranges.splice(i, 1);
                    inRange = false;
                    return ranges;
                }
                ranges.splice(i, 1);
                i--;
            }
        }
        if (inRange) {
            ranges[ranges.length - 1][1] = newRange[1];
        }
        else {
            ranges.push(newRange);
        }
        return ranges;
    };
    return CharacterJoinerRegistry;
}());
exports.CharacterJoinerRegistry = CharacterJoinerRegistry;

},{"../Buffer":2}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DEFAULT_FOREGROUND = fromHex('#ffffff');
var DEFAULT_BACKGROUND = fromHex('#000000');
var DEFAULT_CURSOR = fromHex('#ffffff');
var DEFAULT_CURSOR_ACCENT = fromHex('#000000');
var DEFAULT_SELECTION = {
    css: 'rgba(255, 255, 255, 0.3)',
    rgba: 0xFFFFFF77
};
exports.DEFAULT_ANSI_COLORS = (function () {
    var colors = [
        fromHex('#2e3436'),
        fromHex('#cc0000'),
        fromHex('#4e9a06'),
        fromHex('#c4a000'),
        fromHex('#3465a4'),
        fromHex('#75507b'),
        fromHex('#06989a'),
        fromHex('#d3d7cf'),
        fromHex('#555753'),
        fromHex('#ef2929'),
        fromHex('#8ae234'),
        fromHex('#fce94f'),
        fromHex('#729fcf'),
        fromHex('#ad7fa8'),
        fromHex('#34e2e2'),
        fromHex('#eeeeec')
    ];
    var v = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff];
    for (var i = 0; i < 216; i++) {
        var r = v[(i / 36) % 6 | 0];
        var g = v[(i / 6) % 6 | 0];
        var b = v[i % 6];
        colors.push({
            css: "#" + toPaddedHex(r) + toPaddedHex(g) + toPaddedHex(b),
            rgba: ((r << 24) | (g << 16) | (b << 8) | 0xFF) >>> 0
        });
    }
    for (var i = 0; i < 24; i++) {
        var c = 8 + i * 10;
        var ch = toPaddedHex(c);
        colors.push({
            css: "#" + ch + ch + ch,
            rgba: ((c << 24) | (c << 16) | (c << 8) | 0xFF) >>> 0
        });
    }
    return colors;
})();
function fromHex(css) {
    return {
        css: css,
        rgba: parseInt(css.slice(1), 16) << 8 | 0xFF
    };
}
function toPaddedHex(c) {
    var s = c.toString(16);
    return s.length < 2 ? '0' + s : s;
}
var ColorManager = (function () {
    function ColorManager(document, allowTransparency) {
        this.allowTransparency = allowTransparency;
        var canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        this._ctx = canvas.getContext('2d');
        this._ctx.globalCompositeOperation = 'copy';
        this._litmusColor = this._ctx.createLinearGradient(0, 0, 1, 1);
        this.colors = {
            foreground: DEFAULT_FOREGROUND,
            background: DEFAULT_BACKGROUND,
            cursor: DEFAULT_CURSOR,
            cursorAccent: DEFAULT_CURSOR_ACCENT,
            selection: DEFAULT_SELECTION,
            ansi: exports.DEFAULT_ANSI_COLORS.slice()
        };
    }
    ColorManager.prototype.setTheme = function (theme) {
        this.colors.foreground = this._parseColor(theme.foreground, DEFAULT_FOREGROUND);
        this.colors.background = this._parseColor(theme.background, DEFAULT_BACKGROUND);
        this.colors.cursor = this._parseColor(theme.cursor, DEFAULT_CURSOR, true);
        this.colors.cursorAccent = this._parseColor(theme.cursorAccent, DEFAULT_CURSOR_ACCENT, true);
        this.colors.selection = this._parseColor(theme.selection, DEFAULT_SELECTION, true);
        this.colors.ansi[0] = this._parseColor(theme.black, exports.DEFAULT_ANSI_COLORS[0]);
        this.colors.ansi[1] = this._parseColor(theme.red, exports.DEFAULT_ANSI_COLORS[1]);
        this.colors.ansi[2] = this._parseColor(theme.green, exports.DEFAULT_ANSI_COLORS[2]);
        this.colors.ansi[3] = this._parseColor(theme.yellow, exports.DEFAULT_ANSI_COLORS[3]);
        this.colors.ansi[4] = this._parseColor(theme.blue, exports.DEFAULT_ANSI_COLORS[4]);
        this.colors.ansi[5] = this._parseColor(theme.magenta, exports.DEFAULT_ANSI_COLORS[5]);
        this.colors.ansi[6] = this._parseColor(theme.cyan, exports.DEFAULT_ANSI_COLORS[6]);
        this.colors.ansi[7] = this._parseColor(theme.white, exports.DEFAULT_ANSI_COLORS[7]);
        this.colors.ansi[8] = this._parseColor(theme.brightBlack, exports.DEFAULT_ANSI_COLORS[8]);
        this.colors.ansi[9] = this._parseColor(theme.brightRed, exports.DEFAULT_ANSI_COLORS[9]);
        this.colors.ansi[10] = this._parseColor(theme.brightGreen, exports.DEFAULT_ANSI_COLORS[10]);
        this.colors.ansi[11] = this._parseColor(theme.brightYellow, exports.DEFAULT_ANSI_COLORS[11]);
        this.colors.ansi[12] = this._parseColor(theme.brightBlue, exports.DEFAULT_ANSI_COLORS[12]);
        this.colors.ansi[13] = this._parseColor(theme.brightMagenta, exports.DEFAULT_ANSI_COLORS[13]);
        this.colors.ansi[14] = this._parseColor(theme.brightCyan, exports.DEFAULT_ANSI_COLORS[14]);
        this.colors.ansi[15] = this._parseColor(theme.brightWhite, exports.DEFAULT_ANSI_COLORS[15]);
    };
    ColorManager.prototype._parseColor = function (css, fallback, allowTransparency) {
        if (allowTransparency === void 0) { allowTransparency = this.allowTransparency; }
        if (!css) {
            return fallback;
        }
        this._ctx.fillStyle = this._litmusColor;
        this._ctx.fillStyle = css;
        if (typeof this._ctx.fillStyle !== 'string') {
            console.warn("Color: " + css + " is invalid using fallback " + fallback.css);
            return fallback;
        }
        this._ctx.fillRect(0, 0, 1, 1);
        var data = this._ctx.getImageData(0, 0, 1, 1).data;
        if (!allowTransparency && data[3] !== 0xFF) {
            console.warn("Color: " + css + " is using transparency, but allowTransparency is false. " +
                ("Using fallback " + fallback.css + "."));
            return fallback;
        }
        return {
            css: css,
            rgba: (data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3]) >>> 0
        };
    };
    return ColorManager;
}());
exports.ColorManager = ColorManager;

},{}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("../Buffer");
var BaseRenderLayer_1 = require("./BaseRenderLayer");
var BLINK_INTERVAL = 600;
var CursorRenderLayer = (function (_super) {
    __extends(CursorRenderLayer, _super);
    function CursorRenderLayer(container, zIndex, colors) {
        var _this = _super.call(this, container, 'cursor', zIndex, true, colors) || this;
        _this._state = {
            x: null,
            y: null,
            isFocused: null,
            style: null,
            width: null
        };
        _this._cursorRenderers = {
            'bar': _this._renderBarCursor.bind(_this),
            'block': _this._renderBlockCursor.bind(_this),
            'underline': _this._renderUnderlineCursor.bind(_this)
        };
        return _this;
    }
    CursorRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        this._state = {
            x: null,
            y: null,
            isFocused: null,
            style: null,
            width: null
        };
    };
    CursorRenderLayer.prototype.reset = function (terminal) {
        this._clearCursor();
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.dispose();
            this._cursorBlinkStateManager = null;
            this.onOptionsChanged(terminal);
        }
    };
    CursorRenderLayer.prototype.onBlur = function (terminal) {
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.pause();
        }
        terminal.refresh(terminal.buffer.y, terminal.buffer.y);
    };
    CursorRenderLayer.prototype.onFocus = function (terminal) {
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.resume(terminal);
        }
        else {
            terminal.refresh(terminal.buffer.y, terminal.buffer.y);
        }
    };
    CursorRenderLayer.prototype.onOptionsChanged = function (terminal) {
        var _this = this;
        if (terminal.options.cursorBlink) {
            if (!this._cursorBlinkStateManager) {
                this._cursorBlinkStateManager = new CursorBlinkStateManager(terminal, function () {
                    _this._render(terminal, true);
                });
            }
        }
        else {
            if (this._cursorBlinkStateManager) {
                this._cursorBlinkStateManager.dispose();
                this._cursorBlinkStateManager = null;
            }
            terminal.refresh(terminal.buffer.y, terminal.buffer.y);
        }
    };
    CursorRenderLayer.prototype.onCursorMove = function (terminal) {
        if (this._cursorBlinkStateManager) {
            this._cursorBlinkStateManager.restartBlinkAnimation(terminal);
        }
    };
    CursorRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) {
        if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused) {
            this._render(terminal, false);
        }
        else {
            this._cursorBlinkStateManager.restartBlinkAnimation(terminal);
        }
    };
    CursorRenderLayer.prototype._render = function (terminal, triggeredByAnimationFrame) {
        if (!terminal.cursorState || terminal.cursorHidden) {
            this._clearCursor();
            return;
        }
        var cursorY = terminal.buffer.ybase + terminal.buffer.y;
        var viewportRelativeCursorY = cursorY - terminal.buffer.ydisp;
        if (viewportRelativeCursorY < 0 || viewportRelativeCursorY >= terminal.rows) {
            this._clearCursor();
            return;
        }
        var charData = terminal.buffer.lines.get(cursorY).get(terminal.buffer.x);
        if (!charData) {
            return;
        }
        if (!terminal.isFocused) {
            this._clearCursor();
            this._ctx.save();
            this._ctx.fillStyle = this._colors.cursor.css;
            this._renderBlurCursor(terminal, terminal.buffer.x, viewportRelativeCursorY, charData);
            this._ctx.restore();
            this._state.x = terminal.buffer.x;
            this._state.y = viewportRelativeCursorY;
            this._state.isFocused = false;
            this._state.style = terminal.options.cursorStyle;
            this._state.width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            return;
        }
        if (this._cursorBlinkStateManager && !this._cursorBlinkStateManager.isCursorVisible) {
            this._clearCursor();
            return;
        }
        if (this._state) {
            if (this._state.x === terminal.buffer.x &&
                this._state.y === viewportRelativeCursorY &&
                this._state.isFocused === terminal.isFocused &&
                this._state.style === terminal.options.cursorStyle &&
                this._state.width === charData[Buffer_1.CHAR_DATA_WIDTH_INDEX]) {
                return;
            }
            this._clearCursor();
        }
        this._ctx.save();
        this._cursorRenderers[terminal.options.cursorStyle || 'block'](terminal, terminal.buffer.x, viewportRelativeCursorY, charData);
        this._ctx.restore();
        this._state.x = terminal.buffer.x;
        this._state.y = viewportRelativeCursorY;
        this._state.isFocused = false;
        this._state.style = terminal.options.cursorStyle;
        this._state.width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
    };
    CursorRenderLayer.prototype._clearCursor = function () {
        if (this._state) {
            this.clearCells(this._state.x, this._state.y, this._state.width, 1);
            this._state = {
                x: null,
                y: null,
                isFocused: null,
                style: null,
                width: null
            };
        }
    };
    CursorRenderLayer.prototype._renderBarCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.fillStyle = this._colors.cursor.css;
        this.fillLeftLineAtCell(x, y);
        this._ctx.restore();
    };
    CursorRenderLayer.prototype._renderBlockCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.fillStyle = this._colors.cursor.css;
        this.fillCells(x, y, charData[Buffer_1.CHAR_DATA_WIDTH_INDEX], 1);
        this._ctx.fillStyle = this._colors.cursorAccent.css;
        this.fillCharTrueColor(terminal, charData, x, y);
        this._ctx.restore();
    };
    CursorRenderLayer.prototype._renderUnderlineCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.fillStyle = this._colors.cursor.css;
        this.fillBottomLineAtCells(x, y);
        this._ctx.restore();
    };
    CursorRenderLayer.prototype._renderBlurCursor = function (terminal, x, y, charData) {
        this._ctx.save();
        this._ctx.strokeStyle = this._colors.cursor.css;
        this.strokeRectAtCell(x, y, charData[Buffer_1.CHAR_DATA_WIDTH_INDEX], 1);
        this._ctx.restore();
    };
    return CursorRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.CursorRenderLayer = CursorRenderLayer;
var CursorBlinkStateManager = (function () {
    function CursorBlinkStateManager(terminal, _renderCallback) {
        this._renderCallback = _renderCallback;
        this.isCursorVisible = true;
        if (terminal.isFocused) {
            this._restartInterval();
        }
    }
    Object.defineProperty(CursorBlinkStateManager.prototype, "isPaused", {
        get: function () { return !(this._blinkStartTimeout || this._blinkInterval); },
        enumerable: true,
        configurable: true
    });
    CursorBlinkStateManager.prototype.dispose = function () {
        if (this._blinkInterval) {
            window.clearInterval(this._blinkInterval);
            this._blinkInterval = null;
        }
        if (this._blinkStartTimeout) {
            window.clearTimeout(this._blinkStartTimeout);
            this._blinkStartTimeout = null;
        }
        if (this._animationFrame) {
            window.cancelAnimationFrame(this._animationFrame);
            this._animationFrame = null;
        }
    };
    CursorBlinkStateManager.prototype.restartBlinkAnimation = function (terminal) {
        var _this = this;
        if (this.isPaused) {
            return;
        }
        this._animationTimeRestarted = Date.now();
        this.isCursorVisible = true;
        if (!this._animationFrame) {
            this._animationFrame = window.requestAnimationFrame(function () {
                _this._renderCallback();
                _this._animationFrame = null;
            });
        }
    };
    CursorBlinkStateManager.prototype._restartInterval = function (timeToStart) {
        var _this = this;
        if (timeToStart === void 0) { timeToStart = BLINK_INTERVAL; }
        if (this._blinkInterval) {
            window.clearInterval(this._blinkInterval);
        }
        this._blinkStartTimeout = setTimeout(function () {
            if (_this._animationTimeRestarted) {
                var time = BLINK_INTERVAL - (Date.now() - _this._animationTimeRestarted);
                _this._animationTimeRestarted = null;
                if (time > 0) {
                    _this._restartInterval(time);
                    return;
                }
            }
            _this.isCursorVisible = false;
            _this._animationFrame = window.requestAnimationFrame(function () {
                _this._renderCallback();
                _this._animationFrame = null;
            });
            _this._blinkInterval = setInterval(function () {
                if (_this._animationTimeRestarted) {
                    var time = BLINK_INTERVAL - (Date.now() - _this._animationTimeRestarted);
                    _this._animationTimeRestarted = null;
                    _this._restartInterval(time);
                    return;
                }
                _this.isCursorVisible = !_this.isCursorVisible;
                _this._animationFrame = window.requestAnimationFrame(function () {
                    _this._renderCallback();
                    _this._animationFrame = null;
                });
            }, BLINK_INTERVAL);
        }, timeToStart);
    };
    CursorBlinkStateManager.prototype.pause = function () {
        this.isCursorVisible = true;
        if (this._blinkInterval) {
            window.clearInterval(this._blinkInterval);
            this._blinkInterval = null;
        }
        if (this._blinkStartTimeout) {
            window.clearTimeout(this._blinkStartTimeout);
            this._blinkStartTimeout = null;
        }
        if (this._animationFrame) {
            window.cancelAnimationFrame(this._animationFrame);
            this._animationFrame = null;
        }
    };
    CursorBlinkStateManager.prototype.resume = function (terminal) {
        this._animationTimeRestarted = null;
        this._restartInterval();
        this.restartBlinkAnimation(terminal);
    };
    return CursorBlinkStateManager;
}());

},{"../Buffer":2,"./BaseRenderLayer":29}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GridCache = (function () {
    function GridCache() {
        this.cache = [];
    }
    GridCache.prototype.resize = function (width, height) {
        for (var x = 0; x < width; x++) {
            if (this.cache.length <= x) {
                this.cache.push([]);
            }
            for (var y = this.cache[x].length; y < height; y++) {
                this.cache[x].push(null);
            }
            this.cache[x].length = height;
        }
        this.cache.length = width;
    };
    GridCache.prototype.clear = function () {
        for (var x = 0; x < this.cache.length; x++) {
            for (var y = 0; y < this.cache[x].length; y++) {
                this.cache[x][y] = null;
            }
        }
    };
    return GridCache;
}());
exports.GridCache = GridCache;

},{}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseRenderLayer_1 = require("./BaseRenderLayer");
var Types_1 = require("./atlas/Types");
var CharAtlasUtils_1 = require("./atlas/CharAtlasUtils");
var LinkRenderLayer = (function (_super) {
    __extends(LinkRenderLayer, _super);
    function LinkRenderLayer(container, zIndex, colors, terminal) {
        var _this = _super.call(this, container, 'link', zIndex, true, colors) || this;
        _this._state = null;
        terminal.linkifier.on("linkhover", function (e) { return _this._onLinkHover(e); });
        terminal.linkifier.on("linkleave", function (e) { return _this._onLinkLeave(e); });
        return _this;
    }
    LinkRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        this._state = null;
    };
    LinkRenderLayer.prototype.reset = function (terminal) {
        this._clearCurrentLink();
    };
    LinkRenderLayer.prototype._clearCurrentLink = function () {
        if (this._state) {
            this.clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);
            var middleRowCount = this._state.y2 - this._state.y1 - 1;
            if (middleRowCount > 0) {
                this.clearCells(0, this._state.y1 + 1, this._state.cols, middleRowCount);
            }
            this.clearCells(0, this._state.y2, this._state.x2, 1);
            this._state = null;
        }
    };
    LinkRenderLayer.prototype._onLinkHover = function (e) {
        if (e.fg === Types_1.INVERTED_DEFAULT_COLOR) {
            this._ctx.fillStyle = this._colors.background.css;
        }
        else if (CharAtlasUtils_1.is256Color(e.fg)) {
            this._ctx.fillStyle = this._colors.ansi[e.fg].css;
        }
        else {
            this._ctx.fillStyle = this._colors.foreground.css;
        }
        if (e.y1 === e.y2) {
            this.fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);
        }
        else {
            this.fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);
            for (var y = e.y1 + 1; y < e.y2; y++) {
                this.fillBottomLineAtCells(0, y, e.cols);
            }
            this.fillBottomLineAtCells(0, e.y2, e.x2);
        }
        this._state = e;
    };
    LinkRenderLayer.prototype._onLinkLeave = function (e) {
        this._clearCurrentLink();
    };
    return LinkRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.LinkRenderLayer = LinkRenderLayer;

},{"./BaseRenderLayer":29,"./atlas/CharAtlasUtils":41,"./atlas/Types":46}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TextRenderLayer_1 = require("./TextRenderLayer");
var SelectionRenderLayer_1 = require("./SelectionRenderLayer");
var CursorRenderLayer_1 = require("./CursorRenderLayer");
var ColorManager_1 = require("./ColorManager");
var LinkRenderLayer_1 = require("./LinkRenderLayer");
var EventEmitter_1 = require("../common/EventEmitter");
var RenderDebouncer_1 = require("../ui/RenderDebouncer");
var ScreenDprMonitor_1 = require("../ui/ScreenDprMonitor");
var CharacterJoinerRegistry_1 = require("../renderer/CharacterJoinerRegistry");
var Renderer = (function (_super) {
    __extends(Renderer, _super);
    function Renderer(_terminal, theme) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._isPaused = false;
        _this._needsFullRefresh = false;
        var allowTransparency = _this._terminal.options.allowTransparency;
        _this.colorManager = new ColorManager_1.ColorManager(document, allowTransparency);
        _this._characterJoinerRegistry = new CharacterJoinerRegistry_1.CharacterJoinerRegistry(_terminal);
        if (theme) {
            _this.colorManager.setTheme(theme);
        }
        _this._renderLayers = [
            new TextRenderLayer_1.TextRenderLayer(_this._terminal.screenElement, 0, _this.colorManager.colors, _this._characterJoinerRegistry, allowTransparency),
            new SelectionRenderLayer_1.SelectionRenderLayer(_this._terminal.screenElement, 1, _this.colorManager.colors),
            new LinkRenderLayer_1.LinkRenderLayer(_this._terminal.screenElement, 2, _this.colorManager.colors, _this._terminal),
            new CursorRenderLayer_1.CursorRenderLayer(_this._terminal.screenElement, 3, _this.colorManager.colors)
        ];
        _this.dimensions = {
            scaledCharWidth: null,
            scaledCharHeight: null,
            scaledCellWidth: null,
            scaledCellHeight: null,
            scaledCharLeft: null,
            scaledCharTop: null,
            scaledCanvasWidth: null,
            scaledCanvasHeight: null,
            canvasWidth: null,
            canvasHeight: null,
            actualCellWidth: null,
            actualCellHeight: null
        };
        _this._devicePixelRatio = window.devicePixelRatio;
        _this._updateDimensions();
        _this.onOptionsChanged();
        _this._renderDebouncer = new RenderDebouncer_1.RenderDebouncer(_this._terminal, _this._renderRows.bind(_this));
        _this._screenDprMonitor = new ScreenDprMonitor_1.ScreenDprMonitor();
        _this._screenDprMonitor.setListener(function () { return _this.onWindowResize(window.devicePixelRatio); });
        _this.register(_this._screenDprMonitor);
        if ('IntersectionObserver' in window) {
            var observer_1 = new IntersectionObserver(function (e) { return _this.onIntersectionChange(e[0]); }, { threshold: 0 });
            observer_1.observe(_this._terminal.element);
            _this.register({ dispose: function () { return observer_1.disconnect(); } });
        }
        return _this;
    }
    Renderer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._renderLayers.forEach(function (l) { return l.dispose(); });
    };
    Renderer.prototype.onIntersectionChange = function (entry) {
        this._isPaused = entry.intersectionRatio === 0;
        if (!this._isPaused && this._needsFullRefresh) {
            this._terminal.refresh(0, this._terminal.rows - 1);
        }
    };
    Renderer.prototype.onWindowResize = function (devicePixelRatio) {
        if (this._devicePixelRatio !== devicePixelRatio) {
            this._devicePixelRatio = devicePixelRatio;
            this.onResize(this._terminal.cols, this._terminal.rows);
        }
    };
    Renderer.prototype.setTheme = function (theme) {
        var _this = this;
        this.colorManager.setTheme(theme);
        this._renderLayers.forEach(function (l) {
            l.onThemeChanged(_this._terminal, _this.colorManager.colors);
            l.reset(_this._terminal);
        });
        if (this._isPaused) {
            this._needsFullRefresh = true;
        }
        else {
            this._terminal.refresh(0, this._terminal.rows - 1);
        }
        return this.colorManager.colors;
    };
    Renderer.prototype.onResize = function (cols, rows) {
        var _this = this;
        this._updateDimensions();
        this._renderLayers.forEach(function (l) { return l.resize(_this._terminal, _this.dimensions); });
        if (this._isPaused) {
            this._needsFullRefresh = true;
        }
        else {
            this._terminal.refresh(0, this._terminal.rows - 1);
        }
        this._terminal.screenElement.style.width = this.dimensions.canvasWidth + "px";
        this._terminal.screenElement.style.height = this.dimensions.canvasHeight + "px";
        this.emit('resize', {
            width: this.dimensions.canvasWidth,
            height: this.dimensions.canvasHeight
        });
    };
    Renderer.prototype.onCharSizeChanged = function () {
        this.onResize(this._terminal.cols, this._terminal.rows);
    };
    Renderer.prototype.onBlur = function () {
        var _this = this;
        this._runOperation(function (l) { return l.onBlur(_this._terminal); });
    };
    Renderer.prototype.onFocus = function () {
        var _this = this;
        this._runOperation(function (l) { return l.onFocus(_this._terminal); });
    };
    Renderer.prototype.onSelectionChanged = function (start, end, columnSelectMode) {
        var _this = this;
        if (columnSelectMode === void 0) { columnSelectMode = false; }
        this._runOperation(function (l) { return l.onSelectionChanged(_this._terminal, start, end, columnSelectMode); });
    };
    Renderer.prototype.onCursorMove = function () {
        var _this = this;
        this._runOperation(function (l) { return l.onCursorMove(_this._terminal); });
    };
    Renderer.prototype.onOptionsChanged = function () {
        var _this = this;
        this.colorManager.allowTransparency = this._terminal.options.allowTransparency;
        this._runOperation(function (l) { return l.onOptionsChanged(_this._terminal); });
    };
    Renderer.prototype.clear = function () {
        var _this = this;
        this._runOperation(function (l) { return l.reset(_this._terminal); });
    };
    Renderer.prototype._runOperation = function (operation) {
        if (this._isPaused) {
            this._needsFullRefresh = true;
        }
        else {
            this._renderLayers.forEach(function (l) { return operation(l); });
        }
    };
    Renderer.prototype.refreshRows = function (start, end) {
        if (this._isPaused) {
            this._needsFullRefresh = true;
            return;
        }
        this._renderDebouncer.refresh(start, end);
    };
    Renderer.prototype._renderRows = function (start, end) {
        var _this = this;
        this._renderLayers.forEach(function (l) { return l.onGridChanged(_this._terminal, start, end); });
        this._terminal.emit('refresh', { start: start, end: end });
    };
    Renderer.prototype._updateDimensions = function () {
        if (!this._terminal.charMeasure.width || !this._terminal.charMeasure.height) {
            return;
        }
        this.dimensions.scaledCharWidth = Math.floor(this._terminal.charMeasure.width * window.devicePixelRatio);
        this.dimensions.scaledCharHeight = Math.ceil(this._terminal.charMeasure.height * window.devicePixelRatio);
        this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.options.lineHeight);
        this.dimensions.scaledCharTop = this._terminal.options.lineHeight === 1 ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2);
        this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.options.letterSpacing);
        this.dimensions.scaledCharLeft = Math.floor(this._terminal.options.letterSpacing / 2);
        this.dimensions.scaledCanvasHeight = this._terminal.rows * this.dimensions.scaledCellHeight;
        this.dimensions.scaledCanvasWidth = this._terminal.cols * this.dimensions.scaledCellWidth;
        this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / window.devicePixelRatio);
        this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / window.devicePixelRatio);
        this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;
        this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;
    };
    Renderer.prototype.registerCharacterJoiner = function (handler) {
        return this._characterJoinerRegistry.registerCharacterJoiner(handler);
    };
    Renderer.prototype.deregisterCharacterJoiner = function (joinerId) {
        return this._characterJoinerRegistry.deregisterCharacterJoiner(joinerId);
    };
    return Renderer;
}(EventEmitter_1.EventEmitter));
exports.Renderer = Renderer;

},{"../common/EventEmitter":19,"../renderer/CharacterJoinerRegistry":30,"../ui/RenderDebouncer":54,"../ui/ScreenDprMonitor":55,"./ColorManager":31,"./CursorRenderLayer":32,"./LinkRenderLayer":34,"./SelectionRenderLayer":36,"./TextRenderLayer":37}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseRenderLayer_1 = require("./BaseRenderLayer");
var SelectionRenderLayer = (function (_super) {
    __extends(SelectionRenderLayer, _super);
    function SelectionRenderLayer(container, zIndex, colors) {
        var _this = _super.call(this, container, 'selection', zIndex, true, colors) || this;
        _this._clearState();
        return _this;
    }
    SelectionRenderLayer.prototype._clearState = function () {
        this._state = {
            start: null,
            end: null,
            columnSelectMode: null,
            ydisp: null
        };
    };
    SelectionRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        this._clearState();
    };
    SelectionRenderLayer.prototype.reset = function (terminal) {
        if (this._state.start && this._state.end) {
            this._clearState();
            this.clearAll();
        }
    };
    SelectionRenderLayer.prototype.onSelectionChanged = function (terminal, start, end, columnSelectMode) {
        if (!this._didStateChange(start, end, columnSelectMode, terminal.buffer.ydisp)) {
            return;
        }
        this.clearAll();
        if (!start || !end) {
            return;
        }
        var viewportStartRow = start[1] - terminal.buffer.ydisp;
        var viewportEndRow = end[1] - terminal.buffer.ydisp;
        var viewportCappedStartRow = Math.max(viewportStartRow, 0);
        var viewportCappedEndRow = Math.min(viewportEndRow, terminal.rows - 1);
        if (viewportCappedStartRow >= terminal.rows || viewportCappedEndRow < 0) {
            return;
        }
        this._ctx.fillStyle = this._colors.selection.css;
        if (columnSelectMode) {
            var startCol = start[0];
            var width = end[0] - startCol;
            var height = viewportCappedEndRow - viewportCappedStartRow + 1;
            this.fillCells(startCol, viewportCappedStartRow, width, height);
        }
        else {
            var startCol = viewportStartRow === viewportCappedStartRow ? start[0] : 0;
            var startRowEndCol = viewportCappedStartRow === viewportCappedEndRow ? end[0] : terminal.cols;
            this.fillCells(startCol, viewportCappedStartRow, startRowEndCol - startCol, 1);
            var middleRowsCount = Math.max(viewportCappedEndRow - viewportCappedStartRow - 1, 0);
            this.fillCells(0, viewportCappedStartRow + 1, terminal.cols, middleRowsCount);
            if (viewportCappedStartRow !== viewportCappedEndRow) {
                var endCol = viewportEndRow === viewportCappedEndRow ? end[0] : terminal.cols;
                this.fillCells(0, viewportCappedEndRow, endCol, 1);
            }
        }
        this._state.start = [start[0], start[1]];
        this._state.end = [end[0], end[1]];
        this._state.columnSelectMode = columnSelectMode;
        this._state.ydisp = terminal.buffer.ydisp;
    };
    SelectionRenderLayer.prototype._didStateChange = function (start, end, columnSelectMode, ydisp) {
        return !this._areCoordinatesEqual(start, this._state.start) ||
            !this._areCoordinatesEqual(end, this._state.end) ||
            columnSelectMode !== this._state.columnSelectMode ||
            ydisp !== this._state.ydisp;
    };
    SelectionRenderLayer.prototype._areCoordinatesEqual = function (coord1, coord2) {
        if (!coord1 || !coord2) {
            return false;
        }
        return coord1[0] === coord2[0] && coord1[1] === coord2[1];
    };
    return SelectionRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.SelectionRenderLayer = SelectionRenderLayer;

},{"./BaseRenderLayer":29}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("../Buffer");
var Types_1 = require("./atlas/Types");
var GridCache_1 = require("./GridCache");
var BaseRenderLayer_1 = require("./BaseRenderLayer");
var CharAtlasUtils_1 = require("./atlas/CharAtlasUtils");
var TextRenderLayer = (function (_super) {
    __extends(TextRenderLayer, _super);
    function TextRenderLayer(container, zIndex, colors, characterJoinerRegistry, alpha) {
        var _this = _super.call(this, container, 'text', zIndex, alpha, colors) || this;
        _this._characterOverlapCache = {};
        _this._state = new GridCache_1.GridCache();
        _this._characterJoinerRegistry = characterJoinerRegistry;
        return _this;
    }
    TextRenderLayer.prototype.resize = function (terminal, dim) {
        _super.prototype.resize.call(this, terminal, dim);
        var terminalFont = this._getFont(terminal, false, false);
        if (this._characterWidth !== dim.scaledCharWidth || this._characterFont !== terminalFont) {
            this._characterWidth = dim.scaledCharWidth;
            this._characterFont = terminalFont;
            this._characterOverlapCache = {};
        }
        this._state.clear();
        this._state.resize(terminal.cols, terminal.rows);
    };
    TextRenderLayer.prototype.reset = function (terminal) {
        this._state.clear();
        this.clearAll();
    };
    TextRenderLayer.prototype._forEachCell = function (terminal, firstRow, lastRow, joinerRegistry, callback) {
        for (var y = firstRow; y <= lastRow; y++) {
            var row = y + terminal.buffer.ydisp;
            var line = terminal.buffer.lines.get(row);
            var joinedRanges = joinerRegistry ? joinerRegistry.getJoinedCharacters(row) : [];
            for (var x = 0; x < terminal.cols; x++) {
                var charData = line.get(x);
                var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX] || Buffer_1.WHITESPACE_CELL_CODE;
                var chars = charData[Buffer_1.CHAR_DATA_CHAR_INDEX] || Buffer_1.WHITESPACE_CELL_CHAR;
                var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX];
                var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
                var isJoined = false;
                var lastCharX = x;
                if (width === 0) {
                    continue;
                }
                if (joinedRanges.length > 0 && x === joinedRanges[0][0]) {
                    isJoined = true;
                    var range = joinedRanges.shift();
                    chars = terminal.buffer.translateBufferLineToString(row, true, range[0], range[1]);
                    width = range[1] - range[0];
                    code = Infinity;
                    lastCharX = range[1] - 1;
                }
                if (!isJoined && this._isOverlapping(charData)) {
                    if (lastCharX < line.length - 1 && line.get(lastCharX + 1)[Buffer_1.CHAR_DATA_CODE_INDEX] === Buffer_1.NULL_CELL_CODE) {
                        width = 2;
                    }
                }
                var flags = attr >> 18;
                var bg = attr & 0x1ff;
                var fg = (attr >> 9) & 0x1ff;
                if (flags & 8) {
                    var temp = bg;
                    bg = fg;
                    fg = temp;
                    if (fg === Types_1.DEFAULT_COLOR) {
                        fg = Types_1.INVERTED_DEFAULT_COLOR;
                    }
                    if (bg === Types_1.DEFAULT_COLOR) {
                        bg = Types_1.INVERTED_DEFAULT_COLOR;
                    }
                }
                callback(code, chars, width, x, y, fg, bg, flags);
                x = lastCharX;
            }
        }
    };
    TextRenderLayer.prototype._drawBackground = function (terminal, firstRow, lastRow) {
        var _this = this;
        var ctx = this._ctx;
        var cols = terminal.cols;
        var startX = 0;
        var startY = 0;
        var prevFillStyle = null;
        ctx.save();
        this._forEachCell(terminal, firstRow, lastRow, null, function (code, chars, width, x, y, fg, bg, flags) {
            var nextFillStyle = null;
            if (bg === Types_1.INVERTED_DEFAULT_COLOR) {
                nextFillStyle = _this._colors.foreground.css;
            }
            else if (CharAtlasUtils_1.is256Color(bg)) {
                nextFillStyle = _this._colors.ansi[bg].css;
            }
            if (prevFillStyle === null) {
                startX = x;
                startY = y;
            }
            if (y !== startY) {
                ctx.fillStyle = prevFillStyle;
                _this.fillCells(startX, startY, cols - startX, 1);
                startX = x;
                startY = y;
            }
            else if (prevFillStyle !== nextFillStyle) {
                ctx.fillStyle = prevFillStyle;
                _this.fillCells(startX, startY, x - startX, 1);
                startX = x;
                startY = y;
            }
            prevFillStyle = nextFillStyle;
        });
        if (prevFillStyle !== null) {
            ctx.fillStyle = prevFillStyle;
            this.fillCells(startX, startY, cols - startX, 1);
        }
        ctx.restore();
    };
    TextRenderLayer.prototype._drawForeground = function (terminal, firstRow, lastRow) {
        var _this = this;
        this._forEachCell(terminal, firstRow, lastRow, this._characterJoinerRegistry, function (code, chars, width, x, y, fg, bg, flags) {
            if (flags & 16) {
                return;
            }
            if (flags & 2) {
                _this._ctx.save();
                if (fg === Types_1.INVERTED_DEFAULT_COLOR) {
                    _this._ctx.fillStyle = _this._colors.background.css;
                }
                else if (CharAtlasUtils_1.is256Color(fg)) {
                    _this._ctx.fillStyle = _this._colors.ansi[fg].css;
                }
                else {
                    _this._ctx.fillStyle = _this._colors.foreground.css;
                }
                _this.fillBottomLineAtCells(x, y, width);
                _this._ctx.restore();
            }
            _this.drawChars(terminal, chars, code, width, x, y, fg, bg, !!(flags & 1), !!(flags & 32), !!(flags & 64));
        });
    };
    TextRenderLayer.prototype.onGridChanged = function (terminal, firstRow, lastRow) {
        if (this._state.cache.length === 0) {
            return;
        }
        if (this._charAtlas) {
            this._charAtlas.beginFrame();
        }
        this.clearCells(0, firstRow, terminal.cols, lastRow - firstRow + 1);
        this._drawBackground(terminal, firstRow, lastRow);
        this._drawForeground(terminal, firstRow, lastRow);
    };
    TextRenderLayer.prototype.onOptionsChanged = function (terminal) {
        this.setTransparency(terminal, terminal.options.allowTransparency);
    };
    TextRenderLayer.prototype._isOverlapping = function (charData) {
        if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] !== 1) {
            return false;
        }
        var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];
        if (code < 256) {
            return false;
        }
        var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
        if (this._characterOverlapCache.hasOwnProperty(char)) {
            return this._characterOverlapCache[char];
        }
        this._ctx.save();
        this._ctx.font = this._characterFont;
        var overlaps = Math.floor(this._ctx.measureText(char).width) > this._characterWidth;
        this._ctx.restore();
        this._characterOverlapCache[char] = overlaps;
        return overlaps;
    };
    return TextRenderLayer;
}(BaseRenderLayer_1.BaseRenderLayer));
exports.TextRenderLayer = TextRenderLayer;

},{"../Buffer":2,"./BaseRenderLayer":29,"./GridCache":33,"./atlas/CharAtlasUtils":41,"./atlas/Types":46}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BaseCharAtlas = (function () {
    function BaseCharAtlas() {
        this._didWarmUp = false;
    }
    BaseCharAtlas.prototype.dispose = function () { };
    BaseCharAtlas.prototype.warmUp = function () {
        if (!this._didWarmUp) {
            this._doWarmUp();
            this._didWarmUp = true;
        }
    };
    BaseCharAtlas.prototype._doWarmUp = function () { };
    BaseCharAtlas.prototype.beginFrame = function () { };
    return BaseCharAtlas;
}());
exports.default = BaseCharAtlas;

},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CharAtlasUtils_1 = require("./CharAtlasUtils");
var DynamicCharAtlas_1 = require("./DynamicCharAtlas");
var NoneCharAtlas_1 = require("./NoneCharAtlas");
var StaticCharAtlas_1 = require("./StaticCharAtlas");
var charAtlasImplementations = {
    'none': NoneCharAtlas_1.default,
    'static': StaticCharAtlas_1.default,
    'dynamic': DynamicCharAtlas_1.default
};
var charAtlasCache = [];
function acquireCharAtlas(terminal, colors, scaledCharWidth, scaledCharHeight) {
    var newConfig = CharAtlasUtils_1.generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors);
    for (var i = 0; i < charAtlasCache.length; i++) {
        var entry = charAtlasCache[i];
        var ownedByIndex = entry.ownedBy.indexOf(terminal);
        if (ownedByIndex >= 0) {
            if (CharAtlasUtils_1.configEquals(entry.config, newConfig)) {
                return entry.atlas;
            }
            if (entry.ownedBy.length === 1) {
                entry.atlas.dispose();
                charAtlasCache.splice(i, 1);
            }
            else {
                entry.ownedBy.splice(ownedByIndex, 1);
            }
            break;
        }
    }
    for (var i = 0; i < charAtlasCache.length; i++) {
        var entry = charAtlasCache[i];
        if (CharAtlasUtils_1.configEquals(entry.config, newConfig)) {
            entry.ownedBy.push(terminal);
            return entry.atlas;
        }
    }
    var newEntry = {
        atlas: new charAtlasImplementations[terminal.options.experimentalCharAtlas](document, newConfig),
        config: newConfig,
        ownedBy: [terminal]
    };
    charAtlasCache.push(newEntry);
    return newEntry.atlas;
}
exports.acquireCharAtlas = acquireCharAtlas;
function removeTerminalFromCache(terminal) {
    for (var i = 0; i < charAtlasCache.length; i++) {
        var index = charAtlasCache[i].ownedBy.indexOf(terminal);
        if (index !== -1) {
            if (charAtlasCache[i].ownedBy.length === 1) {
                charAtlasCache[i].atlas.dispose();
                charAtlasCache.splice(i, 1);
            }
            else {
                charAtlasCache[i].ownedBy.splice(index, 1);
            }
            break;
        }
    }
}
exports.removeTerminalFromCache = removeTerminalFromCache;

},{"./CharAtlasUtils":41,"./DynamicCharAtlas":42,"./NoneCharAtlas":44,"./StaticCharAtlas":45}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Platform_1 = require("../../core/Platform");
var Types_1 = require("./Types");
function generateStaticCharAtlasTexture(context, canvasFactory, config) {
    var cellWidth = config.scaledCharWidth + Types_1.CHAR_ATLAS_CELL_SPACING;
    var cellHeight = config.scaledCharHeight + Types_1.CHAR_ATLAS_CELL_SPACING;
    var canvas = canvasFactory(255 * cellWidth, (2 + 16 + 16) * cellHeight);
    var ctx = canvas.getContext('2d', { alpha: config.allowTransparency });
    ctx.fillStyle = config.colors.background.css;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.fillStyle = config.colors.foreground.css;
    ctx.font = getFont(config.fontWeight, config);
    ctx.textBaseline = 'middle';
    for (var i = 0; i < 256; i++) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(i * cellWidth, 0, cellWidth, cellHeight);
        ctx.clip();
        ctx.fillText(String.fromCharCode(i), i * cellWidth, cellHeight / 2);
        ctx.restore();
    }
    ctx.save();
    ctx.font = getFont(config.fontWeightBold, config);
    for (var i = 0; i < 256; i++) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(i * cellWidth, cellHeight, cellWidth, cellHeight);
        ctx.clip();
        ctx.fillText(String.fromCharCode(i), i * cellWidth, cellHeight * 1.5);
        ctx.restore();
    }
    ctx.restore();
    ctx.font = getFont(config.fontWeight, config);
    for (var colorIndex = 0; colorIndex < 16; colorIndex++) {
        var y = (colorIndex + 2) * cellHeight;
        for (var i = 0; i < 256; i++) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(i * cellWidth, y, cellWidth, cellHeight);
            ctx.clip();
            ctx.fillStyle = config.colors.ansi[colorIndex].css;
            ctx.fillText(String.fromCharCode(i), i * cellWidth, y + cellHeight / 2);
            ctx.restore();
        }
    }
    ctx.font = getFont(config.fontWeightBold, config);
    for (var colorIndex = 0; colorIndex < 16; colorIndex++) {
        var y = (colorIndex + 2 + 16) * cellHeight;
        for (var i = 0; i < 256; i++) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(i * cellWidth, y, cellWidth, cellHeight);
            ctx.clip();
            ctx.fillStyle = config.colors.ansi[colorIndex].css;
            ctx.fillText(String.fromCharCode(i), i * cellWidth, y + cellHeight / 2);
            ctx.restore();
        }
    }
    ctx.restore();
    if (!('createImageBitmap' in context) || Platform_1.isFirefox || Platform_1.isSafari) {
        return canvas;
    }
    var charAtlasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    clearColor(charAtlasImageData, config.colors.background);
    return context.createImageBitmap(charAtlasImageData);
}
exports.generateStaticCharAtlasTexture = generateStaticCharAtlasTexture;
function clearColor(imageData, color) {
    var isEmpty = true;
    var r = color.rgba >>> 24;
    var g = color.rgba >>> 16 & 0xFF;
    var b = color.rgba >>> 8 & 0xFF;
    for (var offset = 0; offset < imageData.data.length; offset += 4) {
        if (imageData.data[offset] === r &&
            imageData.data[offset + 1] === g &&
            imageData.data[offset + 2] === b) {
            imageData.data[offset + 3] = 0;
        }
        else {
            isEmpty = false;
        }
    }
    return isEmpty;
}
exports.clearColor = clearColor;
function getFont(fontWeight, config) {
    return fontWeight + " " + config.fontSize * config.devicePixelRatio + "px " + config.fontFamily;
}

},{"../../core/Platform":23,"./Types":46}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = require("./Types");
function generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors) {
    var clonedColors = {
        foreground: colors.foreground,
        background: colors.background,
        cursor: null,
        cursorAccent: null,
        selection: null,
        ansi: colors.ansi.slice(0, 16)
    };
    return {
        type: terminal.options.experimentalCharAtlas,
        devicePixelRatio: window.devicePixelRatio,
        scaledCharWidth: scaledCharWidth,
        scaledCharHeight: scaledCharHeight,
        fontFamily: terminal.options.fontFamily,
        fontSize: terminal.options.fontSize,
        fontWeight: terminal.options.fontWeight,
        fontWeightBold: terminal.options.fontWeightBold,
        allowTransparency: terminal.options.allowTransparency,
        colors: clonedColors
    };
}
exports.generateConfig = generateConfig;
function configEquals(a, b) {
    for (var i = 0; i < a.colors.ansi.length; i++) {
        if (a.colors.ansi[i].rgba !== b.colors.ansi[i].rgba) {
            return false;
        }
    }
    return a.type === b.type &&
        a.devicePixelRatio === b.devicePixelRatio &&
        a.fontFamily === b.fontFamily &&
        a.fontSize === b.fontSize &&
        a.fontWeight === b.fontWeight &&
        a.fontWeightBold === b.fontWeightBold &&
        a.allowTransparency === b.allowTransparency &&
        a.scaledCharWidth === b.scaledCharWidth &&
        a.scaledCharHeight === b.scaledCharHeight &&
        a.colors.foreground === b.colors.foreground &&
        a.colors.background === b.colors.background;
}
exports.configEquals = configEquals;
function is256Color(colorCode) {
    return colorCode < Types_1.DEFAULT_COLOR;
}
exports.is256Color = is256Color;

},{"./Types":46}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = require("./Types");
var BaseCharAtlas_1 = require("./BaseCharAtlas");
var ColorManager_1 = require("../ColorManager");
var CharAtlasGenerator_1 = require("./CharAtlasGenerator");
var LRUMap_1 = require("./LRUMap");
var Platform_1 = require("../../core/Platform");
var TEXTURE_WIDTH = 1024;
var TEXTURE_HEIGHT = 1024;
var TRANSPARENT_COLOR = {
    css: 'rgba(0, 0, 0, 0)',
    rgba: 0
};
var FRAME_CACHE_DRAW_LIMIT = 100;
var GLYPH_BITMAP_COMMIT_DELAY = 100;
function getGlyphCacheKey(glyph) {
    return glyph.code << 21 | glyph.bg << 12 | glyph.fg << 3 | (glyph.bold ? 0 : 4) + (glyph.dim ? 0 : 2) + (glyph.italic ? 0 : 1);
}
exports.getGlyphCacheKey = getGlyphCacheKey;
var DynamicCharAtlas = (function (_super) {
    __extends(DynamicCharAtlas, _super);
    function DynamicCharAtlas(document, _config) {
        var _this = _super.call(this) || this;
        _this._config = _config;
        _this._drawToCacheCount = 0;
        _this._glyphsWaitingOnBitmap = [];
        _this._bitmapCommitTimeout = null;
        _this._bitmap = null;
        _this._cacheCanvas = document.createElement('canvas');
        _this._cacheCanvas.width = TEXTURE_WIDTH;
        _this._cacheCanvas.height = TEXTURE_HEIGHT;
        _this._cacheCtx = _this._cacheCanvas.getContext('2d', { alpha: true });
        var tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = _this._config.scaledCharWidth;
        tmpCanvas.height = _this._config.scaledCharHeight;
        _this._tmpCtx = tmpCanvas.getContext('2d', { alpha: _this._config.allowTransparency });
        _this._width = Math.floor(TEXTURE_WIDTH / _this._config.scaledCharWidth);
        _this._height = Math.floor(TEXTURE_HEIGHT / _this._config.scaledCharHeight);
        var capacity = _this._width * _this._height;
        _this._cacheMap = new LRUMap_1.default(capacity);
        _this._cacheMap.prealloc(capacity);
        return _this;
    }
    DynamicCharAtlas.prototype.dispose = function () {
        if (this._bitmapCommitTimeout !== null) {
            window.clearTimeout(this._bitmapCommitTimeout);
            this._bitmapCommitTimeout = null;
        }
    };
    DynamicCharAtlas.prototype.beginFrame = function () {
        this._drawToCacheCount = 0;
    };
    DynamicCharAtlas.prototype.draw = function (ctx, glyph, x, y) {
        if (glyph.code === 32) {
            return true;
        }
        if (!this._canCache(glyph)) {
            return false;
        }
        var glyphKey = getGlyphCacheKey(glyph);
        var cacheValue = this._cacheMap.get(glyphKey);
        if (cacheValue !== null && cacheValue !== undefined) {
            this._drawFromCache(ctx, cacheValue, x, y);
            return true;
        }
        else if (this._drawToCacheCount < FRAME_CACHE_DRAW_LIMIT) {
            var index = void 0;
            if (this._cacheMap.size < this._cacheMap.capacity) {
                index = this._cacheMap.size;
            }
            else {
                index = this._cacheMap.peek().index;
            }
            var cacheValue_1 = this._drawToCache(glyph, index);
            this._cacheMap.set(glyphKey, cacheValue_1);
            this._drawFromCache(ctx, cacheValue_1, x, y);
            return true;
        }
        return false;
    };
    DynamicCharAtlas.prototype._canCache = function (glyph) {
        return glyph.code < 256;
    };
    DynamicCharAtlas.prototype._toCoordinateX = function (index) {
        return (index % this._width) * this._config.scaledCharWidth;
    };
    DynamicCharAtlas.prototype._toCoordinateY = function (index) {
        return Math.floor(index / this._width) * this._config.scaledCharHeight;
    };
    DynamicCharAtlas.prototype._drawFromCache = function (ctx, cacheValue, x, y) {
        if (cacheValue.isEmpty) {
            return;
        }
        var cacheX = this._toCoordinateX(cacheValue.index);
        var cacheY = this._toCoordinateY(cacheValue.index);
        ctx.drawImage(cacheValue.inBitmap ? this._bitmap : this._cacheCanvas, cacheX, cacheY, this._config.scaledCharWidth, this._config.scaledCharHeight, x, y, this._config.scaledCharWidth, this._config.scaledCharHeight);
    };
    DynamicCharAtlas.prototype._getColorFromAnsiIndex = function (idx) {
        if (idx < this._config.colors.ansi.length) {
            return this._config.colors.ansi[idx];
        }
        return ColorManager_1.DEFAULT_ANSI_COLORS[idx];
    };
    DynamicCharAtlas.prototype._getBackgroundColor = function (glyph) {
        if (this._config.allowTransparency) {
            return TRANSPARENT_COLOR;
        }
        else if (glyph.bg === Types_1.INVERTED_DEFAULT_COLOR) {
            return this._config.colors.foreground;
        }
        else if (glyph.bg < 256) {
            return this._getColorFromAnsiIndex(glyph.bg);
        }
        return this._config.colors.background;
    };
    DynamicCharAtlas.prototype._getForegroundColor = function (glyph) {
        if (glyph.fg === Types_1.INVERTED_DEFAULT_COLOR) {
            return this._config.colors.background;
        }
        else if (glyph.fg < 256) {
            return this._getColorFromAnsiIndex(glyph.fg);
        }
        return this._config.colors.foreground;
    };
    DynamicCharAtlas.prototype._drawToCache = function (glyph, index) {
        this._drawToCacheCount++;
        this._tmpCtx.save();
        var backgroundColor = this._getBackgroundColor(glyph);
        this._tmpCtx.globalCompositeOperation = 'copy';
        this._tmpCtx.fillStyle = backgroundColor.css;
        this._tmpCtx.fillRect(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight);
        this._tmpCtx.globalCompositeOperation = 'source-over';
        var fontWeight = glyph.bold ? this._config.fontWeightBold : this._config.fontWeight;
        var fontStyle = glyph.italic ? 'italic' : '';
        this._tmpCtx.font =
            fontStyle + " " + fontWeight + " " + this._config.fontSize * this._config.devicePixelRatio + "px " + this._config.fontFamily;
        this._tmpCtx.textBaseline = 'middle';
        this._tmpCtx.fillStyle = this._getForegroundColor(glyph).css;
        if (glyph.dim) {
            this._tmpCtx.globalAlpha = Types_1.DIM_OPACITY;
        }
        this._tmpCtx.fillText(glyph.chars, 0, this._config.scaledCharHeight / 2);
        this._tmpCtx.restore();
        var imageData = this._tmpCtx.getImageData(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight);
        var isEmpty = false;
        if (!this._config.allowTransparency) {
            isEmpty = CharAtlasGenerator_1.clearColor(imageData, backgroundColor);
        }
        var x = this._toCoordinateX(index);
        var y = this._toCoordinateY(index);
        this._cacheCtx.putImageData(imageData, x, y);
        var cacheValue = {
            index: index,
            isEmpty: isEmpty,
            inBitmap: false
        };
        this._addGlyphToBitmap(cacheValue);
        return cacheValue;
    };
    DynamicCharAtlas.prototype._addGlyphToBitmap = function (cacheValue) {
        var _this = this;
        if (!('createImageBitmap' in window) || Platform_1.isFirefox || Platform_1.isSafari) {
            return;
        }
        this._glyphsWaitingOnBitmap.push(cacheValue);
        if (this._bitmapCommitTimeout !== null) {
            return;
        }
        this._bitmapCommitTimeout = window.setTimeout(function () { return _this._generateBitmap(); }, GLYPH_BITMAP_COMMIT_DELAY);
    };
    DynamicCharAtlas.prototype._generateBitmap = function () {
        var _this = this;
        var glyphsMovingToBitmap = this._glyphsWaitingOnBitmap;
        this._glyphsWaitingOnBitmap = [];
        window.createImageBitmap(this._cacheCanvas).then(function (bitmap) {
            _this._bitmap = bitmap;
            for (var i = 0; i < glyphsMovingToBitmap.length; i++) {
                var value = glyphsMovingToBitmap[i];
                value.inBitmap = true;
            }
        });
        this._bitmapCommitTimeout = null;
    };
    return DynamicCharAtlas;
}(BaseCharAtlas_1.default));
exports.default = DynamicCharAtlas;

},{"../../core/Platform":23,"../ColorManager":31,"./BaseCharAtlas":38,"./CharAtlasGenerator":40,"./LRUMap":43,"./Types":46}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRUMap = (function () {
    function LRUMap(capacity) {
        this.capacity = capacity;
        this._map = {};
        this._head = null;
        this._tail = null;
        this._nodePool = [];
        this.size = 0;
    }
    LRUMap.prototype._unlinkNode = function (node) {
        var prev = node.prev;
        var next = node.next;
        if (node === this._head) {
            this._head = next;
        }
        if (node === this._tail) {
            this._tail = prev;
        }
        if (prev !== null) {
            prev.next = next;
        }
        if (next !== null) {
            next.prev = prev;
        }
    };
    LRUMap.prototype._appendNode = function (node) {
        var tail = this._tail;
        if (tail !== null) {
            tail.next = node;
        }
        node.prev = tail;
        node.next = null;
        this._tail = node;
        if (this._head === null) {
            this._head = node;
        }
    };
    LRUMap.prototype.prealloc = function (count) {
        var nodePool = this._nodePool;
        for (var i = 0; i < count; i++) {
            nodePool.push({
                prev: null,
                next: null,
                key: null,
                value: null
            });
        }
    };
    LRUMap.prototype.get = function (key) {
        var node = this._map[key];
        if (node !== undefined) {
            this._unlinkNode(node);
            this._appendNode(node);
            return node.value;
        }
        return null;
    };
    LRUMap.prototype.peekValue = function (key) {
        var node = this._map[key];
        if (node !== undefined) {
            return node.value;
        }
        return null;
    };
    LRUMap.prototype.peek = function () {
        var head = this._head;
        return head === null ? null : head.value;
    };
    LRUMap.prototype.set = function (key, value) {
        var node = this._map[key];
        if (node !== undefined) {
            node = this._map[key];
            this._unlinkNode(node);
            node.value = value;
        }
        else if (this.size >= this.capacity) {
            node = this._head;
            this._unlinkNode(node);
            delete this._map[node.key];
            node.key = key;
            node.value = value;
            this._map[key] = node;
        }
        else {
            var nodePool = this._nodePool;
            if (nodePool.length > 0) {
                node = nodePool.pop();
                node.key = key;
                node.value = value;
            }
            else {
                node = {
                    prev: null,
                    next: null,
                    key: key,
                    value: value
                };
            }
            this._map[key] = node;
            this.size++;
        }
        this._appendNode(node);
    };
    return LRUMap;
}());
exports.default = LRUMap;

},{}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseCharAtlas_1 = require("./BaseCharAtlas");
var NoneCharAtlas = (function (_super) {
    __extends(NoneCharAtlas, _super);
    function NoneCharAtlas(document, config) {
        return _super.call(this) || this;
    }
    NoneCharAtlas.prototype.draw = function (ctx, glyph, x, y) {
        return false;
    };
    return NoneCharAtlas;
}(BaseCharAtlas_1.default));
exports.default = NoneCharAtlas;

},{"./BaseCharAtlas":38}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Types_1 = require("./Types");
var CharAtlasGenerator_1 = require("./CharAtlasGenerator");
var BaseCharAtlas_1 = require("./BaseCharAtlas");
var CharAtlasUtils_1 = require("./CharAtlasUtils");
var StaticCharAtlas = (function (_super) {
    __extends(StaticCharAtlas, _super);
    function StaticCharAtlas(_document, _config) {
        var _this = _super.call(this) || this;
        _this._document = _document;
        _this._config = _config;
        _this._canvasFactory = function (width, height) {
            var canvas = _this._document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        };
        return _this;
    }
    StaticCharAtlas.prototype._doWarmUp = function () {
        var _this = this;
        var result = CharAtlasGenerator_1.generateStaticCharAtlasTexture(window, this._canvasFactory, this._config);
        if (result instanceof HTMLCanvasElement) {
            this._texture = result;
        }
        else {
            result.then(function (texture) {
                _this._texture = texture;
            });
        }
    };
    StaticCharAtlas.prototype._isCached = function (glyph, colorIndex) {
        var isAscii = glyph.code < 256;
        var isBasicColor = glyph.fg < 16;
        var isDefaultColor = glyph.fg === Types_1.DEFAULT_COLOR;
        var isDefaultBackground = glyph.bg === Types_1.DEFAULT_COLOR;
        return isAscii && (isBasicColor || isDefaultColor) && isDefaultBackground && !glyph.italic;
    };
    StaticCharAtlas.prototype.draw = function (ctx, glyph, x, y) {
        if (this._texture === null || this._texture === undefined) {
            return false;
        }
        var colorIndex = 0;
        if (CharAtlasUtils_1.is256Color(glyph.fg)) {
            colorIndex = 2 + glyph.fg + (glyph.bold ? 16 : 0);
        }
        else if (glyph.fg === Types_1.DEFAULT_COLOR) {
            if (glyph.bold) {
                colorIndex = 1;
            }
        }
        if (!this._isCached(glyph, colorIndex)) {
            return false;
        }
        ctx.save();
        var charAtlasCellWidth = this._config.scaledCharWidth + Types_1.CHAR_ATLAS_CELL_SPACING;
        var charAtlasCellHeight = this._config.scaledCharHeight + Types_1.CHAR_ATLAS_CELL_SPACING;
        if (glyph.dim) {
            ctx.globalAlpha = Types_1.DIM_OPACITY;
        }
        ctx.drawImage(this._texture, glyph.code * charAtlasCellWidth, colorIndex * charAtlasCellHeight, charAtlasCellWidth, this._config.scaledCharHeight, x, y, charAtlasCellWidth, this._config.scaledCharHeight);
        ctx.restore();
        return true;
    };
    return StaticCharAtlas;
}(BaseCharAtlas_1.default));
exports.default = StaticCharAtlas;

},{"./BaseCharAtlas":38,"./CharAtlasGenerator":40,"./CharAtlasUtils":41,"./Types":46}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_COLOR = 256;
exports.INVERTED_DEFAULT_COLOR = 257;
exports.DIM_OPACITY = 0.5;
exports.CHAR_ATLAS_CELL_SPACING = 1;

},{}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = require("../../common/EventEmitter");
var ColorManager_1 = require("../ColorManager");
var RenderDebouncer_1 = require("../../ui/RenderDebouncer");
var DomRendererRowFactory_1 = require("./DomRendererRowFactory");
var Types_1 = require("../atlas/Types");
var TERMINAL_CLASS_PREFIX = 'xterm-dom-renderer-owner-';
var ROW_CONTAINER_CLASS = 'xterm-rows';
var FG_CLASS_PREFIX = 'xterm-fg-';
var BG_CLASS_PREFIX = 'xterm-bg-';
var FOCUS_CLASS = 'xterm-focus';
var SELECTION_CLASS = 'xterm-selection';
var nextTerminalId = 1;
var DomRenderer = (function (_super) {
    __extends(DomRenderer, _super);
    function DomRenderer(_terminal, theme) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._terminalClass = nextTerminalId++;
        _this._rowElements = [];
        var allowTransparency = _this._terminal.options.allowTransparency;
        _this.colorManager = new ColorManager_1.ColorManager(document, allowTransparency);
        _this.setTheme(theme);
        _this._rowContainer = document.createElement('div');
        _this._rowContainer.classList.add(ROW_CONTAINER_CLASS);
        _this._rowContainer.style.lineHeight = 'normal';
        _this._rowContainer.setAttribute('aria-hidden', 'true');
        _this._refreshRowElements(_this._terminal.cols, _this._terminal.rows);
        _this._selectionContainer = document.createElement('div');
        _this._selectionContainer.classList.add(SELECTION_CLASS);
        _this._selectionContainer.setAttribute('aria-hidden', 'true');
        _this.dimensions = {
            scaledCharWidth: null,
            scaledCharHeight: null,
            scaledCellWidth: null,
            scaledCellHeight: null,
            scaledCharLeft: null,
            scaledCharTop: null,
            scaledCanvasWidth: null,
            scaledCanvasHeight: null,
            canvasWidth: null,
            canvasHeight: null,
            actualCellWidth: null,
            actualCellHeight: null
        };
        _this._updateDimensions();
        _this._renderDebouncer = new RenderDebouncer_1.RenderDebouncer(_this._terminal, _this._renderRows.bind(_this));
        _this._rowFactory = new DomRendererRowFactory_1.DomRendererRowFactory(document);
        _this._terminal.element.classList.add(TERMINAL_CLASS_PREFIX + _this._terminalClass);
        _this._terminal.screenElement.appendChild(_this._rowContainer);
        _this._terminal.screenElement.appendChild(_this._selectionContainer);
        _this._terminal.linkifier.on("linkhover", function (e) { return _this._onLinkHover(e); });
        _this._terminal.linkifier.on("linkleave", function (e) { return _this._onLinkLeave(e); });
        return _this;
    }
    DomRenderer.prototype.dispose = function () {
        this._terminal.element.classList.remove(TERMINAL_CLASS_PREFIX + this._terminalClass);
        this._terminal.screenElement.removeChild(this._rowContainer);
        this._terminal.screenElement.removeChild(this._selectionContainer);
        this._terminal.screenElement.removeChild(this._themeStyleElement);
        this._terminal.screenElement.removeChild(this._dimensionsStyleElement);
        _super.prototype.dispose.call(this);
    };
    DomRenderer.prototype._updateDimensions = function () {
        var _this = this;
        this.dimensions.scaledCharWidth = Math.floor(this._terminal.charMeasure.width * window.devicePixelRatio);
        this.dimensions.scaledCharHeight = Math.ceil(this._terminal.charMeasure.height * window.devicePixelRatio);
        this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.options.letterSpacing);
        this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.options.lineHeight);
        this.dimensions.scaledCharLeft = 0;
        this.dimensions.scaledCharTop = 0;
        this.dimensions.scaledCanvasWidth = this.dimensions.scaledCellWidth * this._terminal.cols;
        this.dimensions.scaledCanvasHeight = this.dimensions.scaledCellHeight * this._terminal.rows;
        this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / window.devicePixelRatio);
        this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / window.devicePixelRatio);
        this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;
        this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;
        this._rowElements.forEach(function (element) {
            element.style.width = _this.dimensions.canvasWidth + "px";
            element.style.height = _this.dimensions.actualCellHeight + "px";
            element.style.lineHeight = _this.dimensions.actualCellHeight + "px";
            element.style.overflow = 'hidden';
        });
        if (!this._dimensionsStyleElement) {
            this._dimensionsStyleElement = document.createElement('style');
            this._terminal.screenElement.appendChild(this._dimensionsStyleElement);
        }
        var styles = this._terminalSelector + " ." + ROW_CONTAINER_CLASS + " span {" +
            " display: inline-block;" +
            " height: 100%;" +
            " vertical-align: top;" +
            (" width: " + this.dimensions.actualCellWidth + "px") +
            "}";
        this._dimensionsStyleElement.innerHTML = styles;
        this._selectionContainer.style.height = this._terminal._viewportElement.style.height;
        this._terminal.screenElement.style.width = this.dimensions.canvasWidth + "px";
        this._terminal.screenElement.style.height = this.dimensions.canvasHeight + "px";
    };
    DomRenderer.prototype.setTheme = function (theme) {
        var _this = this;
        if (theme) {
            this.colorManager.setTheme(theme);
        }
        if (!this._themeStyleElement) {
            this._themeStyleElement = document.createElement('style');
            this._terminal.screenElement.appendChild(this._themeStyleElement);
        }
        var styles = this._terminalSelector + " ." + ROW_CONTAINER_CLASS + " {" +
            (" color: " + this.colorManager.colors.foreground.css + ";") +
            (" background-color: " + this.colorManager.colors.background.css + ";") +
            (" font-family: " + this._terminal.getOption('fontFamily') + ";") +
            (" font-size: " + this._terminal.getOption('fontSize') + "px;") +
            "}";
        styles +=
            this._terminalSelector + " span:not(." + DomRendererRowFactory_1.BOLD_CLASS + ") {" +
                (" font-weight: " + this._terminal.options.fontWeight + ";") +
                "}" +
                (this._terminalSelector + " span." + DomRendererRowFactory_1.BOLD_CLASS + " {") +
                (" font-weight: " + this._terminal.options.fontWeightBold + ";") +
                "}" +
                (this._terminalSelector + " span." + DomRendererRowFactory_1.ITALIC_CLASS + " {") +
                " font-style: italic;" +
                "}";
        styles +=
            this._terminalSelector + " ." + ROW_CONTAINER_CLASS + ":not(." + FOCUS_CLASS + ") ." + DomRendererRowFactory_1.CURSOR_CLASS + " {" +
                (" outline: 1px solid " + this.colorManager.colors.cursor.css + ";") +
                " outline-offset: -1px;" +
                "}" +
                (this._terminalSelector + " ." + ROW_CONTAINER_CLASS + "." + FOCUS_CLASS + " ." + DomRendererRowFactory_1.CURSOR_CLASS + "." + DomRendererRowFactory_1.CURSOR_STYLE_BLOCK_CLASS + " {") +
                (" background-color: " + this.colorManager.colors.cursor.css + ";") +
                (" color: " + this.colorManager.colors.cursorAccent.css + ";") +
                "}" +
                (this._terminalSelector + " ." + ROW_CONTAINER_CLASS + "." + FOCUS_CLASS + " ." + DomRendererRowFactory_1.CURSOR_CLASS + "." + DomRendererRowFactory_1.CURSOR_STYLE_BAR_CLASS + " {") +
                (" box-shadow: 1px 0 0 " + this.colorManager.colors.cursor.css + " inset;") +
                "}" +
                (this._terminalSelector + " ." + ROW_CONTAINER_CLASS + "." + FOCUS_CLASS + " ." + DomRendererRowFactory_1.CURSOR_CLASS + "." + DomRendererRowFactory_1.CURSOR_STYLE_UNDERLINE_CLASS + " {") +
                (" box-shadow: 0 -1px 0 " + this.colorManager.colors.cursor.css + " inset;") +
                "}";
        styles +=
            this._terminalSelector + " ." + SELECTION_CLASS + " {" +
                " position: absolute;" +
                " top: 0;" +
                " left: 0;" +
                " z-index: 1;" +
                " pointer-events: none;" +
                "}" +
                (this._terminalSelector + " ." + SELECTION_CLASS + " div {") +
                " position: absolute;" +
                (" background-color: " + this.colorManager.colors.selection.css + ";") +
                "}";
        this.colorManager.colors.ansi.forEach(function (c, i) {
            styles +=
                _this._terminalSelector + " ." + FG_CLASS_PREFIX + i + " { color: " + c.css + "; }" +
                    (_this._terminalSelector + " ." + BG_CLASS_PREFIX + i + " { background-color: " + c.css + "; }");
        });
        styles +=
            this._terminalSelector + " ." + FG_CLASS_PREFIX + Types_1.INVERTED_DEFAULT_COLOR + " { color: " + this.colorManager.colors.background.css + "; }" +
                (this._terminalSelector + " ." + BG_CLASS_PREFIX + Types_1.INVERTED_DEFAULT_COLOR + " { background-color: " + this.colorManager.colors.foreground.css + "; }");
        this._themeStyleElement.innerHTML = styles;
        return this.colorManager.colors;
    };
    DomRenderer.prototype.onWindowResize = function (devicePixelRatio) {
        this._updateDimensions();
    };
    DomRenderer.prototype._refreshRowElements = function (cols, rows) {
        for (var i = this._rowElements.length; i <= rows; i++) {
            var row = document.createElement('div');
            this._rowContainer.appendChild(row);
            this._rowElements.push(row);
        }
        while (this._rowElements.length > rows) {
            this._rowContainer.removeChild(this._rowElements.pop());
        }
    };
    DomRenderer.prototype.onResize = function (cols, rows) {
        this._refreshRowElements(cols, rows);
        this._updateDimensions();
    };
    DomRenderer.prototype.onCharSizeChanged = function () {
        this._updateDimensions();
    };
    DomRenderer.prototype.onBlur = function () {
        this._rowContainer.classList.remove(FOCUS_CLASS);
    };
    DomRenderer.prototype.onFocus = function () {
        this._rowContainer.classList.add(FOCUS_CLASS);
    };
    DomRenderer.prototype.onSelectionChanged = function (start, end, columnSelectMode) {
        while (this._selectionContainer.children.length) {
            this._selectionContainer.removeChild(this._selectionContainer.children[0]);
        }
        if (!start || !end) {
            return;
        }
        var viewportStartRow = start[1] - this._terminal.buffer.ydisp;
        var viewportEndRow = end[1] - this._terminal.buffer.ydisp;
        var viewportCappedStartRow = Math.max(viewportStartRow, 0);
        var viewportCappedEndRow = Math.min(viewportEndRow, this._terminal.rows - 1);
        if (viewportCappedStartRow >= this._terminal.rows || viewportCappedEndRow < 0) {
            return;
        }
        var documentFragment = document.createDocumentFragment();
        if (columnSelectMode) {
            documentFragment.appendChild(this._createSelectionElement(viewportCappedStartRow, start[0], end[0], viewportCappedEndRow - viewportCappedStartRow + 1));
        }
        else {
            var startCol = viewportStartRow === viewportCappedStartRow ? start[0] : 0;
            var endCol = viewportCappedStartRow === viewportCappedEndRow ? end[0] : this._terminal.cols;
            documentFragment.appendChild(this._createSelectionElement(viewportCappedStartRow, startCol, endCol));
            var middleRowsCount = viewportCappedEndRow - viewportCappedStartRow - 1;
            documentFragment.appendChild(this._createSelectionElement(viewportCappedStartRow + 1, 0, this._terminal.cols, middleRowsCount));
            if (viewportCappedStartRow !== viewportCappedEndRow) {
                var endCol_1 = viewportEndRow === viewportCappedEndRow ? end[0] : this._terminal.cols;
                documentFragment.appendChild(this._createSelectionElement(viewportCappedEndRow, 0, endCol_1));
            }
        }
        this._selectionContainer.appendChild(documentFragment);
    };
    DomRenderer.prototype._createSelectionElement = function (row, colStart, colEnd, rowCount) {
        if (rowCount === void 0) { rowCount = 1; }
        var element = document.createElement('div');
        element.style.height = rowCount * this.dimensions.actualCellHeight + "px";
        element.style.top = row * this.dimensions.actualCellHeight + "px";
        element.style.left = colStart * this.dimensions.actualCellWidth + "px";
        element.style.width = this.dimensions.actualCellWidth * (colEnd - colStart) + "px";
        return element;
    };
    DomRenderer.prototype.onCursorMove = function () {
    };
    DomRenderer.prototype.onOptionsChanged = function () {
        this._updateDimensions();
        this.setTheme(undefined);
        this._terminal.refresh(0, this._terminal.rows - 1);
    };
    DomRenderer.prototype.clear = function () {
        this._rowElements.forEach(function (e) { return e.innerHTML = ''; });
    };
    DomRenderer.prototype.refreshRows = function (start, end) {
        this._renderDebouncer.refresh(start, end);
    };
    DomRenderer.prototype._renderRows = function (start, end) {
        var terminal = this._terminal;
        var cursorAbsoluteY = terminal.buffer.ybase + terminal.buffer.y;
        var cursorX = this._terminal.buffer.x;
        for (var y = start; y <= end; y++) {
            var rowElement = this._rowElements[y];
            rowElement.innerHTML = '';
            var row = y + terminal.buffer.ydisp;
            var lineData = terminal.buffer.lines.get(row);
            var cursorStyle = terminal.options.cursorStyle;
            rowElement.appendChild(this._rowFactory.createRow(lineData, row === cursorAbsoluteY, cursorStyle, cursorX, this.dimensions.actualCellWidth, terminal.cols));
        }
        this._terminal.emit('refresh', { start: start, end: end });
    };
    Object.defineProperty(DomRenderer.prototype, "_terminalSelector", {
        get: function () {
            return "." + TERMINAL_CLASS_PREFIX + this._terminalClass;
        },
        enumerable: true,
        configurable: true
    });
    DomRenderer.prototype.registerCharacterJoiner = function (handler) { return -1; };
    DomRenderer.prototype.deregisterCharacterJoiner = function (joinerId) { return false; };
    DomRenderer.prototype._onLinkHover = function (e) {
        this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, true);
    };
    DomRenderer.prototype._onLinkLeave = function (e) {
        this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, false);
    };
    DomRenderer.prototype._setCellUnderline = function (x, x2, y, y2, cols, enabled) {
        while (x !== x2 || y !== y2) {
            var row = this._rowElements[y];
            if (!row) {
                return;
            }
            var span = row.children[x];
            if (span) {
                span.style.textDecoration = enabled ? 'underline' : 'none';
            }
            if (++x >= cols) {
                x = 0;
                y++;
            }
        }
    };
    return DomRenderer;
}(EventEmitter_1.EventEmitter));
exports.DomRenderer = DomRenderer;

},{"../../common/EventEmitter":19,"../../ui/RenderDebouncer":54,"../ColorManager":31,"../atlas/Types":46,"./DomRendererRowFactory":48}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Buffer_1 = require("../../Buffer");
var Types_1 = require("../atlas/Types");
exports.BOLD_CLASS = 'xterm-bold';
exports.ITALIC_CLASS = 'xterm-italic';
exports.CURSOR_CLASS = 'xterm-cursor';
exports.CURSOR_STYLE_BLOCK_CLASS = 'xterm-cursor-block';
exports.CURSOR_STYLE_BAR_CLASS = 'xterm-cursor-bar';
exports.CURSOR_STYLE_UNDERLINE_CLASS = 'xterm-cursor-underline';
var DomRendererRowFactory = (function () {
    function DomRendererRowFactory(_document) {
        this._document = _document;
    }
    DomRendererRowFactory.prototype.createRow = function (lineData, isCursorRow, cursorStyle, cursorX, cellWidth, cols) {
        var fragment = this._document.createDocumentFragment();
        var lineLength = 0;
        for (var x = Math.min(lineData.length, cols) - 1; x >= 0; x--) {
            var charData = lineData.get(x);
            var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];
            if (code !== Buffer_1.NULL_CELL_CODE || (isCursorRow && x === cursorX)) {
                lineLength = x + 1;
                break;
            }
        }
        for (var x = 0; x < lineLength; x++) {
            var charData = lineData.get(x);
            var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX] || Buffer_1.WHITESPACE_CELL_CHAR;
            var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX];
            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
            if (width === 0) {
                continue;
            }
            var charElement = this._document.createElement('span');
            if (width > 1) {
                charElement.style.width = cellWidth * width + "px";
            }
            var flags = attr >> 18;
            var bg = attr & 0x1ff;
            var fg = (attr >> 9) & 0x1ff;
            if (isCursorRow && x === cursorX) {
                charElement.classList.add(exports.CURSOR_CLASS);
                switch (cursorStyle) {
                    case 'bar':
                        charElement.classList.add(exports.CURSOR_STYLE_BAR_CLASS);
                        break;
                    case 'underline':
                        charElement.classList.add(exports.CURSOR_STYLE_UNDERLINE_CLASS);
                        break;
                    default:
                        charElement.classList.add(exports.CURSOR_STYLE_BLOCK_CLASS);
                        break;
                }
            }
            if (flags & 8) {
                var temp = bg;
                bg = fg;
                fg = temp;
                if (fg === Types_1.DEFAULT_COLOR) {
                    fg = Types_1.INVERTED_DEFAULT_COLOR;
                }
                if (bg === Types_1.DEFAULT_COLOR) {
                    bg = Types_1.INVERTED_DEFAULT_COLOR;
                }
            }
            if (flags & 1) {
                if (fg < 8) {
                    fg += 8;
                }
                charElement.classList.add(exports.BOLD_CLASS);
            }
            if (flags & 64) {
                charElement.classList.add(exports.ITALIC_CLASS);
            }
            charElement.textContent = char;
            if (fg !== Types_1.DEFAULT_COLOR) {
                charElement.classList.add("xterm-fg-" + fg);
            }
            if (bg !== Types_1.DEFAULT_COLOR) {
                charElement.classList.add("xterm-bg-" + bg);
            }
            fragment.appendChild(charElement);
        }
        return fragment;
    };
    return DomRendererRowFactory;
}());
exports.DomRendererRowFactory = DomRendererRowFactory;

},{"../../Buffer":2,"../atlas/Types":46}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = require("../common/EventEmitter");
var CharMeasure = (function (_super) {
    __extends(CharMeasure, _super);
    function CharMeasure(document, parentElement) {
        var _this = _super.call(this) || this;
        _this._document = document;
        _this._parentElement = parentElement;
        _this._measureElement = _this._document.createElement('span');
        _this._measureElement.classList.add('xterm-char-measure-element');
        _this._measureElement.textContent = 'W';
        _this._measureElement.setAttribute('aria-hidden', 'true');
        _this._parentElement.appendChild(_this._measureElement);
        return _this;
    }
    Object.defineProperty(CharMeasure.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharMeasure.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    CharMeasure.prototype.measure = function (options) {
        this._measureElement.style.fontFamily = options.fontFamily;
        this._measureElement.style.fontSize = options.fontSize + "px";
        var geometry = this._measureElement.getBoundingClientRect();
        if (geometry.width === 0 || geometry.height === 0) {
            return;
        }
        var adjustedHeight = Math.ceil(geometry.height);
        if (this._width !== geometry.width || this._height !== adjustedHeight) {
            this._width = geometry.width;
            this._height = adjustedHeight;
            this.emit('charsizechanged');
        }
    };
    return CharMeasure;
}(EventEmitter_1.EventEmitter));
exports.CharMeasure = CharMeasure;

},{"../common/EventEmitter":19}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function prepareTextForTerminal(text) {
    return text.replace(/\r?\n/g, '\r');
}
exports.prepareTextForTerminal = prepareTextForTerminal;
function bracketTextForPaste(text, bracketedPasteMode) {
    if (bracketedPasteMode) {
        return '\x1b[200~' + text + '\x1b[201~';
    }
    return text;
}
exports.bracketTextForPaste = bracketTextForPaste;
function copyHandler(ev, term, selectionManager) {
    if (term.browser.isMSIE) {
        window.clipboardData.setData('Text', selectionManager.selectionText);
    }
    else {
        ev.clipboardData.setData('text/plain', selectionManager.selectionText);
    }
    ev.preventDefault();
}
exports.copyHandler = copyHandler;
function pasteHandler(ev, term) {
    ev.stopPropagation();
    var text;
    var dispatchPaste = function (text) {
        text = prepareTextForTerminal(text);
        text = bracketTextForPaste(text, term.bracketedPasteMode);
        term.handler(text);
        term.textarea.value = '';
        term.emit('paste', text);
        term.cancel(ev);
    };
    if (term.browser.isMSIE) {
        if (window.clipboardData) {
            text = window.clipboardData.getData('Text');
            dispatchPaste(text);
        }
    }
    else {
        if (ev.clipboardData) {
            text = ev.clipboardData.getData('text/plain');
            dispatchPaste(text);
        }
    }
}
exports.pasteHandler = pasteHandler;
function moveTextAreaUnderMouseCursor(ev, term) {
    var pos = term.screenElement.getBoundingClientRect();
    var left = ev.clientX - pos.left - 10;
    var top = ev.clientY - pos.top - 10;
    term.textarea.style.position = 'absolute';
    term.textarea.style.width = '20px';
    term.textarea.style.height = '20px';
    term.textarea.style.left = left + "px";
    term.textarea.style.top = top + "px";
    term.textarea.style.zIndex = '1000';
    term.textarea.focus();
    setTimeout(function () {
        term.textarea.style.position = null;
        term.textarea.style.width = null;
        term.textarea.style.height = null;
        term.textarea.style.left = null;
        term.textarea.style.top = null;
        term.textarea.style.zIndex = null;
    }, 200);
}
exports.moveTextAreaUnderMouseCursor = moveTextAreaUnderMouseCursor;
function rightClickHandler(ev, term, selectionManager, shouldSelectWord) {
    moveTextAreaUnderMouseCursor(ev, term);
    if (shouldSelectWord && !selectionManager.isClickInSelection(ev)) {
        selectionManager.selectWordAtCursor(ev);
    }
    term.textarea.value = selectionManager.selectionText;
    term.textarea.select();
}
exports.rightClickHandler = rightClickHandler;

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function addDisposableDomListener(node, type, handler, useCapture) {
    node.addEventListener(type, handler, useCapture);
    return {
        dispose: function () {
            if (!handler) {
                return;
            }
            node.removeEventListener(type, handler, useCapture);
            node = null;
            handler = null;
        }
    };
}
exports.addDisposableDomListener = addDisposableDomListener;

},{}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MouseHelper = (function () {
    function MouseHelper(_renderer) {
        this._renderer = _renderer;
    }
    MouseHelper.prototype.setRenderer = function (renderer) {
        this._renderer = renderer;
    };
    MouseHelper.getCoordsRelativeToElement = function (event, element) {
        var rect = element.getBoundingClientRect();
        return [event.clientX - rect.left, event.clientY - rect.top];
    };
    MouseHelper.prototype.getCoords = function (event, element, charMeasure, colCount, rowCount, isSelection) {
        if (!charMeasure.width || !charMeasure.height) {
            return null;
        }
        var coords = MouseHelper.getCoordsRelativeToElement(event, element);
        if (!coords) {
            return null;
        }
        coords[0] = Math.ceil((coords[0] + (isSelection ? this._renderer.dimensions.actualCellWidth / 2 : 0)) / this._renderer.dimensions.actualCellWidth);
        coords[1] = Math.ceil(coords[1] / this._renderer.dimensions.actualCellHeight);
        coords[0] = Math.min(Math.max(coords[0], 1), colCount + (isSelection ? 1 : 0));
        coords[1] = Math.min(Math.max(coords[1], 1), rowCount);
        return coords;
    };
    MouseHelper.prototype.getRawByteCoords = function (event, element, charMeasure, colCount, rowCount) {
        var coords = this.getCoords(event, element, charMeasure, colCount, rowCount);
        var x = coords[0];
        var y = coords[1];
        x += 32;
        y += 32;
        return { x: x, y: y };
    };
    return MouseHelper;
}());
exports.MouseHelper = MouseHelper;

},{}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = require("../common/Lifecycle");
var Lifecycle_2 = require("./Lifecycle");
var HOVER_DURATION = 500;
var MouseZoneManager = (function (_super) {
    __extends(MouseZoneManager, _super);
    function MouseZoneManager(_terminal) {
        var _this = _super.call(this) || this;
        _this._terminal = _terminal;
        _this._zones = [];
        _this._areZonesActive = false;
        _this._tooltipTimeout = null;
        _this._currentZone = null;
        _this._lastHoverCoords = [null, null];
        _this.register(Lifecycle_2.addDisposableDomListener(_this._terminal.element, 'mousedown', function (e) { return _this._onMouseDown(e); }));
        _this._mouseMoveListener = function (e) { return _this._onMouseMove(e); };
        _this._clickListener = function (e) { return _this._onClick(e); };
        return _this;
    }
    MouseZoneManager.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._deactivate();
    };
    MouseZoneManager.prototype.add = function (zone) {
        this._zones.push(zone);
        if (this._zones.length === 1) {
            this._activate();
        }
    };
    MouseZoneManager.prototype.clearAll = function (start, end) {
        if (this._zones.length === 0) {
            return;
        }
        if (!end) {
            start = 0;
            end = this._terminal.rows - 1;
        }
        for (var i = 0; i < this._zones.length; i++) {
            var zone = this._zones[i];
            if ((zone.y1 > start && zone.y1 <= end + 1) ||
                (zone.y2 > start && zone.y2 <= end + 1) ||
                (zone.y1 < start && zone.y2 > end + 1)) {
                if (this._currentZone && this._currentZone === zone) {
                    this._currentZone.leaveCallback();
                    this._currentZone = null;
                }
                this._zones.splice(i--, 1);
            }
        }
        if (this._zones.length === 0) {
            this._deactivate();
        }
    };
    MouseZoneManager.prototype._activate = function () {
        if (!this._areZonesActive) {
            this._areZonesActive = true;
            this._terminal.element.addEventListener('mousemove', this._mouseMoveListener);
            this._terminal.element.addEventListener('click', this._clickListener);
        }
    };
    MouseZoneManager.prototype._deactivate = function () {
        if (this._areZonesActive) {
            this._areZonesActive = false;
            this._terminal.element.removeEventListener('mousemove', this._mouseMoveListener);
            this._terminal.element.removeEventListener('click', this._clickListener);
        }
    };
    MouseZoneManager.prototype._onMouseMove = function (e) {
        if (this._lastHoverCoords[0] !== e.pageX || this._lastHoverCoords[1] !== e.pageY) {
            this._onHover(e);
            this._lastHoverCoords = [e.pageX, e.pageY];
        }
    };
    MouseZoneManager.prototype._onHover = function (e) {
        var _this = this;
        var zone = this._findZoneEventAt(e);
        if (zone === this._currentZone) {
            return;
        }
        if (this._currentZone) {
            this._currentZone.leaveCallback();
            this._currentZone = null;
            if (this._tooltipTimeout) {
                clearTimeout(this._tooltipTimeout);
            }
        }
        if (!zone) {
            return;
        }
        this._currentZone = zone;
        if (zone.hoverCallback) {
            zone.hoverCallback(e);
        }
        this._tooltipTimeout = setTimeout(function () { return _this._onTooltip(e); }, HOVER_DURATION);
    };
    MouseZoneManager.prototype._onTooltip = function (e) {
        this._tooltipTimeout = null;
        var zone = this._findZoneEventAt(e);
        if (zone && zone.tooltipCallback) {
            zone.tooltipCallback(e);
        }
    };
    MouseZoneManager.prototype._onMouseDown = function (e) {
        if (!this._areZonesActive) {
            return;
        }
        var zone = this._findZoneEventAt(e);
        if (zone) {
            if (zone.willLinkActivate(e)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        }
    };
    MouseZoneManager.prototype._onClick = function (e) {
        var zone = this._findZoneEventAt(e);
        if (zone) {
            zone.clickCallback(e);
            e.preventDefault();
            e.stopImmediatePropagation();
        }
    };
    MouseZoneManager.prototype._findZoneEventAt = function (e) {
        var coords = this._terminal.mouseHelper.getCoords(e, this._terminal.screenElement, this._terminal.charMeasure, this._terminal.cols, this._terminal.rows);
        if (!coords) {
            return null;
        }
        var x = coords[0];
        var y = coords[1];
        for (var i = 0; i < this._zones.length; i++) {
            var zone = this._zones[i];
            if (zone.y1 === zone.y2) {
                if (y === zone.y1 && x >= zone.x1 && x < zone.x2) {
                    return zone;
                }
            }
            else {
                if ((y === zone.y1 && x >= zone.x1) ||
                    (y === zone.y2 && x < zone.x2) ||
                    (y > zone.y1 && y < zone.y2)) {
                    return zone;
                }
            }
        }
        return null;
    };
    return MouseZoneManager;
}(Lifecycle_1.Disposable));
exports.MouseZoneManager = MouseZoneManager;
var MouseZone = (function () {
    function MouseZone(x1, y1, x2, y2, clickCallback, hoverCallback, tooltipCallback, leaveCallback, willLinkActivate) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.clickCallback = clickCallback;
        this.hoverCallback = hoverCallback;
        this.tooltipCallback = tooltipCallback;
        this.leaveCallback = leaveCallback;
        this.willLinkActivate = willLinkActivate;
    }
    return MouseZone;
}());
exports.MouseZone = MouseZone;

},{"../common/Lifecycle":20,"./Lifecycle":51}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RenderDebouncer = (function () {
    function RenderDebouncer(_terminal, _callback) {
        this._terminal = _terminal;
        this._callback = _callback;
        this._animationFrame = null;
    }
    RenderDebouncer.prototype.dispose = function () {
        if (this._animationFrame) {
            window.cancelAnimationFrame(this._animationFrame);
            this._animationFrame = null;
        }
    };
    RenderDebouncer.prototype.refresh = function (rowStart, rowEnd) {
        var _this = this;
        rowStart = rowStart !== null && rowStart !== undefined ? rowStart : 0;
        rowEnd = rowEnd !== null && rowEnd !== undefined ? rowEnd : this._terminal.rows - 1;
        var isRowStartSet = this._rowStart !== undefined && this._rowStart !== null;
        var isRowEndSet = this._rowEnd !== undefined && this._rowEnd !== null;
        this._rowStart = isRowStartSet ? Math.min(this._rowStart, rowStart) : rowStart;
        this._rowEnd = isRowEndSet ? Math.max(this._rowEnd, rowEnd) : rowEnd;
        if (this._animationFrame) {
            return;
        }
        this._animationFrame = window.requestAnimationFrame(function () { return _this._innerRefresh(); });
    };
    RenderDebouncer.prototype._innerRefresh = function () {
        this._rowStart = Math.max(this._rowStart, 0);
        this._rowEnd = Math.min(this._rowEnd, this._terminal.rows - 1);
        this._callback(this._rowStart, this._rowEnd);
        this._rowStart = null;
        this._rowEnd = null;
        this._animationFrame = null;
    };
    return RenderDebouncer;
}());
exports.RenderDebouncer = RenderDebouncer;

},{}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lifecycle_1 = require("../common/Lifecycle");
var ScreenDprMonitor = (function (_super) {
    __extends(ScreenDprMonitor, _super);
    function ScreenDprMonitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ScreenDprMonitor.prototype.setListener = function (listener) {
        var _this = this;
        if (this._listener) {
            this.clearListener();
        }
        this._listener = listener;
        this._outerListener = function () {
            _this._listener(window.devicePixelRatio, _this._currentDevicePixelRatio);
            _this._updateDpr();
        };
        this._updateDpr();
    };
    ScreenDprMonitor.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.clearListener();
    };
    ScreenDprMonitor.prototype._updateDpr = function () {
        if (this._resolutionMediaMatchList) {
            this._resolutionMediaMatchList.removeListener(this._outerListener);
        }
        this._currentDevicePixelRatio = window.devicePixelRatio;
        this._resolutionMediaMatchList = window.matchMedia("screen and (resolution: " + window.devicePixelRatio + "dppx)");
        this._resolutionMediaMatchList.addListener(this._outerListener);
    };
    ScreenDprMonitor.prototype.clearListener = function () {
        if (!this._listener) {
            return;
        }
        this._resolutionMediaMatchList.removeListener(this._outerListener);
        this._listener = null;
        this._outerListener = null;
    };
    return ScreenDprMonitor;
}(Lifecycle_1.Disposable));
exports.ScreenDprMonitor = ScreenDprMonitor;

},{"../common/Lifecycle":20}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Terminal_1 = require("./public/Terminal");
module.exports = Terminal_1.Terminal;

},{"./public/Terminal":28}]},{},[56])(56)
});
//# sourceMappingURL=xterm.js.map
;
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('js/xterm/addons/fit/fit.js',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.fit = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function proposeGeometry(term) {
    if (!term.element.parentElement) {
        return null;
    }
    var parentElementStyle = window.getComputedStyle(term.element.parentElement);
    var parentElementHeight = parseInt(parentElementStyle.getPropertyValue('height'));
    var parentElementWidth = Math.max(0, parseInt(parentElementStyle.getPropertyValue('width')));
    var elementStyle = window.getComputedStyle(term.element);
    var elementPadding = {
        top: parseInt(elementStyle.getPropertyValue('padding-top')),
        bottom: parseInt(elementStyle.getPropertyValue('padding-bottom')),
        right: parseInt(elementStyle.getPropertyValue('padding-right')),
        left: parseInt(elementStyle.getPropertyValue('padding-left'))
    };
    var elementPaddingVer = elementPadding.top + elementPadding.bottom;
    var elementPaddingHor = elementPadding.right + elementPadding.left;
    var availableHeight = parentElementHeight - elementPaddingVer;
    var availableWidth = parentElementWidth - elementPaddingHor - term._core.viewport.scrollBarWidth;
    var geometry = {
        cols: Math.floor(availableWidth / term._core.renderer.dimensions.actualCellWidth),
        rows: Math.floor(availableHeight / term._core.renderer.dimensions.actualCellHeight)
    };
    return geometry;
}
exports.proposeGeometry = proposeGeometry;
function fit(term) {
    var geometry = proposeGeometry(term);
    if (geometry) {
        if (term.rows !== geometry.rows || term.cols !== geometry.cols) {
            term._core.renderer.clear();
            term.resize(geometry.cols, geometry.rows);
        }
    }
}
exports.fit = fit;
function apply(terminalConstructor) {
    terminalConstructor.prototype.proposeGeometry = function () {
        return proposeGeometry(this);
    };
    terminalConstructor.prototype.fit = function () {
        fit(this);
    };
}
exports.apply = apply;

},{}]},{},[1])(1)
});
//# sourceMappingURL=fit.js.map
;
//
// Modeled on jupyter's terminado.js, but modified a lot for Graffiti usage.
//
// xterm, xterm's css and its fit addon were downloaded and put in the graffiti code base, from here:
// "xterm.js": "https://unpkg.com/xterm@~3.11.0/dist/xterm.js"
// "xterm.js-fit": "https://unpkg.com/xterm@~3.11.0/dist/addons/fit/fit.js"
// "xterm.js-css": "https://unpkg.com/xterm@~3.11.0/dist/xterm.css"

define ('js/terminals.js',[
  'base/js/utils',
  'js/utils.js',
  'js/localizer.js',
  'js/xterm/xterm.js',
  'js/xterm/addons/fit/fit.js',
], (jupyterUtils, utils, localizer, terminalLib, fit) => {
  const terminals = {

    focusedTerminal: undefined,
    singleCDCommand: false,
    CDCommandCount : 0,
    terminalsList: {},

    _makeTerminal: (element, terminalId, wsUrl, sizeObj) => {
      //console.log('makeTerminal,wsUrl:', wsUrl);
      const ws = new WebSocket(wsUrl);
      terminalLib.applyAddon(fit);
      const term = new terminalLib({ 
        scrollback: 10000, 
        theme: { 
          foreground:'white',
          background: '#222',
          // foreground: 'black',
          // background: '#eee',
          selection: '#fff',
          cursor:'#f73', 
          cursorAccent: '#f22' 
        }
      });
      term.id = terminalId;
      // contents: contains all chars in and out of the terminal over the socket.
      let termObject = {
        socket: ws, 
        term: term, 
        contents: '',
        socketOpen: false,
        sendQueue: [],
        send: (data) => {
          if (termObject.socketOpen) {
            ws.send(JSON.stringify(['stdin',data]));
          } else {
            termObject.sendQueue.push(data);
          }
        }
      };
      ws.onopen = function(event) {
        termObject.socketOpen = true;
        for (let data of termObject.sendQueue) {
          // Send any commands queued up before the socket was ready, down the pipe
          ws.send(JSON.stringify(['stdin',data])); 
        }
        term.on('data', function(data) {
          ws.send(JSON.stringify(['stdin', data]));
        });

        // term.on('keydown', (data) => {
        //  console.log('keypress data:', data);
        // });
        
        //term.on('scroll', (data) => {
        //console.log('term scroll:', data);
        //});

        // term.on('selection', (data) => {
        //   console.log('term selection:', term.getSelection());
        // });

        term.on('focus', () => { 
          //console.log('Graffiti: terminal ' + term.id + ' focused');
          terminals.focusedTerminal = term.id;
        });

        term.on('blur', () => { 
          // console.log('terminal defocused'); 
          terminals.focusedTerminal = undefined;
        });

        term.on('refresh', (data) => {
          const checkYdisp = term._core.buffer.ydisp;
          if (term.storedYdisp !== undefined) {
            if (term.storedYdisp != checkYdisp) {
              terminals.eventsCallback({ 
                id: term.id,
                type: 'refresh',
                scrollLine: checkYdisp
              });
              //console.log('Graffiti: terminal refresh delta:', term.storedYdisp, checkYdisp);
            }
          }
          term.storedYdisp = term._core.buffer.ydisp;
        });

        term.open(element);
        term.fit();
        // Send the terminal size to the server.
        ws.send(JSON.stringify(["set_size", term.rows, term.cols,
                                window.innerHeight, window.innerWidth]));

        ws.onmessage = function(event) {
          const json_msg = JSON.parse(event.data);
          switch(json_msg[0]) {
            case "stdout":
              const newChars = json_msg[1];
              term.write(newChars);
              term.storedYdisp = term._core.buffer.ydisp;
              //console.log('received newCharslength:', newChars.length, newChars);
              termObject.contents += newChars;
              terminals.eventsCallback({ 
                id: term.id,
                scrollLine: term.storedYdisp,
                position: termObject.contents.length,
                focusedTerminal: terminals.focusedTerminal,
                firstRecord: false,
              });
              // console.log('termId:', terminalId,'received string of length:', json_msg[1].length, 'from server, contents now has:', termObject.contents);
              break;
            case "disconnect":
              term.write("\r\n\r\n[CLOSED]\r\n");
              break;
          }
        };
      };

      return termObject;
    },

    getFocusedTerminal: () => {
      return terminals.focusedTerminal;
    },

    // Get enough content to fill a terminal sufficiently during scrubbing or just starting playback.
    // We don't restore the entire contents we may have had for the terminal because it could be huge,
    // but we restore about 4x the terminal contents so you can scroll back a bit and to account for
    // curses program output and multibyte characters, etc.
    getContentToFillTerminal: (terminal, contents, contentsPointer) => {
      const portionMultiplier = 8;
      const term = terminal.term;
      const portionLength = (term.rows * term.cols) * portionMultiplier;
      const contentsPortion = contents.substr(Math.max(0,contentsPointer - portionLength), contentsPointer);
      //const contentsPortion = contents.substr(0, contentsPointer);
      //console.log('contentsPointer:', contentsPointer);
      return contentsPortion;
    },

    createTerminalCell: (cellId, config) => {
      if (terminals.terminalsList.hasOwnProperty(cellId)) {
        return terminals.terminalsList[cellId]; // already have this terminal set up
      }
      const cell = utils.findCellByCellId(cellId);
      if (cell !== undefined) {
        const cellJq = $(cell.element);
        const renderArea = cellJq.find('.rendered_html');

        renderArea.html('<div>' +
                        '  <span id="dummy-screen-rows" style="font-family:courier; font-weight:bold; font-size:15px;">bash-3.2$ </span>' +
                        '</div>');
        const lineHeight = renderArea.find('#dummy-screen-rows').height();
        renderArea.html('Loading...');

        const terminalHeight = lineHeight * config.rows; // pixels
        const terminalContainerId = 'graffiti-terminal-container-' + cellId;

        renderArea.html('<div class="graffiti-terminal-container" id="' + terminalContainerId + '" class="container" style="width:100%;height:' + terminalHeight + 'px;"></div>' +
                        '<div class="graffiti-terminal-links">' +
                        ' <div class="graffiti-terminal-go-notebook-dir">' + localizer.getString('JUMP_TO_NOTEBOOK_DIR') + '</div>' +
                        ' <div class="graffiti-terminal-reset">' + localizer.getString('RESET_TERMINAL') + '</div>' +
                        '</div>').show();

        const urlPathName = location.pathname;
        let host = location.host;
        let path = '/terminals/websocket/';
        if (urlPathName.indexOf('/notebooks/') > 0) {
          // In cases where Jupyter is hosted on a path-based VM, like on binder.org, we need to extract that path part 
          // and put it in front of the regular terminals endpoint.
          const parts = urlPathName.split(/\/notebooks\//,2);
          path = (parts[0].length > 0 ? parts[0] + path : path);
        }
        const wsUrl = location.protocol.replace('http', 'ws') + '//' + location.host + path + config.terminalId;
        const elem = $('#' + terminalContainerId);
        const sizeObj = {cols:40, rows:10};
        renderArea.find('.graffiti-terminal-reset').click((e) => {
          const target = $(e.target);
          const cellDOM = target.parents('.cell');
          const cellId = cellDOM.attr('graffiti-cell-id');
          terminals.resetTerminalCell(cellId);
        });

        renderArea.find('.graffiti-terminal-container').bind('mousewheel', (e) => {
          //console.log('xterm mousewheel',e.originalEvent.wheelDeltaY); // looks like values about 10 move one line...
        });

        const newTerminal = terminals._makeTerminal(elem[0], cellId, wsUrl, sizeObj);
        terminals.terminalsList[cellId] = newTerminal;

        elem.bind('click', () => { newTerminal.term.focus(); });

        const notebookDirectory = utils.getNotebookDirectory();
        //console.log('Graffiti: notebookDirectory:', notebookDirectory);
        if (notebookDirectory !== undefined) {
          // in theory we could check to see if we're already in the directory we are supposed to be in using basename:
          // https://stackoverflow.com/questions/23162299/how-to-get-the-last-part-of-dirname-in-bash
          const cdCommand = "" + 'if test -d ' + notebookDirectory + '; then cd ' + notebookDirectory + "; fi && clear\n";
          if (!terminals.singleCDCommand || (terminals.singleCDCommand && terminals.CDCommandCount < 1)) {
            newTerminal.send(cdCommand);
            terminals.CDCommandCount++;
          }
          renderArea.find('.graffiti-terminal-go-notebook-dir').click((e) => {
            newTerminal.send(cdCommand);
          });
        } else {
          renderArea.find('.graffiti-terminal-go-notebook-dir').hide(); // if this link is inactive, just hide it.
        }

        return newTerminal;
      } else {
        return undefined;
      }
    },

    createTerminalInCell: (cell, terminalId, desiredRows) => {
      const cellId = utils.getMetadataCellId(cell.metadata);
      if (terminalId === undefined) {
        terminalId = cellId;
      }
      if (cellId !== undefined) {
        const notebookDirectory = utils.getNotebookDirectory();
        const rows = (desiredRows === undefined ? 6 : desiredRows); // default is 6 rows but can be changed by metadata
        const graffitiConfig = {
          type : 'terminal',
          startingDirectory: notebookDirectory,
          terminalId: terminalId, // defaults to the graffiti cell id, but can be changed if author wants to display the same terminal twice in one notebook.
          rows: rows, 
        };
        utils.assignCellGraffitiConfig(cell, graffitiConfig);
        utils.selectCellByCellId(cellId);
        cell.set_text('<i>Loading terminal (' + cellId + '), please wait...</i>');
        cell.render();
        return terminals.createTerminalCell(cellId, graffitiConfig);
      }
    },

    refreshTerminalCell: (cellId) => {
      if (terminals.terminalsList[cellId] !== undefined) {
        // Create a new terminal id so we'll connect to a fresh socket.
        const term = terminals.terminalsList[cellId].term;
        term.refresh(0,100000);
        term.focus();        
      }
    },

    resetTerminalCell: (cellId) => {
      if (terminals.terminalsList[cellId] !== undefined) {
        const fetchParams = { method: 'delete', credentials: 'include',  };
        const cell = utils.findCellByCellId(cellId);
        const graffitiConfig = utils.getCellGraffitiConfig(cell);
        if (graffitiConfig !== undefined) {
          const deleteAPIEndpoint = location.origin + '/api/terminals/' + graffitiConfig.terminalId;
          const settings = { 
            // liberally cribbed from jupyter's codebase,
            // https://github.com/jupyter/notebook/blob/b8b66332e2023e83d2ee04f83d8814f567e01a4e/notebook/static/tree/js/terminallist.js#L110
            processData : false,
            type : "DELETE",
            dataType : "json",
            success : function () {
              console.log('Graffiti: successful terminal delete.');
            },
            error : utils.log_ajax_error,
          };
          jupyterUtils.ajax(deleteAPIEndpoint, settings);
        }
        const currentRows = terminals.terminalsList[cellId].term.rows;
        delete(terminals.terminalsList[cellId]);
        terminals.createTerminalInCell(cell, utils.generateUniqueId(), currentRows );
        utils.saveNotebook();
      }
    },

    // Just remove the cellId from the list we keep of terminals in the nb.
    removeTerminal: (cellId) => {
      delete(terminals.terminalsList[cellId]);
    },

    createTerminalCellAboveSelectedCell: () => {
      const newTerminalCell = Jupyter.notebook.insert_cell_above('markdown');
      if (newTerminalCell !== undefined) {
        return terminals.createTerminalInCell(newTerminalCell);
      }
      return undefined;
    },

    processRenderQueue: () => {
      if (terminals.renderQueue.length > 0) {
        const rq = terminals.renderQueue.shift();
        const cellId = utils.getMetadataCellId(rq.cell.metadata);
        // console.log('Processing render queue entry:', rq);
        terminals.createTerminalCell(cellId, rq.config);
        // make sure you can't double click this cell because that would break the terminal
        $(rq.cell.element[0]).unbind('dblclick').bind('dblclick', ((e) => { 
          e.stopPropagation();
          return false;
        }));
        setTimeout(terminals.processRenderQueue, 250);
      }
    },

    // If there are terminals present in this notebook, render them.
    renderAllTerminals: () => {
      const cells = Jupyter.notebook.get_cells();
      let cell, cellId;
      terminals.renderQueue = [];
      for (let i = 0; i < cells.length; ++i) {
        cell = cells[i];
        if (cell.cell_type === 'markdown') {
          if (cell.metadata.hasOwnProperty('graffitiConfig')) {
            if (cell.metadata.graffitiConfig.type === 'terminal') {
              let config = $.extend({}, cell.metadata.graffitiConfig);
              if ((utils.getNotebookGraffitiConfigEntry('singleTerminal') !== undefined) &&
                  (utils.getNotebookGraffitiConfigEntry('singleTerminal') == "true")) {
                config.terminalId = utils.getNotebookGraffitiConfigEntry('id');
                terminals.singleCDCommand = true;
              }
              terminals.renderQueue.push({cell: cell, config: config });
            }
          }
        }
      }
      terminals.processRenderQueue();
    },

    backupTerminalOutput: (cellId) => {
      const terminal = terminals.terminalsList[cellId];
      if (terminal !== undefined) {
        terminal.contentsBackup = terminal.contents;
      }
    },

    setTerminalContents: (opts) => {
      let cellId = opts.id;
      const newContents = opts.terminalsContents[cellId];
      let terminal = terminals.terminalsList[cellId];
      if (terminal === undefined) {
        console.log('Graffiti: cannot find terminal', cellId, 
                    'for sending output, trying to find next terminal from:', opts.nearestCellPosition);
        if (opts.nearestCellPosition === undefined || !opts.useNearestCellPosition) {
          return;
        }
        // Try to find a terminal after the nearest cell position. If you find one, dump output into that terminal. This happens because
        const cells = Jupyter.notebook.get_cells();
        let i, nearestCell, checkCellId;
        cellId = undefined;
        for (i = opts.nearestCellPosition + 1; i < cells.length; ++i) {
          nearestCell = cells[i];
          checkCellId = utils.getMetadataCellId(nearestCell.metadata);
          if (terminals.terminalsList.hasOwnProperty(checkCellId)) {
            cellId = checkCellId;
            console.log('Graffiti: We found a subsequent terminal and will write output to cell:', cellId);
            break;
          }
        }
        if (cellId === undefined) {
          return; // we couldn't find a terminal after the position passed in so we're going to give up and not try to write to any terminal.
        } else {
          terminal = terminals.terminalsList[cellId];
        }
      }
      terminal.contents = newContents;
      let madeUpdateToTerminal = false;
      if (terminal !== undefined) {
        let didScroll = false;
        if (!opts.incremental || opts.firstRecord || terminal.lastPosition === undefined) {
          terminal.term.reset();
          const portion = terminals.getContentToFillTerminal(terminal, terminal.contents, opts.position);
          terminal.term.write(portion);
          terminal.lastPosition = opts.position;
          madeUpdateToTerminal = true;
        } else {
          //console.log('setTerminalContents, opts:', opts, 'lastPosition', terminal.lastPosition, 'opts.position', opts.position);
          if (terminal.lastPosition !== opts.position) {
            const newPortion = terminal.contents.substr(terminal.lastPosition, opts.position - terminal.lastPosition);
            // Replace CR followed by a character NOT a line feed by the non-linefeed char alone. 
            // Sometimes we've gotten this weird situation with terminal recordings and this causes recorded
            // text to write over itself on the same line.
            const newPortionCleaned = newPortion.replace(/([\x0d])([^\x0a])/g, "$2"); 
            terminal.term.write(newPortionCleaned);
            terminal.lastPosition = opts.position;
            terminal.term.scrollToBottom();
            didScroll = true;
            madeUpdateToTerminal = true;
          }
        }
        // Scroll to the correct spot if needed
        if (!didScroll) {
          madeUpdateToTerminal = madeUpdateToTerminal || terminals.scrollTerminal(opts);
        }
      }
      return madeUpdateToTerminal;
    },

    clearTerminalsContentsPositions: () => {
      for (let cellId of Object.keys(terminals.terminalsList)) {
        terminals.terminalsList[cellId].lastPosition = undefined;
      }
    },

    focusTerminal: (cellId) => {
      const termRecord = terminals.terminalsList[cellId];
      if (termRecord !== undefined) {
        const cell = utils.findCellByCellId(cellId);
        cell.focus_cell();
        terminals.focusedTerminal = cellId;
        termRecord.term.focus();
      }
    },

    scrollTerminal: (opts) => {
      const termRecord = terminals.terminalsList[opts.id];
      if (termRecord !== undefined) {
        const term = termRecord.term;
        // Basically the same functionality as in scrollToLine, see here:
        // https://github.com/xtermjs/xterm.js/blob/c908da351b11d718f8dcda7424baee4bd8211681/src/Terminal.ts#L1302
        const scrollAmount = opts.scrollLine - term._core.buffer.ydisp;
        //console.log('scrollTerminal: opts.scrollLine', opts.scrollLine, 'ydisp', term._core.buffer.ydisp, 'scrollAmount', scrollAmount);
        if (scrollAmount !== 0) {
          term.scrollLines(scrollAmount);
          return true;
        }
      }
      return false;
    },

    restoreTerminalOutput: (cellId) => {
      const terminal = terminals.terminalsList[cellId];
      if (terminal !== undefined) {
        if (terminal.contentsBackup !== undefined) {
          if (terminal.contents != terminal.contentsBackup) {
            terminal.contents = terminal.contentsBackup;
            terminal.term.reset();
            terminal.term.write(terminal.contents);
          }
        }
      }      
    },

    saveOrRestoreTerminalOutputs: (action) => {
      for (let cellId of Object.keys(terminals.terminalsList)) {
        if (action === 'save') {
          terminals.backupTerminalOutput(cellId);
        } else {
          terminals.restoreTerminalOutput(cellId);
        }
      }
    },

    getTerminalsStates: (markAsFirstRecord) => {
      const states = [];
      for (let cellId of Object.keys(terminals.terminalsList)) {
        terminal = terminals.terminalsList[cellId];
        states.push({
          id: cellId,
          scrollLine: terminal.term._core.buffer.ydisp,
          position: terminal.contents.length,
          isFocused: (terminals.focusedTerminal === cellId),
          focusedTerminal: terminals.focusedTerminal,
          firstRecord: markAsFirstRecord,
        });
      }
      return states;
    },

    getTerminalsContents: () => {
      const contents = {};
      let terminal;
      for (let cellId of Object.keys(terminals.terminalsList)) {
        terminal = terminals.terminalsList[cellId];
        contents[cellId] = terminal.contents;
      }
      return contents;
    },

    refitAllTerminals: () => {
      let terminal;
      let term;
      for (let cellId of Object.keys(terminals.terminalsList)) {
        terminal = terminals.terminalsList[cellId];
        //console.log('Running fit on term', terminal.term.rows, terminal.term.cols);
        term = terminal.term;
        if (term && term.element && term.element.parentElement) { // safety check for race conditions
          terminal.term.fit();
          terminal.socket.send(JSON.stringify(["set_size", terminal.term.rows, terminal.term.cols,
                                               window.innerHeight, window.innerWidth]));
        }
      }
    },

    isTerminalCell: (cellId) => {
      return (terminals.terminalsList[cellId] !== undefined);
    },

    runTerminalCommand: (terminalId, command, addCR) => {
      // Inject the terminal command into the target terminal (if found).
      if (terminals.terminalsList[terminalId] !== undefined) {
        const term = terminals.terminalsList[terminalId];
        term.send(command);
        if (addCR) {
          term.send("\n");
        }
      }
    },

    init: (eventsCallback) => {
      terminals.eventsCallback = eventsCallback;
      terminals.renderAllTerminals();
    },


  }

  return terminals;

});

define('js/state.js',[
  'js/utils.js',
  'js/terminals.js',
], function (utils, terminalLib) {
  const state = {
    init: () => {
      console.log('Graffiti: state constructor running.');
      state.history = undefined;
      state.manifest = {};
      state.movieCache = {
        history: {},
        audio: {}
      };
      state.accessLevel = 'view'; // one of 'create' or 'view'. If 'create' then we can create new graffitis, otherwise we can only view them
      state.authorId = undefined; // set when we activivateGraffiti or load a manifest
      state.authorType = 'creator';  // currently hardwired to be creator (teacher).
      state.audioInitialized = false;
      state.recordingBlocked = false;
      state.activity = 'idle'; // one of "recording", "playing", "idle"
      state.previousActivity = undefined;
      state.shouldUpdateCellContentsDuringPlayback = false;
      state.pointer = { x : 0, y: 0 };
      state.windowSize = state.getWindowSize();
      state.resetOnNextPlay = false;
      state.recordedAudioString = '';
      state.audioStorageCallback = undefined;
      state.frameArrays = ['view', 'selections', 'contents', 'drawings', 'terminals', 'speaking', 'skip'];
      state.scrollTop = undefined;
      state.selectedCellId = undefined;
      state.mute = false;
      state.compressedPlayTimeDuration = 0.25 * 1000; // millis. make compressed time "really fast". It won't really compress down to this few seconds though, JS is too slow.
      state.playSpeeds = { 
        'regular' : 1.0,       // playback rate at speed it was originally recorded
        'rapid'   : 2.0,       // playback rate when watching entire recording fast, either a multiplier of real-time, or a "compressed time" multiplier
        'compressed' : 1.0,    // this is not a play rate, but a target time to compress skips into
        'scanInactive' : 1.0,  // playback rate while watching non-silence (speaking) in the recording (defunct)
        'scanActive' : 3.0     // playback rate while watching silence (no speaking) in the recordin (defunct)
      };
      state.currentPlaySpeed = 'regular';
      state.userChoicePlaySpeed = 'regular';
      state.rapidScanActive = false; // whether rapidscan is activate at this moment (it's activated during silent moments so we play faster)
      state.recordedCursorPosition = { x: -1000, y: -1000 };
      state.viewInfo = undefined;
      state.recordingCellInfo = {};
      state.tipTimeout = undefined;
      state.displayedTipInfo = undefined;
      state.movieRecordingStarted = false;
      state.cellsAffectedByActivity = {};
      state.terminalsAffectedByActivity = undefined;
      state.drawingFadeClockAllowed = true;
      state.drawingFadeStart;
      state.drawingFadeDuration = 1000;
      state.drawingFadePreFadeDelay = 2000;
      state.maxDrawingOpacity = 0.5;
      state.drawingOpacity = state.maxDrawingOpacity;
      state.totalDrawingFadeDuration = state.drawingFadePreFadeDelay + state.drawingFadeDuration;
      state.lastEditActivityTime = undefined;
      state.controlPanelDragging = false;
      state.controlPanelDragOffset = { x: 0, y: 0 };
      state.playableMovies = {};
      state.currentlyPlayingMovie = undefined;
      state.selectionSerialized = undefined;
      state.hidePlayerAfterPlayback = false;
      state.dontRestoreCellContentsAfterPlayback = false; // this is something the author can decide with a tooltip command.
      state.cellOutputsSent = {};
      state.stickerImageUrl = undefined;
      state.stickerImageCandidateUrl = undefined;
      state.cellIdsAddedDuringRecording = {};
      state.userId = undefined;
      state.workspace = {};
      state.speakingStatus = false; // true when the graffiti creator is currently speaking (not silent)
      state.currentSkipRecord = 0;
      state.appliedSkipRecord = undefined;
      state.totalSkipTimeForRecording = 0;
      state.cellStates = {
        contents: {},
        changedCells: {},
        selections: {}
      };
      state.skippedTimeSoFar = 0;
      state.animationIntervalIds = {};
      state.playbackCellAdditions = {};
      state.highlightsRefreshCellId = undefined;
      state.graffitiEditCellId = undefined;
      state.narratorInfo = {};
      state.shiftKeyIsDown = false;
      state.shiftKeyWentDown = false;
      state.scaleCursorWithWindow = false;
      state.terminalState = undefined;
      state.cellIdToGraffitiMap = {}; // maps which graffitis are present in which cells. Used for autosave cells.

      // Usage statistic gathering for the current session (since last load of the notebook)
      state.usageStats = {
        notebookLoadedAt: utils.getNow(),
        created: {},   // how many graffiti were created
        played: {},    // how much time and how many plays were done
        terminalCommands: {}, // what terminal commands were executed by graffiti
        totalTipsShown: 0,  // how many times we've shown tips
        totalUniqueTipsShown: 0,
        totalUniquePlays: 0,
        totalPlaysAllGraffiti: 0,
        totalPlayTimeAllGraffiti: 0,
        totalTerminalCommandsRun: 0,
        uniqueTips: {},
      };        
      state.statsKey = undefined;

      // Set up a default version of the drawing state object. This gets updated during drawing activity.
      state.drawingState = {
        drawingModeActivated: false,     // when true a drawing tool is selected
        drawingActivity: 'draw',         // One of 'draw', 'fade', 'wipe', 'sticker'. Note that 'drawing activity' includes using the eraser tool and stickering
        cellId: undefined,
        positions: {
          start: { x: 0, y: 0 },
          end: { x: 0, y: 0 }
        },
        promptWidth: 0,
        pen: {
          isDown: false, // becomes true when the pen is down, ie user has clicked and held the mouse button
          mouseDownPosition: { x : 0, y: 0 },
          downInMarkdown: false,    // Whether the pen went down in a markdown cell
          downInPromptArea: false,  // Whether the pen went down in the prompt area
          inPromptArea: false,      // True if the pen is in Jupyter's "prompt" div. This part of drawings/stickers will not be scaled in X, only in Y (if in markdown cell)
          permanence: 'temporary', // default: ink disappears after a second of inactivity
          type: 'line', // one of 'line', 'highlight', 'eraser', 'sticker'
          color: 'black',
          dash: 'solid', // one of 'solid', 'dashed'
          fill: 'none', // one of 'none', '#xyz'
          fillOpacity: 0
        },
        stickersRecords: {}, // This contains records of all stickers drawn to date during a recording, or since the last fadeout in a recording.
        stickerOnGrid: false,
        opacity: state.maxDrawingOpacity
      };

      state.skipping = false; // true if we are currently recording a skip
      state.skipTypes = {
        rapid: 1,
        absolute: 2,
        compressed: 3
      };
      state.skipInfo = {
        type: state.skipTypes.absolute,
        factor: 0
      };

      state.END_RECORDING_KEYDOWN_TIMEOUT = 1200;      

      utils.refreshCellMaps();

    },

    getManifest: () => {
      return state.manifest;
    },

    setManifest: (manifest) => {
      state.manifest = $.extend({}, manifest);
    },

    removeManifestEntry: (recordingCellId, recordingKey) => {
      const recordings = state.getManifestRecordingsForCell(recordingCellId);
      if (recordings != undefined) {
        if (recordings.hasOwnProperty(recordingKey)) {
          delete(recordings[recordingKey]);
          return true;
        }
      }
      return false;
    },

    getManifestSingleRecording: (recordingCellId, recordingKey) => {
      const recordings = state.getManifestRecordingsForCell(recordingCellId);
      if (recordings === undefined) {
        return undefined;
      }
      return recordings.hasOwnProperty(recordingKey) ? recordings[recordingKey] : undefined;
    },

    getManifestRecordingsForCell: (recordingCellId) => {
      return state.manifest.hasOwnProperty(recordingCellId) ? state.manifest[recordingCellId] : undefined;
    },

    setSingleManifestRecording: (recordingCellId, recordingKey, recordingData) => {
      if (!state.manifest.hasOwnProperty(recordingCellId)) {
        state.manifest[recordingCellId] = {};
      }
      state.manifest[recordingCellId][recordingKey] = recordingData;
    },

    refreshCellIdToGraffitiMap: () => {
      state.cellIdToGraffitiMap = {};
      const manifest = state.getManifest();
      let recording, recordingCellId, recordingKeys, i, saveToFileEntry, cellId;
      for (recordingCellId of Object.keys(manifest)) {
        recordingKeys = Object.keys(manifest[recordingCellId]);
        for (recordingKey of recordingKeys) {
          recording = manifest[recordingCellId][recordingKey];
          if ((recording.saveToFile !== undefined) && (recording.saveToFile.length > 0)) {
            for (i = 0; i < recording.saveToFile.length; ++i) {
              saveToFileEntry = recording.saveToFile[i];
              cellId = saveToFileEntry.cellId;
              if (state.cellIdToGraffitiMap[cellId] === undefined) {
                state.cellIdToGraffitiMap[cellId] = [];
              }
              state.cellIdToGraffitiMap[cellId].push(saveToFileEntry.path);
            }
          }
        }
      }
      console.log('Graffiti: cellIdToGraffitiMap:', state.cellIdToGraffitiMap);

    },

    getCellIdToGraffitiMap: (cellId) => {
      return state.cellIdToGraffitiMap[cellId];
    },

    // compute aggregate stats for this manifest: total number and time of all graffitis, how many cells have graffitis, etc.
    computeManifestStats: () => {
      const manifest = state.manifest;
      const cells = Jupyter.notebook.get_cells();
      let totals = {
        totalGraffitis: 0,          // how many graffitis in this notebook
        totalCells: cells.length,   // how many cells in this notebook
        totalCellsWithGraffitis: 0, // how many cells have graffitis
        maxGraffitiPerCell: 0,      // the maximum number of graffitis in any one cell
        maxTakesPerGraffiti: 0,     // the maximum number of takes for any one graffiti to date
        totalRecordedTime: 0,       // total play time of all graffitis
      }        
      let recording, recordingCells, recordingCellId, recordingKeys;
      let lenCheck, activeTakeId, takes;
      recordingCells = Object.keys(manifest);
      if (recordingCells.length > 0) {
        for (recordingCellId of Object.keys(manifest)) {
          if (recordingCellId !== 'stats') { // we don't want to gather stats on the stats themselves!
            recordingKeys = Object.keys(manifest[recordingCellId]);
            totals.totalCellsWithGraffitis++;
            lenCheck = recordingKeys.length;
            if (lenCheck > 0) {
              if (lenCheck > totals.maxGraffitiPerCell) {
                totals.maxGraffitiPerCell = lenCheck;
              }
              for (recordingKey of recordingKeys) {
                recording = manifest[recordingCellId][recordingKey];
                totals.totalGraffitis++;
                takes = recording.takes;
                if (takes !== undefined) {
                  activeTakeId = recording.activeTakeId;
                  if (takes[activeTakeId] !== undefined) {
                    totals.totalRecordedTime += takes[activeTakeId].duration;
                  }
                  lenCheck = Object.keys(takes).length;
                  if (lenCheck > totals.maxTakesPerGraffiti) {
                    totals.maxTakesPerGraffiti = lenCheck;
                  }
                }
              }
            }
          }
        }
      }
      return totals;
    },

    getAccessLevel: () => {
      return state.accessLevel;
    },

    setAccessLevel: (level) => {
      state.accessLevel = level;
    },

    getAuthorId: () => {
      return state.authorId;
    },

    setAuthorId: (authorId) => {
      state.authorId = authorId;
    },

    getAuthorType: () => {
      return state.authorType;
    },

    setAuthorType: (authorType) => {
      state.authorType = authorType;
    },

    getUserId: () => {
      return state.userId;
    },

    setUserId: (userId) => {
      state.userId = userId;
    },

    getWorkspace: () => {
      return state.workspace;
    },

    setWorkspace: (workspace) => {
      state.workspace = workspace;
    },

    getSpeakingStatus: () => {
      return state.speakingStatus;
    },

    setSpeakingStatus: (speakingStatus) => {
      state.speakingStatus = speakingStatus;
      state.storeHistoryRecord('speaking'); // record speaking status, if we are currently recording
    },
    

    clearHighlightsRefreshableCell: () => {
      state.highlightsRefreshCellId = undefined;
    },

    isSkipping: () => {
      return state.skipping;
    },

    isLastSkipRecord: () => {
      return ((state.currentSkipRecord !== undefined) && (state.history.skip !== undefined) && (state.currentSkipRecord === state.history.skip.length - 1));
    },

    startSkipping: () => {
      state.skipping = true;
    },

    stopSkipping: () => {
      state.skipping = false;
    },

    toggleSkipping: () => {
      state.skipping = !state.skipping;
      state.storeSkipRecord();
    },

    getCurrentSkipRecord: () => {
      return state.currentSkipRecord;
    },

    // If the current time is in the current (or next) skip record, return the skip record.
    timeInSkipRecordRange: (t) => {
      if (state.currentSkipRecord !== undefined) {
        const record = state.history.skip[state.currentSkipRecord];
        //console.log('timeInSkipRecordRange, checking time t', t, 'against record', record);
        if ((record.startTime <= t) && (t < record.endTime) && (state.appliedSkipRecord !== state.currentSkipRecord)) {
          return record;
        }
      }
      return undefined;
    },

    setAppliedSkipRecord: () => {
      state.appliedSkipRecord = state.currentSkipRecord;
      state.skippedTimeSoFar += state.currentSkipRecord.endTime - state.currentSkipRecord.startTime;
    },
    
    clearAppliedSkipRecord: () => {
      state.appliedSkipRecord = undefined;
    },

    getSkipInfo: () => {
      return state.skipInfo;
    },

    setSkipInfo: (info) => {
      if (info === undefined) {
        state.skipInfo = {
          type: state.skipTypes['absolute'],
          factor: 0,
        };
      } else {
        state.skipInfo = {
          type:   info.type,
          factor: info.factor,
        };
      }
    },

    getTotalSkipTimeForRecording: () => {
      return state.totalSkipTimeForRecording;
    },

    setTotalSkipTimeForRecording: () => {
      let record;
      state.totalSkipTimeForRecording = 0;
      if (state.history.skip !== undefined) {
        for (let i = 0; i < state.history.skip.length; ++i) {
          record = state.history.skip[i];
          // record.status is legacy, we only want to use status -1 skips from these skip records.
          if ((record.status === undefined) || ((record.status !== undefined) && record.status === -1)) { 
            state.totalSkipTimeForRecording += record.endTime - record.startTime;
          }
        }
      }
    },

    // Set the current or next skip record by scanning from 0 to the time given, looking
    // for a skip record that either straddles the time given, or is greater than the time
    // given (next skip record).
    updateCurrentSkipRecord: () => {
      const t = state.getTimePlayedSoFar();
      let record;
      state.currentSkipRecord = undefined;
      state.skippedTimeSoFar = 0;
      if (state.history.skip !== undefined) {
        for (let i = 0; i < state.history.skip.length; ++i) {
          record = state.history.skip[i];
          if (record.endTime < t) { // keep track of total skip time up to the current time played
            state.skippedTimeSoFar += record.endTime - record.startTime;
          }
          if (((record.startTime <= t) && (t < record.endTime)) ||
              (record.startTime > t)) {
            state.currentSkipRecord = i;
            break;
          }
        }
      }
    },

    createSkipRecord: () => {
      return {}; // there is no data needed in a skip record, just the fact that it exists and has a start and end time is sufficient.
    },

    // Create an absolute skip record for the very end of the recording for the time it was being cancelled (ctrl-key held down).
    addCancelTimeSkipRecord: () => {
      state.skipping = true;
      const record = state.createSkipRecord();
      record.startTime = state.history.duration - state.END_RECORDING_KEYDOWN_TIMEOUT;
      record.endTime = state.history.duration - 1;
      state.history['skip'].push(record);

      console.log('Graffiti: after addCancelTimeSkipRecord, skip history:', state.history['skip']);
    },

    getSkipsRecords: () => {
      return state.history['skip'];
    },

    clearSkipsRecords: () => {
      state.history['skip'] = [];
    },

    storeSkipRecord: () => {
      const numRecords = state.history['skip'].length;
      if (!state.skipping) {
        if (numRecords > 0) {
          // Close off last record created with an end time, if it exists.
          const lastRecord = state.history['skip'][numRecords - 1];
          if (!lastRecord.hasOwnProperty('endTime')) {
            lastRecord.endTime = utils.getNow();
            console.log('Graffiti: closed off previous record:', lastRecord);
            if (lastRecord.endTime - lastRecord.startTime < 10) {
              // Delete this record as it has insignificant time in it, ie user just flipped the button on and off.
              state.history['skip'].pop();
            } 
          }
        }
      } else {
        // Only add a new skip record when beginning a skip period.
        state.storeHistoryRecord('skip');
      }
      console.log('after storeSkipRecord, skip history:', state.history['skip']);
    },

    getSkippedTimeSoFar: () => {
      return state.skippedTimeSoFar;
    },

    getShiftKeyIsDown: () => {
      return state.shiftKeyIsDown;
    },

    setShiftKeyIsDown: (val) => {
      state.shiftKeyIsDown = val;
    },

    getShiftKeyWentDown: () => {
      return state.shiftKeyWentDown;
    },

    setShiftKeyWentDown: () => {
      state.shiftKeyWentDown = true;
    },

    clearShiftKeyWentDown: () => {
      state.shiftKeyWentDown = false;
    },

    getScaleCursorWithWindow: () => {
      return state.scaleCursorWithWindow;
    },

    clearScaleCursorWithWindow: () => {
      state.scaleCursorWithWindow = false;
    },

    setScaleCursorWithWindow: () => {
      state.scaleCursorWithWindow = true;
    },

    getGraffitiEditCellId: () => {
      return state.graffitiEditCellId;
    },

    setGraffitiEditCellId: (cellId) => {
      state.graffitiEditCellId = cellId;
    },

    getNarratorInfo: (which) => {
      return state.narratorInfo[which];
    },

    clearNarratorInfo: () => {
      state.narratorInfo = {};
    },

    setNarratorInfo: (which, val) => {
      state.narratorInfo[which] = val;
    },

    scanForSpeakingStatus: () => {
      targetTime = state.getTimePlayedSoFar();
      const lastSpeakingIndex = state.getIndexUpToTime('speaking', targetTime);
      let currentSpeakingStatus = true; // assume we are speaking initially, in case we don't have any speaking records at all.
      if (lastSpeakingIndex !== undefined) {
        for (let index = 0; index < lastSpeakingIndex; ++index) {
          record = state.getHistoryItem('speaking', index);
          currentSpeakingStatus = record.speaking;
        }
      }
      return currentSpeakingStatus;
    },

    setHighlightsRefreshCellId: (cellId) => {
      state.highlightsRefreshCellId = cellId;
    },

    getHighlightsRefreshCellId: () => {
      return state.highlightsRefreshCellId;
    },

    getAudioInitialized: () => {
      return state.audioInitialized;
    },

    setAudioInitialized: () => {
      state.audioInitialized = true;
    },

    getLastEditActivityTime: () => {
      return state.lastEditActivityTime;
    },

    setLastEditActivityTime: () => {
      state.lastEditActivityTime = utils.getNow();
    },

    clearLastEditActivityTime: () => {
      state.lastEditActivityTime = undefined;
    },

    getControlPanelDragging: () => {
      return state.controlPanelDragging;
    },

    getControlPanelDragOffset: () => {
      return state.controlPanelDragOffset;
    },

    setControlPanelDragOffset: (offset) => {
      state.controlPanelDragOffset = offset;
    },
    
    setControlPanelDragging: (dragging) => {
      state.controlPanelDragging = dragging;
    },

    // Window proportion adjustments for when recording is played on a different sized window than what it was recorded on. Not used any more
    getWindowSize: () => {
      return { width: $(window).width(), height: $(window).height() }
    },

    // deprecated, we are now relying on watching for width changes to #notebook-container to adjust for window size changes
    getStoredWindowSize: () => {
      return state.windowSize;
    },

    // deprecated, we are now relying on watching for width changes to #notebook-container to adjust for window size changes
    windowSizeChanged: () => {
      const currentWindowSize = state.getWindowSize();
      const previousWindowSize = state.getStoredWindowSize();
      if ((previousWindowSize.width !== currentWindowSize.width) || (previousWindowSize.height !== currentWindowSize.height)) {
        state.windowSize = state.getWindowSize();
        return true;
      }
      return false;
    },

    setTipTimeout: (tipFunc, t) => {
      state.clearTipTimeout();
      state.tipTimeout = setTimeout(tipFunc, t);
    },

    clearTipTimeout: () => {
      if (state.tipTimeout !== undefined) {
        clearTimeout(state.tipTimeout);
        state.tipTimeout = undefined;
      }
    },

    clearDisplayedTipInfo: () => {
      state.displayedTipInfo = undefined;
    },

    setDisplayedTipInfo: (cellId, recordingKey) => {
      state.displayedTipInfo = { cellId: cellId, recordingKey: recordingKey };
    },

    getDisplayedTipInfo: () => {
      return state.displayedTipInfo;
    },

    getStickerImageUrl: (stickerImageUrl) => {
      return state.stickerImageUrl;
    },

    setStickerImageUrl: (stickerImageUrl) => {
      state.stickerImageUrl = stickerImageUrl;
    },

    getStickerImageCandidateUrl: (stickerImageCandidateUrl) => {
      return state.stickerImageCandidateUrl;
    },

    // We set this in setPlayableMovie(). 
    // When we start playing a movie, we use this to set the final candidate for the movie, which was set by %%custom_sticker in tooltip.
    setStickerImageCandidateUrl: (stickerImageCandidateUrl) => {
      state.stickerImageCandidateUrl = stickerImageCandidateUrl;
    },
    
    saveSelectedCellId: (cellId) => {
      state.selectedCellId = cellId;
    },

    getSelectedCellId: () => {
      return state.selectedCellId;
    },

    getMute: () => {
      return state.mute;
    },

    setMute: (muteState) => {
      state.mute = muteState;
    },

    rapidIsOn: () => {
      return state.currentPlaySpeed === 'rapid';
    },

    scanningIsOn: () => {
      //console.log('scanning is on, currentPlaySpeed:', state.currentPlaySpeed);
      return (state.currentPlaySpeed === 'scanActive' || state.currentPlaySpeed === 'scanInactive');
    },

    getCurrentPlaySpeed: () => {
      return state.currentPlaySpeed;
    },

    resetPlayTimes: (preset) => {
      //console.log('resetPlayTimes, preset:', preset);
      state.playTimes = {};
      for (let type of Object.keys(state.playSpeeds)) {
        state.playTimes[type] = {
          start:undefined,
          total: 0,
        };
      };
      if (preset !== undefined) {
        state.playTimes['regular'] = {
          start: utils.getNow(),
          total: preset
        }
      };
    },

    setPlayTimeBegin: (kind) => {
      state.playTimes[kind].start = utils.getNow();
    },

    setPlayTimeEnd: (kind) => {
      let playSpeed = state.currentPlaySpeed;
      if (kind !== undefined) {
        playSpeed = kind;
      }
      state.playTimes[playSpeed].total += utils.getNow() - state.playTimes[playSpeed].start; // real-time spent watching at this given playSpeed
    },


    // play speed types are 'regular', 'rapid', and 'scan'.
    setCurrentPlaySpeed: (kind) => {
      if (state.activity === 'playing') {
        if (state.currentPlaySpeed !== kind) {
          state.setPlayTimeEnd();
          state.setPlayTimeBegin(kind);
        }
      }
      state.currentPlaySpeed = kind;        
      //console.log('currentPlaySpeed:', state.currentPlaySpeed, 'playTimes', state.playTimes);
    },

    getUserChoicePlaySpeed: () => {
      return state.userChoicePlaySpeed;
    },

    storeUserChoicePlaySpeed: (userChoicePlaySpeed) => {
      state.userChoicePlaySpeed = userChoicePlaySpeed;
    },

    getPlayRateScalar: () => {
      return state.playSpeeds[state.currentPlaySpeed];
    },

    setPlayRate: (kind, newPlayRate) => {
      state.playSpeeds[kind] = newPlayRate;      
    },

    setCompressedTimePlayRate: (duration, timeTarget) => {
      const accelerationFactor = duration / timeTarget;
      state.setPlayRate('compressed', accelerationFactor);
      // console.log('duration, timeTarget, accelerationFactor:', duration,timeTarget, accelerationFactor);
    },

    setPlayStartTimeToNow: () => {
      state.playTimes[state.currentPlaySpeed].start = utils.getNow();
    },

    shouldUpdateDisplay: (kind, frameIndex) => {
      if (frameIndex === undefined) {
        return false;
      }
      if (_.contains(state.history.processed[kind],frameIndex.index)) {
        return false; // during playback, we've already processed this record so don't reprocess it.
      }
      state.history.processed[kind].push(frameIndex.index);
      return true;
    },

    resetProcessedArrays: () => {
      if (state.history !== undefined) {
        state.history.processed = [];
        for (let arrName of state.frameArrays) {
          state.history.processed[arrName] = [];
        }      
      }
    },

    blockRecording: () => {
      state.recordingBlocked = true;
    },

    unblockRecording: () => {
      state.recordingBlocked = false;
    },

    getUsageStats: () => {
      const usageStats = $.extend(true, {}, state.usageStats, 
                                  state.computeManifestStats());
      usageStats.totalUniqueTipsShown = Object.keys(state.usageStats.uniqueTips).length;
      usageStats.statsGatheredAt = utils.getNow();
      delete(usageStats['uniqueTips']);

      return usageStats;
    },

    updateUsageStats: (opts) => {
      const data = opts.data;
      const type = opts.type;
      const playStats = state.usageStats.played;
      const createStats = state.usageStats.created;
      let cellId, recordingKey, activeTakeId, statsKey;
      if ((type === 'create') || (type === 'setup') || (type === 'terminalCommand') || (type === 'tip')) {
        cellId = data.cellId;
        recordingKey = data.recordingKey;
      }
      switch (type) {
        case 'create':
          statsKey = utils.composeGraffitiId(cellId, recordingKey);
          if (!createStats.hasOwnProperty(statsKey)) {
            createStats[statsKey] = {
              createDate: data.createDate,
              numEditsThisSession: 0
            };
          }
          createStats[statsKey].numEditsThisSession++;
          createStats[statsKey].numTakes = data.numTakes;
          break;
        case 'setup':
          activeTakeId = data.activeTakeId;
          statsKey = utils.composeGraffitiId(cellId, recordingKey, activeTakeId);
          if (!playStats.hasOwnProperty(statsKey)) {
            playStats[statsKey] = {
              totalTime: 0, 
              totalPlays: 0
            };
          }
          state.currentStatsKey = statsKey;
          break;
        case 'tip':
          state.usageStats.totalTipsShown++;
          const tipKey = utils.composeGraffitiId(cellId, recordingKey);
          if (!state.usageStats.uniqueTips.hasOwnProperty(tipKey)) {
            state.usageStats.uniqueTips[tipKey] = 0;
          }
          state.usageStats.uniqueTips[tipKey]++;
          break;
        case 'terminalCommand':
          const terminalCommandsStats = state.usageStats.terminalCommands;
          statsKey = utils.composeGraffitiId(cellId, recordingKey);
          state.usageStats.totalTerminalCommandsRun++;
          if (!terminalCommandsStats.hasOwnProperty(statsKey)) {
            terminalCommandsStats[statsKey] = {
              createDate: data.createDate,
              commands: [],
              numRunsThisSession: 0
            };
          } 
          terminalCommandsStats[statsKey].numRunsThisSession++;
          terminalCommandsStats[statsKey].commands.push(opts.command);
          break;
        case 'play':
          const usageRecord = playStats[state.currentStatsKey];
          for (let action of data.actions) {
            switch (action) {
              case 'resetCurrentPlayTime':
                delete(usageRecord['currentPlayTime']);
                break;
              case 'updateCurrentPlayTime':
                usageRecord.currentPlayTime = Math.round(state.getTimePlayedSoFar());
                break;
              case 'updateTotalPlayTime':
                if (state.currentStatsKey !== undefined) {
                  usageRecord.totalTime += usageRecord.currentPlayTime;
                  state.usageStats.totalPlayTimeAllGraffiti += usageRecord.currentPlayTime;
                  delete(usageRecord['currentPlayTime']);
                }
                break;
              case 'incrementPlayCount':
                usageRecord.totalPlays++;
                state.usageStats.totalPlaysAllGraffiti++;
                state.usageStats.totalUniquePlays = Object.keys(playStats).length;
                break;
            }
          }
      }
      //console.log('updateUsageStats:', state.usageStats);
    },
    
    //
    // Drawing utility fns
    //
    getDrawingPenAttribute: (attr) => {
      return state.drawingState.pen[attr];
    },

    getDrawingState: () => {
      return state.drawingState;
    },
    
    getDrawingStateField: (field) => {
      return state.drawingState[field];
    },

    // Store the stickers stages sticker lists for later redrawing during playing/scrubbing
    storeStickersStateForCell: (stickers, cellId) => {
      let stickersRecords = {};
      if ((stickers !== undefined) && (stickers.length > 0)) {
        stickersRecords = [];
        for (let sticker of stickers) {
          // Copy important fields from the "live" sticker records into the drawing state; these will be persisted as sticker records
          // inside drawing records for later playback.
          // NB: we don't include label stickers that don't have text labels at all, these are just displayed for guidance while placing the sticker

          stickersRecords.push({
            positions: { start: { x: sticker.positions.start.x, y: sticker.positions.start.y },
                         end:   { x: sticker.positions.end.x, y: sticker.positions.end.y } },
            innerCellRect: {
              left: sticker.innerCellRect.left,
              top:  sticker.innerCellRect.top,
              width:  sticker.innerCellRect.width,
              height:  sticker.innerCellRect.height,
            },
            pen: {
              stickerType: sticker.pen.stickerType,
              color: sticker.pen.color,
              dash:  sticker.pen.dash,
              fill:  sticker.pen.fill,
              fillOpacity:  sticker.pen.fillOpacity,
              permanence: sticker.pen.permanence,
              label: sticker.pen.label,
              downInMarkdown: sticker.pen.downInMarkdown,
              downInPromptArea: sticker.pen.downInPromptArea,
              inPromptArea: sticker.pen.inPromptArea,
            },
            stickerOnGrid: sticker.stickerOnGrid,
            promptWidth: sticker.promptWidth,
          });
        }
      }
      state.drawingState.stickersRecords = stickersRecords;
      //console.log('stickersRecords:', stickersRecords);
    },

    updateDrawingState: (changeSets) => {
      for (let changeSet of changeSets) {
        const change = changeSet.change;
        const data = changeSet.data;
        const drawingState = state.drawingState;
        drawingState.wipe = false; // default, we don't register a wipe state
        switch (change) {
          case 'drawingModeActivated':
            drawingState.drawingModeActivated = data; // a drawing/sticker tool is activated.
            break;
          case 'drawingActivity':
            drawingState.drawingActivity = data; // the drawing mode (mouse is down) : one of 'draw', 'sticker', 'fade', 'wipe' (mutually exclusive)
            break;
          case 'cellId':
            drawingState.cellId = data;
            break;
          case 'isDown':
            drawingState.pen.isDown = data;
            break;
          case 'mouseDownPosition':
            drawingState.pen.mouseDownPosition = { x: data.x, y: data.y };
            break;
          case 'downInMarkdown':
            drawingState.pen.downInMarkdown = data; // whether the drawing/stickering started in a markdown cell
            break;
          case 'downInPromptArea':
            drawingState.pen.downInPromptArea = data; // whether the drawing/stickering started in the prompt area
            break;
          case 'inPromptArea':
            drawingState.pen.inPromptArea = data; // whether the drawing/stickering in the .prompt div
            break;
          case 'promptWidth':
            drawingState.promptWidth = data;
            break;
          case 'stickerOnGrid':
            drawingState.stickerOnGrid = data;
            break;
          case 'fillOpacity': // if sticker fill is actually visible
            drawingState.pen.fillOpacity = data;
            break;
          case 'penType':
            drawingState.pen.type = data;  // one of 'line', 'highlight', 'eraser', or 'sticker'
            break;
          case 'stickerType':
            drawingState.pen.stickerType = data; // one of many sticker types. if this is set that penType will not be set, and vice versa
            let fill = 'none'; // fill color. this is confusing and needs to be cleaned up a lot
            switch (data) {
              case 'isocelesTriangle':
              case 'rightTriangle':
              case 'ellipse':
              case 'rectangle':          
              case 'leftCurlyBrace':
              case 'rightCurlyBrace':
              case 'symmetricCurlyBraces':
              case 'topBracket':
              case 'bottomBracket':
              case 'leftBracket':
              case 'rightBracket':
              case 'horizontalBrackets':
              case 'verticalBrackets':
              case 'smiley':
              case 'frowney':
              case 'thumbsUp':
              case 'thumbsDown':
              case 'star':
              case 'line':
              case 'lineWithArrow':
              case 'label':
              case 'custom':
                // all these cases have an implicit fill type of 'none'
                break;
              case 'checkMark':
                fill = '00aa00'; // hardwired to green
                break;
              case 'x':
                fill = 'aa0000'; // hardwired to reddish
                break;
              case 'theta': // greek symbols hardwired to black
              case 'sigma':
                fill = '000000';
                break;
            }
            drawingState.pen.fill = fill; // fill color, if opacity == 1
            break;
          case 'label':
            // a label is actually a sticker that's just typed text
            drawingState.pen.label = data;
            break;
          case 'permanence':
            drawingState.pen.permanence = data; // one of 'permanent', 'temporary'
            break;
          case 'positions':
            let bbox = { start: { x: data.positions.start.x, y: data.positions.start.y }, end: { x: data.positions.end.x, y: data.positions.end.y } };
            if (drawingState.pen.penType === 'sticker') {
              if (drawingState.pen.stickerType !== 'line') {
                // Unless we're drawing a line sticker, we want to compute bounding box around the given shape, as it will always be the same orientation, and
                // always have a minimum size
                bbox = { start: { x: Math.min(data.positions.start.x, data.positions.end.x), 
                                  y: Math.min(data.positions.start.y, data.positions.end.y) },
                         end:   { x: Math.max(data.positions.start.x, data.positions.end.x), 
                                  y: Math.max(data.positions.start.y, data.positions.end.y) }
                };
              }
            }
            drawingState.positions = bbox;
            break;
          case 'color':
            drawingState.pen.color = data;
            break;
          case 'dash':
            drawingState.pen.dash = data; // one of 'solid', 'dashed'
            break;
          case 'opacity':
            drawingState.opacity = data; // set during fades of temporary ink
            break;
          case 'wipe':
            drawingState.wipe = true; // after fades are done, this record wipes the temporary canvases clean
            break;
        }
      }
      // console.log('updateDrawingState, state=', state.drawingState);
    },

    resetDrawingOpacity: () => {
      state.drawingState.opacity = state.maxDrawingOpacity;
    },

    getActivePenType: () => {
      return state.drawingState.pen.type;
    },

    getDrawingOpacity: () => {
      return state.drawingOpacity;
    },

    setDrawingOpacity: (opacity) => {
      state.drawingState.drawingOpacity = opacity;
    },

    getMaxDrawingOpacity: () => {
      return state.maxDrawingOpacity;
    },

    resetDrawingOpacity: () => {
      state.drawingState.drawingOpacity = state.maxDrawingOpacity;
    },

    getDrawingFadeTimeSoFar: () => {
      return utils.getNow() - state.drawingFadeStart;
    },

    calculateDrawingOpacity: () => {
      // console.log('drawingFadeCounter', state.drawingFadeCounter);
      const timeSoFar = state.getDrawingFadeTimeSoFar();
      let opacity = state.maxDrawingOpacity;
      if (!state.drawingFadeClockAllowed || timeSoFar < state.drawingFadePreFadeDelay) {
        return { status: 'max', opacity: state.maxDrawingOpacity };
      }
      if (timeSoFar < state.totalDrawingFadeDuration) {
        opacity = ((state.totalDrawingFadeDuration - timeSoFar) / state.drawingFadeDuration) * state.maxDrawingOpacity;
        //console.log('calculateDrawingOpacity:', opacity);
        return { status: 'fade', opacity: opacity };
      }
      return { status: 'fadeDone', opacity: 0 };
    },

    disableDrawingFadeClock: () => {
      state.drawingFadeClockAllowed = false; // not allowed while drawing a drawing
    },

    startDrawingFadeClock: () => {
      // console.log('startDrawingFadeClock');
      state.drawingFadeStart = utils.getNow();
      state.drawingFadeClockAllowed = true;
    },

    getLastRecordedCursorPosition: () => {
      return { x: state.recordedCursorPosition.x, y: state.recordedCursorPosition.y }
    },

    setLastRecordedCursorPosition: (pos) => {
      state.recordedCursorPosition = { x: pos.x, y: pos.y }
    },

    getPlaybackStartTime: () => {
      return state.playbackStartTime;
    },

    setPlaybackStartTime: (startTime) => {
      state.playbackStartTime = startTime;
    },

    startAnimationInterval: (name, cb, timing) => {
      if (state.animationIntervalIds[name] !== undefined) {
        clearInterval(state.animationIntervalIds[name]);
      }
      state.animationIntervalIds[name] = setInterval(cb, timing);      
    },

    clearAnimationIntervals: () => {
      const ids = Object.keys(state.animationIntervalIds);
      for (let id of ids) {
        if (state.animationIntervalIds[id] !== undefined) {
          clearInterval(state.animationIntervalIds[id]);
          delete(state.animationIntervalIds[id]);
        }
      }
    },

    getSetupForReset: () => {
      return state.resetOnNextPlay;
    },

    clearSetupForReset: () => {
      state.resetOnNextPlay = false;
    },

    setupForReset: () => {
      state.resetOnNextPlay = true;
    },

    getResetOnNextPlay: () => {
      return state.resetOnNextPlay;
    },

    // Set the index back to the beginning
    resetPlayState: () => {
      state.resetOnNextPlay = false;
      state.resetPlayTimes();
      state.resetProcessedArrays();
    },

    getActivity: () => {
      return state.activity;
    },

    setActivity: (newState) => {
      console.log('Graffiti: setting activity to:', newState);
      state.activity = newState;
    },

    getPreviousActivity: () => {
      return state.previousActivity;
    },

    storePreviousActivity: () => {
      state.previousActivity = state.activity;
    },

    restorePreviousActivity: () => {
      state.activity = state.previousActivity;
    },

    getPointerPosition: () => {
      return state.pointer;
    },

    storePointerPosition: (x,y) => {
      state.pointer = { x: x, y: y };
      //console.log('graffiti.state.pointer:', graffiti.state.pointer);
    },

    getViewInfo: () => {
      return state.viewInfo;
    },

    storeViewInfo: (viewInfo) => {
      if (viewInfo.cellId !== undefined) { // may not be set if cursor is btwn cells
        state.viewInfo = $.extend({}, viewInfo);
      }
    },

    setSelectionSerialized: (selectionSerialized) => {
      state.selectionSerialized = selectionSerialized;
    },

    clearSelectionSerialized: () => {
      state.selectionSerialized = undefined;
    },

    getSelectionSerialized: () => {
      return state.selectionSerialized;
    },

    getRecordingCellInfo: () => {
      // Copy the latest duration into the recordingCellInfo so we persist it in the manifest, if we have it (for the activeTake only)
      if ((state.history !== undefined) && (state.history.duration !== undefined) &&
          (state.recordingCellInfo.takes !== undefined) && (state.recordingCellInfo.activeTakeId !== undefined)) {
        state.recordingCellInfo.takes[state.recordingCellInfo.activeTakeId].duration = state.history.duration;
      }
      return state.recordingCellInfo;
    },

    storeRecordingCellInfo: (cellInfo) => {
      // console.trace('storeRecordingCellInfo:', cellInfo);
      state.recordingCellInfo = cellInfo;
    },

    getPlayableMovie: (kind) => {
      return state.playableMovies[kind];
    },

    setPlayableMovie: (kind, cellId, recordingKey, hoverCellId) => {
      let cellIndex = undefined;
      if (hoverCellId !== undefined) {
        cellIndex = utils.findCellIndexByCellId(hoverCellId);
      }
      const cell = utils.findCellByCellId(cellId);
      const cellType = (cell === undefined ? undefined : cell.cell_type);
      const recording = state.getManifestSingleRecording(cellId, recordingKey);
      const activeTakeId = recording.activeTakeId;
      state.playableMovies[kind] = { 
        recordingCellId: cellId, 
        recordingKey: recordingKey, 
        activeTakeId: activeTakeId, 
        cell: cell, 
        cellIndex: cellIndex, 
        cellType: cellType 
      };
      state.setStickerImageCandidateUrl(recording.stickerImageUrl);

      //console.trace('setPlayableMovie, kind:', kind, 'cellId:', cellId, 'recordingKey:',recordingKey, 'playableMovies:', state.playableMovies);
      return recording;
    },

    clearPlayableMovie: (kind) => {
      //console.trace('Graffiti: clearing playable movie of kind', kind);
      state.playableMovies[kind] = undefined;
    },

    getMovieRecordingStarted: () => {
      return state.movieRecordingStarted;
    },

    setMovieRecordingStarted: (status) => {
      state.movieRecordingStarted = status;
    },

    getCurrentlyPlayingMovie: () => {
      return state.currentlyPlayingMovie;
    },

    setCurrentlyPlayingMovie: (movie) => {
      state.currentlyPlayingMovie = movie;
    },

    getHidePlayerAfterPlayback: () => {
      return state.hidePlayerAfterPlayback;
    },

    setHidePlayerAfterPlayback: (status) => {
      state.hidePlayerAfterPlayback = status;
    },

    getDontRestoreCellContentsAfterPlayback: () => {
      return state.dontRestoreCellContentsAfterPlayback;
    },

    setDontRestoreCellContentsAfterPlayback: (status) => {
      //console.trace('setDontRestoreCellContentsAfterPlayback:', status);
      state.dontRestoreCellContentsAfterPlayback = status;
    },

    clearCellOutputsSent: () => {
      state.cellOutputsSent = {};
    },

    getCellAdditions: () => {
      if (state.history !== undefined) {
        const  allAdditions = _.union(Object.keys(state.history.cellAdditions), Object.keys(state.playbackCellAdditions));
        return allAdditions;
      }
      return undefined;
    },

    storeCellAddition: (cellId,position) => {
      if (state.activity === 'recording') {
        state.history.cellAdditions[cellId] = position;
        //console.log('cellAdditions:', state.cellAdditions);
      }
    },

    storePlaybackCellAddition: (cellId, position) => {
      state.playbackCellAdditions[cellId] = position;
    },

    clearCellAdditions: () => {
      state.history.cellAdditions = {};
      state.playbackCellAdditions = {};
    },

    storeTerminalsState: (newState) => {
      state.terminalsState = newState; // state of one or more terminals at any given time
    },

    getShouldUpdateCellContentsDuringPlayback: () => {
      return state.shouldUpdateCellContentsDuringPlayback;
    },

    setShouldUpdateCellContentsDuringPlayback: (val) => {
      state.shouldUpdateCellContentsDuringPlayback = val;
    },

    // In any history:
    //
    // Each entry in pointer[] is an object with:
    //   end time of this frame
    //   cursor position relative to active cell
    //   a hash of cell selections
    // Each entry in selection[] is an object with:
    //   end time of this frame
    //   currently active cell id
    //   a hash of all cell selections
    // Each entry in contents[] is an object with:
    //   end time of this frame
    //   hash of all cell contents by id

    dumpHistory: () => {
      console.log('Graffiti: Dumping JSON history');
      console.log("Graffiti: =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
      console.log('Graffiti:', state.history);
      console.log("Graffiti: =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
    },

    createViewRecord: (subType) => {
      const drawingState = state.drawingState;
      const pen = drawingState.pen;
      const downInMarkdown = ((pen.isDown) && pen.downInMarkdown);
      const downInPromptArea = ((pen.isDown) && pen.downInPromptArea);
      const drawingActivity = (pen.isDown ? drawingState.drawingActivity : undefined);
      const stickerCellId = ((pen.isDown && drawingState.drawingActivity == 'sticker') ? drawingState.cellId : undefined);
      let stickerInfo = undefined, stickerCellWidth = 0, stickerCellHeight = 0;
      if (stickerCellId !== undefined) {
        const stickerCell = utils.findCellByCellId(stickerCellId);
        const stickerCellElement = $(stickerCell.element[0]).find('.inner_cell');
        const bbox = stickerCellElement[0].getBoundingClientRect();
        stickerCellWidth = bbox.width;
        stickerCellHeight = bbox.height;
        stickerInfo = { cellId: stickerCellId, width:stickerCellWidth, height: stickerCellHeight };
      }
      const topBarHeight = $('#header').height();
      const inTopBarArea = state.pointer.y < topBarHeight;

      return $.extend({}, state.viewInfo, {
        x: state.pointer.x - parseInt(state.viewInfo.outerCellRect.left),
        y: state.pointer.y - parseInt(state.viewInfo.outerCellRect.top),
        downInMarkdown: downInMarkdown,
        downInPromptArea: downInPromptArea,
        drawingActivity: drawingActivity,
        inTopBarArea: inTopBarArea,
        subType: subType,
        speakingStatus: state.speakingStatus,
        scrollDiff: state.viewInfo.scrollDiff,
        selectedCellId: state.selectedCellId,
        stickerInfo: stickerInfo
      });
    },

    createDrawingRecord: (opts) => {
      const cell = utils.findCellByCellId(state.drawingState.cellId);
      const cellRects = utils.getCellRects(cell);
      let record = $.extend(true, {}, {
        innerCellRect: { 
          left: cellRects.innerCellRect.left, 
          top: cellRects.innerCellRect.top,
          width: cellRects.innerCellRect.width,
          height: cellRects.innerCellRect.height
        }
      }, state.drawingState);

      // Remove drawing status fields that are not needed in history records
      delete(record['drawingModeActivated']);
      delete(record.pen['isDown']);
      delete(record.pen['mouseDownPosition']);
      delete(record['wipe']);
      delete(record['stickerActive']);
      delete(record['stickerOnGrid']);
      if (opts.stickering) {
        // Remove unnecessary items which have more precise info in each sticker record for this drawing frame.
        delete(record['positions']);
        delete(record['pen']);
        delete(record['promptWidth']);
        delete(record['innerCellRect']);
      }
      //console.log('createDrawingRecord:', record);
      return record;
    },

    // drawingRecords (above) contain a hash of stickerRecords, below: all stickers on display during that drawing frame
    createStickerRecord: () => {
      const cell = utils.findCellByCellId(state.drawingState.cellId);
      const cellRects = utils.getCellRects(cell);
      let record = $.extend(true, {}, {
        innerCellRect: { 
          left: cellRects.innerCellRect.left, 
          top: cellRects.innerCellRect.top,
          width: cellRects.innerCellRect.width,
          height: cellRects.innerCellRect.height
        }
      }, state.drawingState);

      // Remove drawing status fields that are not needed in history records
      delete(record.drawingModeActivated);
      delete(record.pen.isDown);
      delete(record.pen['mouseDownPosition']);
      delete(record.wipe);
      // console.log('createStickerRecord:', record);
      return record;
    },


    createSelectionsRecord: () => {
      const activeCell = Jupyter.notebook.get_selected_cell();
      const cells = Jupyter.notebook.get_cells();
      const cellsSelections = {};
      let cellId, cm, cell, selections, cellSelections, output, outputs0, ourJs;
      for (let i = 0; i < cells.length; ++i) {
        cell = cells[i];
        if (cell.cell_type === 'code') {
          cellId = utils.getMetadataCellId(cell.metadata);
          cm = cell.code_mirror;
          selections = utils.cleanSelectionRecords(cm.listSelections());
          output = null;
          ourJs = false; 
          if (cell.output_area.outputs.length > 0) {
            outputs0 = cell.output_area.outputs[0];
            output_type = outputs0.output_type;
            // console.log('checking output area output_type:', output_type);
            if (output_type === 'display_data') {
              if (outputs0.data.hasOwnProperty('application/javascript')) {
                if (outputs0.data['application/javascript'].match(/Graffiti\sjavascript/g) !== null) {
                  ourJs = true;
                }
              }
            }
            if (!ourJs) {
              // Note that we filter out our own javascript outputs-- we don't want to rerun these when we restore cell states or 
              // else we could rerun the whole recording.
              // console.log('recording output for outputs0:', outputs0);
              output = { 
                header: { msg_type: output_type },
                content: outputs0
              };
            }
          } else {
            // if this code cell has no output at time of recording, record that fact for playback
            output = {
              empty: true
            };
          }
          cellSelections = {
            index: i,
            active: cellId === utils.getMetadataCellId(activeCell.metadata),
            selections: selections,
            output: output
          }
          cellsSelections[cellId] = cellSelections;
        }
      }

      return { 
        cellsSelections: cellsSelections,
        // Record text selections in rendered markdown or output areas. These are to be found in state.selectionSerialized (or if none, undefined)
        textSelection: state.selectionSerialized
      };
    },

    extractDataFromContentRecord: (record, cellId) => {
      if (record.backRef !== undefined) {
        if (record.backRefKind === 'contents') {
          return state.history.contents[record.backRef].cellsContent[cellId].contentsRecord.data;
        } else {
          return state.history.contents[record.backRef].cellsContent[cellId].outputsRecord.data;
        }
      }
      return record.data;
    },

    createBackRefRecord: (data, backRefKind, backRefArray, cellId) => {
      let backRef;
      let record = backRefArray[cellId];
      if (record !== undefined) {
        if ( (backRefKind === 'contents' && data === record.data) ||
             (backRefKind === 'outputs'  && _.isEqual(data, record.data)) ) {
          backRef = record.index;
          data = undefined;
        }
      }
      // Store as-yet-unseen contents or outputs for later backref. Delete the backRefKind value to avoid confusion, *unless* we are not bothering 
      // with backref storage (because we're using this function from storeCellStates() via createContentsRecord().
      if (data !== undefined) {
        backRefKind = undefined;
        backRefArray[cellId] = {
          index: state.history.contents.length, // note that this is not the length - 1, because we are still contructing
          // this contents record and haven't pushed it onto the history yet.
          data: data
        }
      }
      return {
        data: data,
        backRefKind: backRefKind,
        backRef: backRef
      }
    },

    createContentsRecord: (doBackRefStore) => {
      let cellId, cell, contents, outputs, contentsBackRefRecord, outputsBackRefRecord;
      const cells = Jupyter.notebook.get_cells();
      let cellsContent = {}, cellsPresentThisFrame = {};
      for (let i = 0; i < cells.length; ++i) {
        cell = cells[i];
        const graffitiConfig = utils.getCellGraffitiConfig(cell);
        if (graffitiConfig !== undefined) {
          const graffitiType = graffitiConfig.type;
          if ((graffitiType !== undefined) && (graffitiType === 'terminal')) {
            continue; // don't save terminal cell state here, it's saved by a separate fn
          }
        }
        cellId = utils.getMetadataCellId(cell.metadata);
        cellsPresentThisFrame[cellId] = utils.findCellIndexByCellId(cellId);
        contents = cell.get_text();
        outputs = undefined;
        // Store the DOM contents of the code cells for rerendering.
        const cellDom = $(cell.element);
        const outputArea = cellDom.find('.output');
        if (outputArea.length > 0) {
          outputs = outputArea.html();
        }

        if (doBackRefStore) {
          contentsBackRefRecord = state.createBackRefRecord(contents, 'contents', state.history.cellContentsTracking, cellId);
          outputsBackRefRecord =  state.createBackRefRecord(outputs,  'outputs',  state.history.cellOutputsTracking,  cellId);
        } else {
          contentsBackRefRecord = { data: contents, backRefKind: 'contents', backRef: undefined };
          outputsBackRefRecord =  { data: outputs,  backRefKind: 'outputs',  backRef: undefined  };
        }

        // console.log('createContentsRecord, outputs:', outputs);
        let cellContent = {
          index: i,
          contentsRecord: contentsBackRefRecord,
          outputsRecord: outputsBackRefRecord
        }
        cellsContent[cellId] = cellContent;
      }

      return { cellsContent: cellsContent, cellsPresentThisFrame: cellsPresentThisFrame };
    },

    createTerminalsRecord: () => {
      // Collect display positions of all terminals. If no terminals history has been recorded yet then mark these records as the "first records",
      // which will trigger term.reset() calls during playback.
      const markAsFirstRecord = state.history.terminals.length === 0;
      const terminalsState = terminalLib.getTerminalsStates(markAsFirstRecord);
      return { terminals: terminalsState };
    },

    getHistoryTerminalsContents: () => {
      return state.history.terminalsContents;
    },

    storeTerminalsContentsInHistory: () => {
      state.history.terminalsContents = terminalLib.getTerminalsContents();
    },

    createSpeakingRecord: () => {
      return { speaking: state.speakingStatus };
    },
    
    storeHistoryRecord: (type, time) => {
      if (state.activity !== 'recording' || state.recordingBlocked)
        return;

      let record;
      // Note: we override the type to throw together pointer moves, scroll innerScroll, and focus in one history record type
      switch (type) {
        case 'pointer':
          record = state.createViewRecord('pointer');
          type = 'view'; // override passed-in type: pointer is a view type
          break;
        case 'scroll':
          record = state.createViewRecord('scroll');
          type = 'view'; // override passed-in type: scroll is a view type
          break;
        case 'innerScroll':
          record = state.createViewRecord('innerScroll');
          type = 'view'; // override passed-in type: innerScroll is a view type
          break;
        case 'focus':
          record = state.createViewRecord('focus');
          type = 'view'; // override passed-in type: focus is a view type
          break;
        case 'selectCell':
          record = state.createViewRecord('selectCell');
          type = 'view'; // override passed-in type: focus is a view type
          break;
        case 'drawings':
          record = state.createDrawingRecord({stickering:false});
          break;
        case 'stickers':
          record = state.createDrawingRecord({stickering:true});
          type = 'drawings'; // we store sticker records as arrays within drawing records.
          break;
        case 'selections':
          record = state.createSelectionsRecord();
          break;
        case 'contents':
          record = state.createContentsRecord(true);
          break;
        case 'terminals':
          record = state.createTerminalsRecord();
          break;
        case 'speaking':
          record = state.createSpeakingRecord();
          break;
        case 'skip':
          record = state.createSkipRecord();
          break;
      }
      record.startTime = (time !== undefined ? time : utils.getNow());
      state.history[type].push(record);
    },

    initHistory: (initialValues) => {
      const now = utils.getNow();
      state.history = {
        storageCellId: initialValues.storageCellId,
        recordingStartTime: now,

        // Time tracks: all pointer positions, cell selections and contents over the time of the recording.
        view:        [],                          // pointer move, vertical scroll or innerscroll (scroll inside cell)
        selections:  [],                          // cell selections
        contents:    [],                          // contents state: what cells present, and what their contents are, and cell outputs
        drawings:    [],                          // drawing record, of type: ['draw', 'fade', 'wipe', 'sticker']
        terminals:   [],                          // terminal record. Records (recent) changes to contents of a terminal
        speaking:    [],                          // time ranges where creator is speaking or silent
        skip:        [],                          // time ranges when creator has requested either an acceleration or a time compression

        // Where we are in each track, during playback.
        lastVisited: {
          view:       0,
          selections: 0,
          contents:   0,
          drawings:   0,
          terminals:  0,
          speaking:   0,
          skip:       0,
        },

        cellContentsTracking: {},                  // this enables back-referencing to reduce storage costs on content recording
        cellOutputsTracking:  {},                  // this enables back-referencing to reduce storage costs on output recording
        cellAdditions: {}                          // id's and positions of any cells added during the recording.
      }

      // Set up to keep track of the latest record processed during playback (so we don't process a record twice).
      state.resetProcessedArrays();

      // Store initial state records at the start of recording.
      state.storeHistoryRecord('pointer',    now);
      state.storeHistoryRecord('scroll',     now);
      state.storeHistoryRecord('focus',      now);
      state.storeHistoryRecord('selections', now);
      state.storeHistoryRecord('contents',   now);
      state.storeHistoryRecord('terminals',  now);
    },

    finalizeHistory: () => {
      state.setHistoryDuration();
      state.normalizeTimeframes();
      state.adjustTimeRecords('speaking'); // move timing of speaking records back by 1/10th of a second since they lag
      state.setupForReset();
    },

    deleteTrackingArrays: () => {
      // console.log('finalizeHistory: deleting Tracking arrays');
      delete(state.history.cellContentsTracking);
      delete(state.history.cellOutputsTracking);
    },

    getJSONHistory: () => {
      let jsonHistory;
      try {
        jsonHistory = JSON.stringify(state.history);
        return jsonHistory;
      } catch(ex) {
        return undefined;
      }
    },

    getHistoryDuration: () => {
      return state.history.duration;
    },

    setHistoryDuration: () => {
      state.history.duration = utils.getNow() - state.history.recordingStartTime;
    },

    adjustTimeRecords: (type) => {
      const historyArray = state.history[type];
      const adjustment = 100; // ms
      if (historyArray.length > 0) {
        for (let i = 0; i < historyArray.length; ++i) {
          historyArray[i].startTime = Math.max(0, historyArray[i].startTime - adjustment);
          historyArray[i].endTime = Math.max(0, historyArray[i].endTime - adjustment);
        }
      }
    },

    findSpeakingStartNearestTime: (t, direction, rewindAmt) => {
      let historyItem, numHistoryItems = 0;
      // Scan for nearest "start speaking" record ...
      let chosenTime = (direction === -1 ? 0 : state.history.duration);
      if (state.history['speaking'] !== undefined) {
        numHistoryItems = state.history['speaking'].length;
      }
      if (numHistoryItems === 0) {
        // no speaking history, just jump by 2s
        if (direction === -1) {
          chosenTime= Math.max(0, t - rewindAmt * 1000);
        } else {
          chosenTime = Math.min(t + rewindAmt * 1000, state.history.duration - 1);
        }
      } else {
        for (let check = 0; check < numHistoryItems; ++check) {
          //console.log('findSpeakingStartNearestTime, check:', check);
          historyItem = state.history['speaking'][check];
          if (historyItem.speaking) {
            if (direction === -1) {
              if (historyItem.startTime > chosenTime && historyItem.endTime < t) {
                chosenTime = historyItem.startTime;
              }
            } else {
              if (historyItem.startTime < chosenTime && historyItem.startTime > t) {
                chosenTime = historyItem.startTime;
              }
            }
          }
        }
      }
      return chosenTime; 
    },

    // When recording finishes, normalize all time frames
    normalizeTimeframes: () => {
      const recordingStartTime = state.history.recordingStartTime;
      const now = utils.getNow();
      for (let arrName of state.frameArrays) {
        let historyArray = state.history[arrName];
        let max = historyArray.length - 1;
        for (let i = 0; i < historyArray.length; ++i) {
          // Only set endTime when not set by some other process (e.g. skipRecs set this on their own).
          if (historyArray[i].endTime === undefined) {
            if ((historyArray.length === 1) || (i === max)) { 
              historyArray[i].endTime = now;
            } else {
              historyArray[i].endTime = historyArray[i+1].startTime;
            }
          }
          historyArray[i].startTime = historyArray[i].startTime - recordingStartTime;
          historyArray[i].endTime = historyArray[i].endTime - recordingStartTime;
        }
        // console.log('normalized ', historyArray.length, 'records for array', arrName);
      }
    },

    // Get all history record frame types straddling a given time. If given time < time of first record or > time of last record, return undefined.
    getHistoryRecordsAtTime: (t) => {
      let indexes = {}, frame, historyArray, arrName, scanPtr, scanDir, currentFrameIndex, previousFrameIndex, numRecords, skipped = {};
      const historyDuration = state.getHistoryDuration();
      const halfHistory = historyDuration / 2;
      for (arrName of state.frameArrays) {
        skipped[arrName] = -1;
        historyArray = state.history[arrName];
        if (historyArray !== undefined) {
          numRecords = historyArray.length;
          currentFrameIndex = state.history.lastVisited[arrName];
          indexes[arrName] = undefined;
          if (historyArray.length > 0) {
            // Only do a scan if the time is within the band of recorded history. E.g. there may only be drawing
            // history in the middle of all recorded time so don't look for records if you're outside that band.
            if ((t >= historyArray[0].startTime) || (t <= historyArray[historyArray.length - 1].endTime)) {
              previousFrameIndex = currentFrameIndex;
              frame = historyArray[currentFrameIndex];
              if ((t >= frame.startTime) && (t < frame.endTime)) {
                // We're already in the right frame so just return that
                indexes[arrName] = { index: currentFrameIndex, rangeStart: undefined };
              } else {
                // if the distance between the start time of the current frame and t is
                // < 10% of the total duration, start scanning up or
                // down from the current frame until you find the right frame.
                const tDist = t - frame.startTime;
                const tDistAbs = Math.abs(tDist);
                if ((tDistAbs / historyDuration) < 0.1) {
                  scanDir = Math.sign(tDist);
                  scanPtr = currentFrameIndex + scanDir;
                } else {
                  // Scan to find the frame:
                  //  from the beginning of the recording if the time is in the first half of the recording,
                  //  otherwise scan backwards from the end
                  if (t < halfHistory) {
                    scanPtr = 0;
                    scanDir = 1;
                  } else {
                    scanPtr = numRecords - 1;
                    scanDir = -1;
                  }
                }
                // Now scan to find the right frame by looking for t within the time frame.
                while ((scanPtr >= 0) && (scanPtr < numRecords)) {
                  frame = historyArray[scanPtr];
                  if ((t >= frame.startTime) && (t < frame.endTime)) {
                    indexes[arrName] = { index: scanPtr, rangeStart: undefined };
                    state.history.lastVisited[arrName] = scanPtr;
                    break;
                  }
                  scanPtr += scanDir;
                  skipped[arrName]++;
                }
                if ((indexes[arrName] !== undefined) && (indexes[arrName].index !== previousFrameIndex) && (indexes[arrName].index > previousFrameIndex)) {
                  // If we skipped forward a bunch of records to catch up with real time, remember how far we skipped. 
                  // This is needed to make sure we (re)draw everything we recorded during the time that was skipped over.
                  // Time skipping happens because browser animationFrame timing isn't that reliable, so to avoid desynching
                  // with the audio track, we sometimes need to skip records.
                  indexes[arrName].rangeStart = previousFrameIndex + 1;
                }                
              }
            }
          }
        }
      }
      //console.log('getHistoryRecordsAtTime:, t=', t, 'records skipped:', skipped, 'indexes[drawings]:', indexes['drawings']);
      return(indexes);
    },

    // Get index of record just before or at the specified time. Used for scrubbing/redrawing drawings/stickers.
    getIndexUpToTime: (kind, t) => {
      let i;
      const historyArray = state.history[kind];
      if (historyArray !== undefined) {
        const historyArrayLength = historyArray.length;
        if (historyArrayLength > 0) {
          for (i = 0; i < historyArrayLength; ++i) {
            if (historyArray[i].startTime >= t) {
              return i;
            }
          }
          // check to see if time is on or past the last known record.
          i = historyArray.length - 1;
          if (((historyArray[i].startTime < t) && (historyArray[i].endTime >= t)) ||
              (historyArray[i].endTime < t)) {
            return i;
          }
        }
      }
      return undefined;
    },

    getLastFrameIndex: (kind) => {
      return state.history[kind].length;
    },

    getHistoryItem: (kind, index) => {
      if ((index < state.history[kind].length) && (index >= 0)) {
        return state.history[kind][index];
      }
      return undefined;
    },

    setHistory: (history) => {
      state.history = $.extend({}, history);
      state.resetPlayState();
      state.resetProcessedArrays();
    },

    getFromMovieCache: (kind, keys) => {
      const combinedKey = [keys.recordingCellId, keys.recordingKey, keys.activeTakeId].join('_');
      return state.movieCache[kind][combinedKey];
    },

    storeToMovieCache: (kind, keys, data) => {
      const combinedKey = [keys.recordingCellId, keys.recordingKey, keys.activeTakeId].join('_');
      state.movieCache[kind][combinedKey] = data;
    },

                   
    getTimeRecordedSoFar: () => {
      return utils.getNow() - state.history.recordingStartTime;
    },

    // The time played so far is the sum of all the play times at various speeds used so far during this play session, including the (growing) time
    // at the current playSpeed.
    getTimePlayedSoFar: () => {
      const now = utils.getNow();
      let timePlayedSoFar = 0;
      if ((state.playTimes[state.currentPlaySpeed].start !== undefined) && (state.activity === 'playing')) {
        const playRateScalar = state.getPlayRateScalar();
        timePlayedSoFar += (now - state.playTimes[state.currentPlaySpeed].start) * playRateScalar;
      }
      for (let type of Object.keys(state.playSpeeds)) {
        timePlayedSoFar += state.playTimes[type].total * state.playSpeeds[type];
      }
      return timePlayedSoFar;
    },

    // If the current recording is set to replayAllCells, or this cell is among those affected by the history, return true
    graffitiShouldUpdateCellContents: (cellId) => {
      return (state.shouldUpdateCellContentsDuringPlayback || state.history.affectedCellIds.hasOwnProperty(cellId));
    },

    storeCellStates: () => {
      state.cellsAffectedByActivity = {};
      state.terminalsAffectedByActivity = [];
      const cells = Jupyter.notebook.get_cells();
      state.cellStates = {
        contents: state.createContentsRecord(false),
        selections: state.createSelectionsRecord(),
        changedCells: {},
        lineNumberStates: {},
      };
      for (let i = 0, cell; i < cells.length; ++i) {
        cell = cells[i];
        state.cellStates.lineNumberStates[utils.getMetadataCellId(cell.metadata)] = cell.code_mirror.options.lineNumbers;
      }
    },

    storeCellIdAffectedByActivity: (cellId) => {
      if (state.activity !== 'playing' && state.activity !== 'recording')
        return;

      //console.log('storeCellIdAffectedByActivity, logging cell: ' + cellId);
      state.cellStates.changedCells[cellId] = true;
    },

    restoreCellOutputs: (cell, frameOutputs) => {
      const cellId = utils.getMetadataCellId(cell.metadata);
      if (frameOutputs === undefined)
        return false; // no output found, so don't update DOM (e.g. markdown cell)
      if (state.cellOutputsSent[cellId] !== undefined) {
        if (state.cellOutputsSent[cellId] === frameOutputs) {
          // no change to cell output, so don't rerender
          return false;
        }
      }
      const cellDom = $(cell.element);
      const outputArea = cellDom.find('.output');
      //console.log('Sending this output to cellid:', cellId, frameOutputs);
      outputArea.html(frameOutputs).show();
      state.cellOutputsSent[cellId] = frameOutputs;
      return true;
    },

    restoreCellStates: (which) => {
      const affectedIds = Object.keys(state.cellStates.changedCells);
      let selections,cellContents,cellOutputs;
      if (affectedIds.length > 0) {
        let cell, cellState, cellsContent, contentsRecord;
        for (let cellId of affectedIds) {
          // console.log('affectedid:', cellId);
          cell = utils.findCellByCellId(cellId);
          if (cell !== undefined) {
            selections = state.cellStates.selections.cellsSelections[cellId];
            if (which === 'contents') {
              cellsContent = state.cellStates.contents.cellsContent[cellId];
              if (cellsContent !== undefined) {
                contentsRecord = cellsContent.contentsRecord;
                cellContents = state.extractDataFromContentRecord(contentsRecord, cellId);
                if (cellContents !== undefined) {
                  cell.set_text(contentsRecord.data);
                }
                if (typeof(cell.clear_output) === 'function') {
                  cell.clear_output();
                  cellOutputs = state.extractDataFromContentRecord(cellsContent.outputsRecord, cellId);
                  state.restoreCellOutputs(cell, cellOutputs);
                }
              }
            } else { // restoring selections
              if (selections !== undefined) {
                if ((cell.cell_type === 'code') && (selections.active)) { // hack, not coded right
                  cell.code_mirror.focus();
                }
                // console.log('setting selection to :', selections.selections);
                cell.code_mirror.setSelections(selections.selections);
              }
            }
          }
        }
      }
    },

    restoreLineNumbersStates: () => {
      if (state.hasOwnProperty('cellStates')) {
        if (state.cellStates.hasOwnProperty('lineNumberStates')) {
          if (Object.keys(state.cellStates.lineNumberStates).length > 0) {
            let cell;
            for (let cellId of Object.keys(state.cellStates.lineNumberStates)) {
              cell = utils.findCellByCellId(cellId);
              if (cell !== undefined) {
                if (cell.code_mirror.options.lineNumbers != state.cellStates.lineNumberStates[cellId]) {
                  cell.toggle_line_numbers();
                }
              }
            }
          }
        }
      }
    },

    getScrollTop: () => {
      return state.scrollTop;
    },

    setScrollTop: (scrollTop) => {
      state.scrollTop = scrollTop;
    },

  }

  return(state);

});

// From: https://github.com/muaz-khan/WebRTC-Experiment/blob/master/hark/hark.js
// original source code is taken from:
// https://github.com/SimpleWebRTC/hark
// copyright goes to &yet team
// edited by Muaz Khan for RTCMultiConnection.js
define('js/hark.js',[], function () {
  const hark = {

    running: false,

    getMaxVolume: (analyser, fftBins) => {
      let maxVolume = -Infinity;
      analyser.getFloatFrequencyData(fftBins);

      for (let i = 4, ii = fftBins.length; i < ii; i++) {
        if (fftBins[i] > maxVolume && fftBins[i] < 0) {
          maxVolume = fftBins[i];
        }
      }

      return maxVolume;
    },

    on: (event, callback) => {
      hark.events[event] = callback;
    },

    emit: (arg1,arg2,arg3,arg4) => {
      if (hark.events[arg1]) {
        hark.events[arg1](arg2,arg3,arg4);
      }
    },

    looper: () => {
      let interval = (hark.speaking ? hark.talkingInterval : hark.silenceInterval);
      setTimeout( () => {

        //check if stop has been called
        if (!hark.running) {
          return;
        }

        let currentVolume = hark.getMaxVolume(hark.analyser, hark.fftBins);
        hark.emit('volume_change', currentVolume, hark.threshold);

        let history = 0;
        if (currentVolume > hark.threshold && !hark.speaking) {
          // trigger quickly, short history
          for (let i = hark.speakingHistory.length - 3; i < hark.speakingHistory.length; i++) {
            history += hark.speakingHistory[i];
          }
          if (history >= 2) {
            hark.speaking = true;
            hark.emit('speaking');
          }
        } else if (currentVolume < hark.threshold && hark.speaking) {
          for (let j = 0; j < hark.speakingHistory.length; j++) {
            history += hark.speakingHistory[j];
          }
          if (history === 0) {
            hark.speaking = false;
            hark.emit('stopped_speaking');
          }
        }
        hark.speakingHistory.shift();
        hark.speakingHistory.push(0 + (currentVolume > hark.threshold));

        hark.looper();
      }, interval);
    },

    setThreshold: (t) => {
      hark.threshold = t;
    },

    setIntervals: (silenceInterval, talkingInterval) => {
      //console.trace('Called from here:');
      hark.silenceInterval = silenceInterval;
      hark.talkingInterval = talkingInterval;
    },

    // Poll the analyser node to determine if speaking
    // and emit events if changed
    start: () => {
      hark.running = true;
      hark.looper();
    },

    stop:  () => {
      hark.running = false;
      hark.emit('volume_change', -100, hark.threshold);
      if (hark.speaking) {
        hark.speaking = false;
        hark.emit('stopped_speaking');
      }
    },

    init: (stream, options) => {
      const audioContextType = window.webkitAudioContext || window.AudioContext;

      hark.events = {};

      // make it not break in non-supported browsers
      if (!audioContextType) return hark;

      options = options || {};
      // Config
      const smoothing = (options.smoothing || 0.1);

      hark.play = options.play;
      hark.historySize = options.historySize || 10;
      hark.silenceInterval = (options.silenceInterval || 10);
      hark.talkingInterval = (options.talkingInterval || 100);
      hark.threshold = options.threshold || -50;

      // Setup Audio Context
      if (!window.audioContext00) {
        window.audioContext00 = new audioContextType();
      }

      const gainNode = audioContext00.createGain();
      gainNode.connect(audioContext00.destination);
      // don't play for self
      gainNode.gain.value = 0;

      hark.analyser = audioContext00.createAnalyser();
      hark.analyser.fftSize = 512;
      hark.analyser.smoothingTimeConstant = smoothing;
      hark.fftBins = new Float32Array(hark.analyser.fftSize);

      //WebRTC Stream
      const sourceNode = audioContext00.createMediaStreamSource(stream);

      sourceNode.connect(hark.analyser);

      if (hark.play) hark.analyser.connect(audioContext00.destination);

      hark.speaking = false;

      hark.speakingHistory = [];
      for (let i = 0; i < hark.historySize; i++) {
        hark.speakingHistory.push(0);
      }
    }
  };

  return hark;

});

define('js/audio.js',[
  'js/state.js',
  'js/hark.js',
], function (state,hark) {

  const audio = {

    init: (cbs) => {
      console.log('Graffiti audio constructor.');
      audio.executeCallback = true; // by default always execute the storage callback

      // fork getUserMedia for multiple browser versions, for the future
      // when more browsers support MediaRecorder
      navigator.getUserMedia = ( navigator.getUserMedia ||
                                 navigator.webkitGetUserMedia ||
                                 navigator.mozGetUserMedia ||
                                 navigator.msGetUserMedia);
      if (navigator.getUserMedia) {
        //console.log('getUserMedia supported.');
        navigator.getUserMedia (
          { // constraints - only audio needed for this app
            audio: true,
            mimeType: 'audio/wav',
          },
          // Success callback
          function(stream) {
            const mediaRecorder = new MediaRecorder(stream);
      	    mediaRecorder.ondataavailable = audio.saveRecordedAudio;
            audio.storeMediaRecorder(mediaRecorder);
            cbs.succeed();

            hark.init(stream, { threshold:-65 });
            hark.on('speaking', () => { 
              state.setSpeakingStatus(true);
              // console.log('Graffiti: speaking started');
            });
            hark.on('stopped_speaking', () => { 
              state.setSpeakingStatus(false);
              // console.log('Graffiti: speaking ended');
            });
            //hark.on('volume_change', (currentVolume, threshold) => { console.log('volume change,', currentVolume, threshold) });
            
          },

          // Error callback
          function(err) {
            console.log('Graffiti: The following getUserMedia error occured: ' + err);
            cbs.fail();
          }
        )
      } else {
        console.log('Graffiti: getUserMedia not supported on your browser!');
      }
    },

    storeMediaRecorder: (mediaRecorder) => {
      audio.mediaRecorder = mediaRecorder;
      console.log('Graffiti: Media recorder ready and stored.');
      return true;
    },
    
    isAvailable: () => {
      return (audio.mediaRecorder !== undefined);
    },

    storeAudio: (audioObj) => {
      audio.audioObj = audioObj;
    },

    updateAudioPlaybackRate: () => {
      const scalar = state.getPlayRateScalar();
      //const scalar = (rawScalar === 1.0 ? rawScalar : rawScalar * 0.85);
      //console.log('updateAudioPlaybackRate, scalar:', scalar);
      audio.audioObj.playbackRate = scalar;
    },

    // Special thanks to: https://developers.google.com/web/updates/2017/06/play-request-was-interrupted 
    // for handling of weird "play was interrupted" chrome exception.
    playAudio: (elapsedTime) => {
      audio.setAudioPosition(elapsedTime);
      audio.updateAudioPlaybackRate();
      let playPromise = audio.audioObj.play();
      if (playPromise !== undefined) {
        playPromise.then(_ => {
          audio.playBeganOK = true;
        })
        .catch(error => {
          audio.playBeganOK = false;
          console.log('Graffiti: audio error:', error);
        });
      }
    },

    pauseAudio: () => {
      if (audio.playBeganOK) {
        audio.audioObj.pause();
      } else {
        console.log('Graffiti: cannot pause audio because audio playback did not begin successfully.');
        // Try again in one second if we fail. Sometimes there's a race condition if audio is stopped really quickly after it begins
        setTimeout(() => {
          if (audio.playBeganOK) {
            audio.audioObj.pause();
          }
        }, 1000);
      }
    },

    // Set time of audio clip, cf:
    // http://stackoverflow.com/questions/9563887/setting-html5-audio-position
    setAudioPosition: (elapsedTime) => {
      audio.audioObj.currentTime = elapsedTime / 1000; // note that we keep elapsed time in ms, but the MSDN API wants currentTime in seconds
    },

    storeRecordedAudio: (base64String) => {
      // console.log('storing audio base64String :', base64String);
      audio.recordedAudioString = base64String;
    },

    getRecordedAudio: () => {
      return(audio.recordedAudioString || '');
    },

    setRecordedAudio: (b64String) => {
      //console.log('Fetching from ', b64String);
      const labeledAudio = 'data:video/webm;base64,' + b64String;
      const audioObj = new Audio(labeledAudio);
      audioObj.load();
      audio.storeAudio(audioObj);

      // An attempt to get sound to play in safari. Unfortunately chrome is recording using encoding type Opus
      // which safari does not accept. So we need to additionally convert the recording to mp3 or wav
      // before safari can play it.
      /*
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createBufferSource();
      const binaryAudioBlob = audio.b64toBlob(b64String);
      const reader = new FileReader();
      reader.addEventListener("loadend", function() {
        const bufferArray = reader.result;
        audioCtx.decodeAudioData(bufferArray, (buffer) => {
          source.buffer = buffer;
          source.connect(audioCtx.destination);
          source.start(0);
          console.log('started audio from blob');
        }, function(e){ console.log("Error with decoding audio data" + e); });
      });
      reader.readAsArrayBuffer(binaryAudioBlob);
      */

    },

    setAudioStorageCallback: (cb) => {
      audio.audioStorageCallback = cb;
    },

    startRecording: () => {
      if (audio.mediaRecorder !== undefined) {
        audio.mediaRecorder.start();
        hark.start(); // start checking for silences
        console.log('Graffiti:', audio.mediaRecorder.state);
        console.log("Graffiti: Audio recording started");
      } else {
        console.log('Graffiti: Audio recording cannot start, access not granted.');
      }
    },

    stopRecording: () => {
      if (audio.mediaRecorder !== undefined) {
        audio.mediaRecorder.stop();
        hark.stop(); // stop checking for silences
        console.log("Graffiti: Audio recording stopped");
      } else {
        console.log('Graffiti: Audio recording cannot stop, access not granted.');
      }
    },

    startPlayback: (elapsedTime) => {
      audio.playAudio(elapsedTime);
    },

    pausePlayback: () => {
      audio.pauseAudio();
    },

    setExecuteCallback: (value) => {
      audio.executeCallback = value;
    },

    saveRecordedAudio: (e) => {
      //console.log("Audio data available");

      // console.log('Graffiti: Audio data:', e.data);
      const reader = new FileReader();
      reader.addEventListener("loadend", function() {
        // reader.result contains the contents of blob as a typed array
        let bufferArray = reader.result;
        // From: https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
        // For going backwards, use https://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript and note comment about ie10
        let base64String = btoa([].reduce.call(new Uint8Array(bufferArray),function(p,c){return p+String.fromCharCode(c)},''));
        //console.log(base64String);
        audio.storeRecordedAudio(base64String);
        if (audio.executeCallback) {
          // This callback is actually: storage:storeMovie().
          audio.audioStorageCallback();
        }
      });
      reader.readAsArrayBuffer(e.data);

      const audioUrl = window.URL.createObjectURL(e.data);
      // This works so nice and simple. From: http://stackoverflow.com/questions/33755524/how-to-load-audio-completely-before-playing (first answer)
      const audioObj = new Audio (audioUrl);
      audioObj.load();

      // Set time of clip for scrubbing: 
      // http://stackoverflow.com/questions/9563887/setting-html5-audio-position

      audio.storeAudio(audioObj);
    },

    b64toBlob: (b64Data, contentType, sliceSize) => {
      contentType = contentType || '';
      sliceSize = sliceSize || 512;

      const byteCharacters = atob(b64Data);
      const byteArrays = [];

      for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        const slice = byteCharacters.slice(offset, offset + sliceSize);

        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
          byteNumbers[i] = slice.charCodeAt(i);
        }

        const byteArray = new Uint8Array(byteNumbers);

        byteArrays.push(byteArray);
      }

      const blob = new Blob(byteArrays, {type: contentType});
      return blob;
    },

  }
        
  return(audio);

});


// Adapted from: https://stackoverflow.com/a/40850909/2767287
define('js/batchRunner.js',[
  'js/state.js',
], function (state) {
  const batchRunner = {

    // Output function for debugging
    output: (ostr) => {
      //console.log(ostr);
    },

    // Main batch parallelization function.
    batch: (pstart, atonce, pos) => {
      if (pos >= batchRunner.data.length) return pstart;
      const p = pstart.then(function() {
        const batchNum = (pos / atonce) + 1;
        batchRunner.output('Graffiti: batchRunner running batch ' + batchNum);
        return Promise.all(batchRunner.data.slice(pos, pos + atonce).map(function(data) {
          return batchRunner.runner(data);
        }));
      });
      return batchRunner.batch(p, atonce, pos + atonce);
    },


    /*
     * Note: callback should return a promise.
     */
    runner: (data) => {
      return batchRunner.callback(data);
    },

    start: (batchSize, callback, data) => {
      batchRunner.data = data;
      batchRunner.callback = callback;
      const init = batchRunner.batch(Promise.resolve(),             // starting promise
                                     batchSize,                     // batch size
                                     0);                            // initial position into the data array
      return init;
    }
  }

  return batchRunner;
  
});

  

define('js/storage.js',[
  'js/state.js',
  'js/audio.js',
  'js/utils.js',
  'js/batchRunner.js',
  'js/LZString.js'
], function (state, audio, utils, batchRunner, LZString) {

  //
  // Storage tree is organized like this:
  //
  // jupytergraffiti_data/
  //   notebooks/
  //     id_1234/
  //       authors/
  //        id_1234 (creator)/
  //          manifest.json
  //          cells/
  //            id_1234/
  //               graffitis/
  //                 id_1234/
  //                   takes/
  //                     id_1234/
  //                       audio.txt
  //                       history.txt  
  // Inside the notebook's graffiti metadata, firstAuthorId records the author id of the creator of the very first graffiti in this notebook.
  // For notebooks created at Udacity, these are usually graffiti created by instructors and we use a Udacity id. Otherwise we use a randomly generated id. 

  const storage = {

    defaultKernel: 'python3',
    executorCell: undefined,
    movieCompleteCallback: undefined,
    preloadBatchSize: 4,

    createExecutorCell: () => {
      if (storage.executorCell === undefined) {
        storage.executorCell = Jupyter.notebook.insert_cell_at_bottom('code');
        state.storePreviousActivity();
        state.setActivity('executing');
      }
      return storage.executorCell;
    },

    runShellCommand: (cmd) => {
      const executorCell = storage.createExecutorCell();
      const currentKernelName = Jupyter.notebook.kernel.name;
      let fullCommand;
      if (currentKernelName === utils.rKernel) {
        // R doesn't support magics so we use internal R system() call.
        // This needs to escape double quotes eventually... 
        fullCommand = "system('" + cmd + "', intern=TRUE)";
      } else {
        fullCommand = '!' + cmd;
      }
      executorCell.set_text(fullCommand);
      executorCell.execute();
    },

    writeTextToFile: (opts) => {
      const path = opts.path;
      const contents = opts.contents;
      const executorCell = storage.createExecutorCell();
      const currentKernelName = Jupyter.notebook.kernel.name;
      let writeMagic, chunkSize;
      switch (currentKernelName) {
        case utils.cplusplusKernel11:
        case utils.cplusplusKernel14:
        case utils.cplusplusKernel17:
          writeMagic = '%%file';
          chunkSize = 7000;
          break;
        case utils.pythonKernel:
          writeMagic = '%%writefile';
          chunkSize = 100000;
          break;
        case utils.rKernel:
          break;
      }
      const contentLength = contents.length;
      let chunkPtr = 0, chunk, appendFlag, cmd, rLines = [];
      const pathWithCrs = path + '.cr';
      while (chunkPtr < contentLength) {
        chunk = contents.substr(chunkPtr, chunkSize);
        appendFlag = (chunkPtr === 0 ? ' ' : ' -a ');
        if (currentKernelName === utils.rKernel) {
          // We don't write in this loop if using the R Kernel, we just collect and write with a single command, below
          rLines.push('"' + chunk + '"');
        } else {
          cmd = writeMagic + appendFlag + pathWithCrs + "\n" + chunk;
          executorCell.set_text(cmd);
          executorCell.execute();
        }
        chunkPtr += chunkSize;
      }

      if (currentKernelName === utils.rKernel) {
        // Now write it all out in one fell swoop, cf: https://stackoverflow.com/questions/2470248/write-lines-of-text-to-a-file-in-r
        cmd = 'writeLines(c(' + rLines.join(',') + '), "' + pathWithCrs + '")';
        executorCell.set_text(cmd);
        executorCell.execute();
      }

      if (opts.stripCRs) {
        cmd = '/usr/bin/tr -d "\\n" < ' + pathWithCrs + ' > ' + path; // remove all the CR's produced by the %%writefile appends and write to the final filename
      } else {
        cmd = 'mv ' + pathWithCrs + ' ' + path; // just rename the .cr file with the final file name
      }        
      storage.runShellCommand(cmd);
      cmd = 'rm ' + pathWithCrs;
      storage.runShellCommand(cmd);
    },

    cleanUpExecutorCell: () => {
      const executorCell = storage.createExecutorCell();
      if (executorCell !== undefined) {
        const executorCellId = utils.getMetadataCellId(executorCell.metadata);
        const deleteCellIndex = utils.findCellIndexByCellId(executorCellId);
        if (deleteCellIndex !== undefined) {
          Jupyter.notebook.delete_cell(deleteCellIndex);
        }
        storage.executorCell = undefined;
        state.restorePreviousActivity();
        utils.saveNotebook();
      }        
    },

    setMovieCompleteCallback: (cb) => {
      storage.movieCompleteCallback = cb;
    },

    executeMovieCompleteCallback: () => {
      if (storage.movieCompleteCallback !== undefined) {
        storage.movieCompleteCallback();
        storage.movieCompleteCallback = undefined;
      }
    },

    ensureNotebookGetsGraffitiId: () => {
      // Make sure a new notebook gets a recording id
      const notebook = Jupyter.notebook;
      if (!notebook.metadata.hasOwnProperty('graffiti')) {
        notebook.metadata['graffiti'] = { 
          id: utils.generateUniqueId(),
          language: 'EN' // defaults to EN but can be changed by the author for their preferred locale, by editing the notebook's metadata
        }
      }
      utils.assignCellIds();
      utils.refreshCellMaps();
      console.log('Graffiti: Notebook is now ready to use Graffiti.');
    },

    ensureNotebookGetsFirstAuthorId: () => {
      // Make sure a new notebook gets a first author id, from whatever auth system is in use.
      const notebook = Jupyter.notebook;
      let metadata = notebook.metadata;
      let firstAuthorId;
      if (!metadata.hasOwnProperty('graffiti')) {
        storage.ensureNotebookGetsGraffitiId();
      }
      if (!metadata.graffiti.hasOwnProperty('firstAuthorId')) {
        firstAuthorId = state.getUserId();
        metadata.graffiti.firstAuthorId = firstAuthorId;
        state.setAuthorId(firstAuthorId);
      } else {
        firstAuthorId = metadata.graffiti.firstAuthorId;
      }

      return firstAuthorId;
    },

    constructBasePath: () => {
      const notebook = Jupyter.notebook;
      if (!notebook.metadata.hasOwnProperty('graffiti')) {
        storage.ensureNotebookGetsGraffitiId();
      }
      // hardwired to only load author recordings for now
      const basePath = 'jupytergraffiti_data/notebooks/' + notebook.metadata.graffiti.id + '/authors/' + state.getAuthorId() + '/';
      return basePath;
    },

    constructManifestPath: () => {
      const basePath = storage.constructBasePath();
      return { path: basePath, file: 'manifest.json' };
    },

    constructGraffitiMoviePath: (pathParts) => {
      const basePath = storage.constructBasePath();
      const graffitiPath = basePath + 
                           'cells/' + pathParts.recordingCellId + '/' + 
                           'graffitis/' + pathParts.recordingKey + '/';
      return graffitiPath;
    },

    constructGraffitiTakePath: (pathParts) => {
      let graffitiPath = storage.constructGraffitiMoviePath(pathParts) + 'takes/' + pathParts.takeId + '/';
      return graffitiPath;
    },

    completeMovieStorage: () => {
      const recordingCellInfo = state.getRecordingCellInfo();
      const recording = state.getManifestSingleRecording(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey);
      const hasMovie = state.getMovieRecordingStarted();
      // recording is a pointer into the live manifest hash, so beware that we are modifying state directly when changing it.
      if (recording !== undefined) {
        recording.inProgress = false;
        recording.hasMovie = hasMovie;
      }
      if (hasMovie) {
        // Store the latest take information in the current take for this recording.
        recording.activeTakeId = recordingCellInfo.recordingRecord.activeTakeId;
        if (!recording.hasOwnProperty('takes')) {
          recording.takes = {};
        }
        recording.takes[recording.activeTakeId] = { 
          duration: state.getHistoryDuration(),
          createDate: utils.getNow()
        };
      }
      state.setMovieRecordingStarted(false);
      console.log('Graffiti: completeMovieStorage is saving manifest for recording:', recording, ', current kernel', Jupyter.notebook.kernel.name);
      storage.storeManifest();
      utils.saveNotebook(() => {
        storage.executeMovieCompleteCallback();
      });
    },

    writeOutMovieData: (movieInfo, jsonHistory, encodedAudio) => {
      //console.log('writeOutMovieData, movieInfo:', movieInfo, 'history:', jsonHistory);
      const graffitiPath = storage.constructGraffitiTakePath({
        recordingCellId: movieInfo.recordingCellId,
        recordingKey:    movieInfo.recordingKey,
        takeId:          movieInfo.activeTakeId
      });

      storage.runShellCommand('mkdir -p ' + graffitiPath);
      if (encodedAudio !== undefined) {
        storage.writeTextToFile({ path: graffitiPath + 'audio.txt', 
                                  contents: encodedAudio,
                                  stripCRs: true });
      }
      if (jsonHistory !== undefined) {
        const base64CompressedHistory = LZString.compressToBase64(jsonHistory);
        storage.writeTextToFile({ path: graffitiPath + 'history.txt', 
                                  contents: base64CompressedHistory,
                                  stripCRs: true });
      }
      storage.cleanUpExecutorCell(graffitiPath);
      return Promise.resolve();
    },

    storeMovie: () => {
      const recordingCellInfo = state.getRecordingCellInfo();

      const notebook = Jupyter.notebook;
      const jsonHistory = state.getJSONHistory();
      if (jsonHistory !== undefined) {
        //console.log(jsonHistory);
        const encodedAudio = audio.getRecordedAudio();
        const keys = {
          recordingCellId: recordingCellInfo.recordingCellId,
          recordingKey: recordingCellInfo.recordingKey,
          activeTakeId: recordingCellInfo.recordingRecord.activeTakeId
        };
        storage.writeOutMovieData(
          keys,
          jsonHistory, 
          encodedAudio).then(() => {
            storage.completeMovieStorage();
          });
      } else {
        console.log('Graffiti: could not fetch JSON history.');
      }
    },

    // Load the manifest for this notebook.
    // Manifests contain information about all the recordings present in this notebook.
    // This version of the system only supports author manifests.
    loadManifest: (currentAccessLevel) => {
      const notebook = Jupyter.notebook;
      if (!notebook.metadata.hasOwnProperty('graffiti')) {
        if (currentAccessLevel !== 'create') {
          console.log('Graffiti: loadManifest is bailing early because we are not in "create" mode and this notebook has no graffiti id.');
          return Promise.reject();
        } else {
          storage.ensureNotebookGetsGraffitiId();
        }
      }
      const authorId = storage.ensureNotebookGetsFirstAuthorId();
      state.setAuthorId(authorId);

      const credentials = { credentials: 'include' };
      const manifestInfo = storage.constructManifestPath();
      console.log('Graffiti: Loading manifest from:', manifestInfo);
      const manifestFullFilePath = manifestInfo.path + manifestInfo.file;
      return fetch(manifestFullFilePath, credentials).then((response) => {
        if (!response.ok) {
          // We could not fetch for some reason (maybe manifest file doesn't exist) so initialize an empty manifest
          return(undefined);
        }
        return response.text();
      }).then((base64Str) => {
        if (base64Str === undefined) {
          state.setManifest({});
        } else {
          const uncompressedManifestString = LZString.decompressFromBase64(base64Str);
          //console.log('uncompressed manifest:', uncompressedManifestString);
          const manifestDataParsed = JSON.parse(uncompressedManifestString);
          state.setManifest(manifestDataParsed);
          //console.log('Graffiti Manifest:', manifestDataParsed['id_iermcbu']);
        }
      });
    },

    updateSingleManifestRecordingField: (recordingCellId, recordingKey, field, data) => {
      const recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
      recording[field] = data;
      storage.storeManifest();
    },

    storeManifest: () => {
      const manifest = state.getManifest();
      const manifestInfo = storage.constructManifestPath();
      const base64CompressedManifest = LZString.compressToBase64(JSON.stringify(manifest));
      const manifestFullFilePath = manifestInfo.path + manifestInfo.file;
      console.log('Graffiti: Saving manifest to:', manifestFullFilePath, manifest);
      
      storage.runShellCommand('mkdir -p ' + manifestInfo.path);
      storage.writeTextToFile({ path: manifestFullFilePath, 
                                contents: base64CompressedManifest,
                                stripCRs: true });
      storage.cleanUpExecutorCell();
    },

    // Compute the ids of any cells affected during this recording.
    computeAffectedCells: (history) => {
      history.affectedCellIds = {};
      let i, viewRec, drawingRec;

      for (i = 1; i < history.contents.length; ++i) {
        Object.keys(history.contents[i]).map((key) => { 
          if (history.contents[i][key].data !== undefined) {
            history.affectedCellIds[key] = true 
          }
        });
      }
      history.view.map((viewRec) => {
        if ((viewRec.subType === 'focus') || (viewRec.subType === 'innerScroll')) {
          history.affectedCellIds[viewRec.cellId] = true;
        } else if (viewRec.subType === 'selectCell') {
          history.affectedCellIds[viewRec.selectedCellId] = true;
        }
      });
      history.drawings.map((drawRec) => {
        history.affectedCellIds[drawRec.cellId] = true;
      });
      Object.keys(history.cellAdditions).map((key) => {
        history.affectedCellIds[key] = true;
      });
    },

    //
    // Fetch a movie and store it into the movies cache in state.
    // Returns a promise.
    //
    fetchMovie: (data) => {
      const notebookRecordingId = Jupyter.notebook.metadata.graffiti.id;
      const graffitiPath = storage.constructGraffitiTakePath( {
        recordingCellId: data.recordingCellId,
        recordingKey: data.recordingKey,
        takeId: data.activeTakeId,
      });
      const credentials = { credentials: 'include'};
      storage.successfulLoad = false; /* assume we cannot fetch this recording ok */
      // console.log('Graffiti: storage is loading movie from path:', graffitiPath);
      const historyUrl = graffitiPath + 'history.txt';
      return fetch(historyUrl, credentials).then((response) => {
        if (!response.ok) {
          throw Error(response.statusText);
        }
        return response.text();
      }).then(function(base64CompressedHistory) {
        try {
          //console.log('Loaded history:', base64CompressedHistory);
          const uncompressedHistory = LZString.decompressFromBase64(base64CompressedHistory);
          //console.log('uncompressedHistory:', uncompressedHistory);
          const parsedHistory = JSON.parse(uncompressedHistory);
          // Compute "affected" cells for the history.
          storage.computeAffectedCells(parsedHistory);
          // console.log('Graffiti: Loaded previous history:', parsedHistory);
          const audioUrl = graffitiPath + 'audio.txt';
          return fetch(audioUrl, { credentials: 'include' }).then((response) => {
            if (!response.ok) {
              throw Error(response.statusText);
            }
            return response.text();
          }).then(function(base64CompressedAudio) {
            try {
              //console.log('history', parsedHistory);
              state.storeToMovieCache('history', data, parsedHistory);
              state.storeToMovieCache('audio',   data, base64CompressedAudio);
              storage.successfulLoad = true;
              return ({ history: parsedHistory, audio: base64CompressedAudio });
            } catch(ex) {
              console.log('Graffiti: Could not parse saved audio, ex:', ex);
              return Promise.reject('Could not parse saved audio, ex :' + ex);
            }
          });
        } catch (ex) {
          console.log('Graffiti: Could not parse previous history, ex :',ex);
          return Promise.reject('Could not parse previous history, ex :' + ex);
        }
      }).catch((ex) => {
        console.log('Graffiti: Could not fetch history file for history at',historyUrl);
        return Promise.reject('Could not fetch history file');
      });
    },

    preloadAllMovies: () => {
      let allRecords = [], dataRecord, recordingCellId, recordingKeys, recording;
      const manifest = state.getManifest();
      for (recordingCellId of Object.keys(manifest)) {
        recordingKeys = Object.keys(manifest[recordingCellId]);
        if (recordingKeys.length > 0) {
          for (recordingKey of recordingKeys) {
            recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
            if (recording.activeTakeId !== undefined) {
              dataRecord = { 
                recordingCellId: recordingCellId,
                recordingKey: recordingKey,
                activeTakeId: recording.activeTakeId
              }
              allRecords.push(dataRecord);
            }
          }
        }
      }
      const callback = (data) => {
        storage.fetchMovie(data).catch((err) => {
          console.log('Graffiti: Could not fetch movie:', data);
        });
      }
      batchRunner.start(storage.preloadBatchSize, callback, allRecords).then(() => { 
        console.log('Graffiti: preloading completed.');
        state.refreshCellIdToGraffitiMap();
      });
    },

    deleteMovie: (recordingCellId, recordingKey) => {
      const graffitiPath = storage.constructGraffitiMoviePath({ 
        recordingCellId: recordingCellId, 
        recordingKey: recordingKey 
      });
      storage.runShellCommand('rm -r ' + graffitiPath);
      storage.cleanUpExecutorCell();
    },

    transferGraffitis: () => {
      const notebook = Jupyter.notebook;
      let originalGraffitiId;
      if (notebook.metadata.hasOwnProperty('graffiti')) {
        originalGraffitiId = $.extend(true, {},notebook.metadata.graffiti);
        delete(notebook.metadata['graffiti']);
      }
      storage.ensureNotebookGetsGraffitiId();
      storage.ensureNotebookGetsFirstAuthorId();
      utils.saveNotebook(() => {
        const newGraffitiId = notebook.metadata.graffiti.id;
        const notebookPath = "jupytergraffiti_data/notebooks/";
        const sourceTree = notebookPath + originalGraffitiId;
        const destTree = notebookPath + newGraffitiId;
        storage.runShellCommand('cp -pr ' + sourceTree + ' ' + destTree);
        storage.cleanUpExecutorCell();
      });

      return Promise.resolve(); // not really doing this right but...
    },

    packageGraffitis: () => {
      //utils.saveNotebook();
      const notebook = Jupyter.notebook;
      const notebookName = notebook.get_notebook_name();
      const archiveName = 'graffiti_archive_' + utils.generateUniqueId().replace('id_','') + '.tgz';
      const tarCmd = 'tar zcf ' + archiveName + ' "' + notebookName + '.ipynb"' + ' jupytergraffiti_data';
      storage.runShellCommand(tarCmd);
      storage.cleanUpExecutorCell();

      return Promise.resolve(archiveName);
    },

    removeGraffitiIds: () => {
      const cells = Jupyter.notebook.get_cells();
      for (let cell of cells) {
        if (cell.metadata.hasOwnProperty('graffitiCellId')) {
          delete(cell.metadata.graffitiCellId)
        }
      }
      delete(Jupyter.notebook.metadata.graffiti);
      utils.saveNotebook();
    },

    // Delete all a notebook's stored graffitis and its data directory (but not the global jupytergraffiti_data directory)
    deleteDataDirectory: (graffitiId) => {
      const notebookStoragePath = 'jupytergraffiti_data/notebooks/' + graffitiId;
      storage.runShellCommand('rm -r ' + notebookStoragePath);
      storage.cleanUpExecutorCell();      
    },

    removeUnusedTakesCore: (recordingCellId, recordingKey) => {
      const recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
      const activeTakeId = recording.activeTakeId;
      let deletedTakes = 0;

      if (recording.takes !== undefined) {
        for (let takeId of Object.keys(recording.takes)) {
          if (takeId !== activeTakeId) {
            const graffitiTakePath = storage.constructGraffitiTakePath({ 
              recordingCellId: recordingCellId, 
              recordingKey: recordingKey,
              takeId: takeId
            });
            storage.runShellCommand('rm -r ' + graffitiTakePath);
            delete(recording.takes[takeId]);
            deletedTakes++;
          }
        }
      }
      return deletedTakes;
    },

    removeUnusedTakes: (recordingCellId, recordingKey) => {
      const deletedTakes = storage.removeUnusedTakesCore(recordingCellId, recordingKey);
      if (deletedTakes > 0) {
        storage.storeManifest();
        storage.cleanUpExecutorCell();
        utils.saveNotebook();
      }
    },

    fetchDataFile: (filePath) => {
      const nbDir = utils.getNotebookDirectory();
      let fullPath = '/tree';
      if (nbDir !== undefined) {
        fullPath += '/' + nbDir;
      }
      fullPath += '/' + filePath;
      return fetch(fullPath, { credentials: 'include' }).then((response) => {
        if (!response.ok) {
          throw Error(response.statusText);
        }
        return response.text();
      }).catch((ex) => {
        console.log('Graffiti: could not fetch data file at :', filePath);
        return Promise.reject('Could not fetch data file at :' + filePath);
      });
    },

  }

  return(storage);
});

define('js/sticker.js',[
  './utils.js'
], (utils) => {
  // Thanks to https://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element
  const sticker = {

    interpretDashing: (opts,obj) => {
      if ((opts.dashed !== undefined) && (opts.dashed === 'dashed')) {
        if (opts.dashWidth) {
          obj['stroke-dasharray'] = opts.dashWidth;
        } else {
          obj['stroke-dasharray'] = 4;
        }
      }
    },
    
    // Cf : https://www.beyondjava.net/how-to-connect-html-elements-with-an-arrow-using-svg
    // and: https://stackoverflow.com/questions/43887340/how-to-include-the-arrow-head-in-the-length-of-a-line-in-svg
    generateArrowHeadElem: (arrowHeadColor, arrowHeadSize) => {
      const arrowHeadId = 'arrowHead-' + utils.generateUniqueId();
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = sticker.makeSvgElement('marker', {
        id: arrowHeadId,
        viewBox: '0 0 10 10',
        refX: 8.7,
        refY: 3,
        markerUnits: 'strokeWidth',
        markerWidth: arrowHeadSize,
        markerHeight: arrowHeadSize,
        orient: 'auto',
        stroke: arrowHeadColor,
        fill: arrowHeadColor
      });
      const path = sticker.makeSvgElement('path', {
        d: "M 0,0 L0,6 L9,3 z"
      });
      marker.appendChild(path);
      defs.appendChild(marker);
      return { 
        arrowHeadId: arrowHeadId, 
        defs: defs 
      };
    },
    
    makeElementHtml: (tag, attr, innerHtml) => {
      let elementHtml = '<' + tag + ' ';
      if (tag === 'svg') {
        elementHtml += 'xmlns="http://www.w3.org/2000/svg" version="1.1" class="graffitiSvg" ';
      }
      let attrHtml = '';
      if (attr !== undefined) {
        attrHtml = $.map(attr, (val, key) => { return (key + '="' + val + '"') } ).join(' ');
      }
      if (innerHtml !== undefined) {
        elementHtml += attrHtml + '>' + innerHtml + '</' + tag + '>';
      } else {
        elementHtml += attrHtml + '></' + tag + '>';
      }
      return elementHtml;
    },

    makeSvgElement: (tag, attrs) => {
      const el= document.createElementNS('http://www.w3.org/2000/svg', tag);
      if (tag === 'svg') {
        el.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        el.setAttribute('version', '1.1');
        el.setAttribute('preserveAspectRatio', 'none')
      }
      for (let k in attrs) {
        el.setAttribute(k, attrs[k]);
      }
      if (attrs.text !== undefined) { 
        // Handle svg text content as a special case b/c it's not an attribute, cf :
        // https://stackoverflow.com/questions/14758125/setting-text-svg-element-dynamically-via-javascript
        el.textContent = attrs.text;
      }
      return el;
    },

    makeDomElement: (tag, attrs) => {
      const el= document.createElement(tag);
      for (let k in attrs) {
        el.setAttribute(k, attrs[k]);
      }
      return el;
    },

    renderSvg: (svgChildren, x, y, width, height, viewBox, arrowHeadRecord) => {
      let containerDiv, containerSticker, containerDivParams, metaParts;
      let svgGenerator = $('#graffitiSvgGenerator');
      if (svgGenerator.length === 0) {
        $('body').append($('<div id="graffitiSvgGenerator"></div>'));
        svgGenerator = $('#graffitiSvgGenerator');
      }
      for (let svgChild of svgChildren) {
        let transform = '';
        if (svgChild.hasOwnProperty('cssTransform')) {
          transform = 'transform:' + svgChild.cssTransform;
        }
        let backgroundColor = '';
        if (svgChild.hasOwnProperty('backgroundColor')) {
          backgroundColor = 'background:' + svgChild.backgroundColor + ';';
        }
        let border = '';
        if (svgChild.hasOwnProperty('border')) {
          border = 'border:' + svgChild.border + ';';
        }
        containerDivParams = {
          'class': svgChild.outerClass,
          'style' : 'position:absolute;' +
                    'left:' + parseInt(svgChild.x) + 'px;top:' + parseInt(svgChild.y) + 'px;' +
                    'width:' + parseInt(svgChild.width) + 'px;height:' + parseInt(svgChild.height) + 'px;' +
                    transform +
                    backgroundColor +
                    border
        };
        if (svgChild.hasOwnProperty('title')) {
          containerDivParams.title = svgChild.title;
        };
        if (svgChild.hasOwnProperty('metaTag')) {
          metaParts = svgChild.metaTag.split('|');
          containerDivParams[metaParts[0]] = metaParts[1];
        };
        containerDiv = sticker.makeDomElement('div',containerDivParams);
        containerSticker =
          sticker.makeSvgElement('svg',
                                 {
                                   width: svgChild.width,
                                   height: svgChild.height,
                                   viewBox: svgChild.viewBox
                                 });
        if (svgChild.usesArrow) {
          containerSticker.appendChild(svgChild.arrowHeadRecord.defs);
        }
        containerSticker.appendChild(svgChild.el);
        containerDiv.appendChild(containerSticker);
        svgGenerator[0].appendChild(containerDiv);
      }
      const containerHtml = svgGenerator[0].innerHTML;
      svgGenerator.empty();

      return containerHtml;
    },

    makeLine: (opts) => {
      const endpoints = opts.endpoints;
      const p1 = endpoints.p1;
      const p2 = endpoints.p2;
      const bbox = { 
        p1: {
          x: Math.min(p1.x, p2.x),
          y: Math.min(p1.y, p2.y)
        }, 
        p2: {
          x: Math.max(p1.x, p2.x),
          y: Math.max(p1.y, p2.y)
        }
      };
      const color = (opts.color === undefined ? '#000' : opts.color);
      const strokeWidth = (opts.strokeWidth === undefined ? 3 : opts.strokeWidth);
      let coordSpaceEndpoints;
      if ((p2.x < p1.x) &&
          (p2.y < p1.y)) {
        coordSpaceEndpoints = { 
          p1: {
            x: bbox.p2.x, y: bbox.p2.y
          },
          p2: {
            x: bbox.p1.x, y: bbox.p1.y
          }
        };
      } else if (p2.x < p1.x) {
        coordSpaceEndpoints = { 
          p1: {
            x: bbox.p2.x, y: bbox.p1.y
          },
          p2: {
            x: bbox.p1.x, y: bbox.p2.y
          }
        };
      } else if (p2.y < p1.y) {
        coordSpaceEndpoints = { 
          p1: {
            x: bbox.p1.x, y: bbox.p2.y
          },
          p2: {
            x: bbox.p2.x, y: bbox.p1.y
          }
        };
      } else {
        coordSpaceEndpoints = { 
          p1: {
            x: bbox.p1.x, y: bbox.p1.y
          },
          p2: {
            x: bbox.p2.x, y: bbox.p2.y
          }
        };
      }

      // Finally, translate coords into viewport space.
      const finalCoordSpaceEndpoints = {
        p1: {
          x: coordSpaceEndpoints.p1.x - bbox.p1.x, y: coordSpaceEndpoints.p1.y - bbox.p1.y
        },
        p2: {
          x: coordSpaceEndpoints.p2.x - bbox.p1.x, y: coordSpaceEndpoints.p2.y - bbox.p1.y
        }
      }
      const pathPart = 'M ' + finalCoordSpaceEndpoints.p1.x + ' ' + finalCoordSpaceEndpoints.p1.y + ' ' +
                       'L ' + finalCoordSpaceEndpoints.p2.x + ' ' + finalCoordSpaceEndpoints.p2.y;
      let pathObj = 
        {
          'vector-effect': 'non-scaling-stroke',
          'stroke-width' : strokeWidth,
          stroke: color,
          fill: color,
          d: pathPart
        };
      let arrowHeadRecord = undefined;
      if (opts.usesArrow !== undefined) {
        arrowHeadRecord = sticker.generateArrowHeadElem(opts.color, opts.arrowHeadSize);
        pathObj['marker-end'] =  'url(#' + arrowHeadRecord.arrowHeadId + ')';
      }
      sticker.interpretDashing(opts, pathObj);

      const line = sticker.makeSvgElement('path', pathObj);

      const viewBoxBuffer = 10;
      const minArrowBox = 10 + viewBoxBuffer;
      const viewBox = [-1 * viewBoxBuffer,
                      -1 * viewBoxBuffer,
                       Math.max(minArrowBox,Math.abs(bbox.p2.x-bbox.p1.x) + viewBoxBuffer * 2),
                       Math.max(minArrowBox, Math.abs(bbox.p2.y-bbox.p1.y) + viewBoxBuffer * 2)];
      const renderedSvg = sticker.renderSvg([
        {
          el: line,
          x: bbox.p1.x + opts.lineStartOffset.x - viewBoxBuffer,
          y: bbox.p1.y + opts.lineStartOffset.y - viewBoxBuffer,
          width: viewBox[2],
          height: viewBox[3],
          color: color,
          viewBox: viewBox.join(' '),
          usesArrow: opts.usesArrow,
          arrowHeadRecord: arrowHeadRecord,
          arrowHeadSize: opts.arrowHeadSize
        }
      ]);

//      console.log('bbox:', bbox, 'finalCoordSpaceEndpoints', finalCoordSpaceEndpoints, 'viewBox', viewBox, 'pathPart:', pathPart);
      return renderedSvg;
    },

    makeEllipse: (opts) => {
      const dimensions = opts.dimensions;
      const buffer = opts.buffer || 4;
      const viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      const viewBox = sticker.makeBufferedViewBox({buffer:buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      let shapeObj = { cx: dimensions.width / 2,
                       cy: dimensions.height / 2,
                       rx: Math.max(0, dimensions.width / 2 - opts.buffer),
                       ry: Math.max(0,dimensions.height / 2 - opts.buffer),
                       stroke: opts.color,
                       "stroke-width": opts.strokeWidth,
                       "fill-opacity":opts.fillOpacity,
                       fill: opts.color
      };
      sticker.interpretDashing(opts, shapeObj);

      const theEllipse = sticker.makeSvgElement('ellipse', shapeObj);
      const parmBlock = {          
        el: theEllipse,
        x: dimensions.x,
        y : dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        viewBox: viewBox
      };

      const renderedSvg = sticker.renderSvg([parmBlock]);
      return renderedSvg;
    },

    makeBullsEye: (opts) => {
      const dimensions = opts.dimensions;
      const buffer = opts.buffer || 4;
      const viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      const viewBox = sticker.makeBufferedViewBox({buffer:buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      let shapeHash, shapeObj, parmBlocks = [];
      const ringRadii = [1,   5,   9,  13,  17];
      for (let ringCtr = 0; ringCtr < ringRadii.length; ++ringCtr) {
        shapeHash = { cx: dimensions.width / 2,
                      cy: dimensions.height / 2,
                      rx: ringRadii[ringCtr],
                      ry: ringRadii[ringCtr],
                      stroke: opts.color,
                      "stroke-width": opts.strokeWidth,
                      "fill-opacity": opts.fillOpacity,
                      fill: opts.color
        };
        shapeObj = sticker.makeSvgElement('ellipse', shapeHash);
        parmBlocks.push({          
          el: shapeObj,
          x: dimensions.x,
          y : dimensions.y,
          width: dimensions.width,
          height: dimensions.height,
          viewBox: viewBox
        });
      }

      const renderedSvg = sticker.renderSvg(parmBlocks);
      return renderedSvg;

    },

    makeBufferedViewBox: (opts) => {
      const doubleBuffer = opts.buffer * 2;
      let bufferedViewBox;
      let viewBox;
      if (typeof(opts.viewBox) === 'string') {
        viewBox = opts.viewBox.split(' ');
      } else {
        viewBox = opts.viewBox;
      }
      if (opts.bufferAllSides) {
        bufferedViewBox = [
          parseInt(viewBox[0]) - opts.buffer,
          parseInt(viewBox[1]) - opts.buffer,
          parseInt(viewBox[2]) + doubleBuffer,
          parseInt(viewBox[3]) + doubleBuffer
        ];
      } else {
        bufferedViewBox = [
          parseInt(viewBox[0]),
          parseInt(viewBox[1]),
          parseInt(viewBox[2]) + doubleBuffer,
          parseInt(viewBox[3]) + doubleBuffer
        ];
      }
      return bufferedViewBox.join(' ');
    },

    makeSimplePath: (opts) => {
      const buffer = (opts.buffer === undefined ?  4 : opts.buffer);
      const doubleBuffer = buffer * 2;
      const viewBox = sticker.makeBufferedViewBox({buffer:buffer, bufferAllSides: true, viewBox: opts.viewBox });
      const color = (opts.color === undefined ? '#000' : opts.color);
      const strokeWidth = (opts.strokeWidth === undefined ? 3 : opts.strokeWidth);
      const outerClass = (opts.outerClass === undefined ? 'graffiti-sticker-inner' : opts.outerClass);
      let pathObj, thePath, parmBlock;
      let renderParms = [];
      for (let dRec of opts.d) {
        pathObj = 
          {
            'vector-effect': 'non-scaling-stroke',
            'stroke-width' : strokeWidth,
            stroke: color,
            d: dRec,
          };

        if (opts.fill !== undefined) {
          pathObj.fill = opts.fill;
        } else {
          pathObj['fill-opacity'] = 0;
        }

        if (opts.transform !== undefined) {
          pathObj.transform = opts.transform;
        }

        if (opts.fillOpacity !== undefined) {
          pathObj['fill-opacity'] = opts.fillOpacity;
          pathObj.fill = opts.color;
        }

        sticker.interpretDashing(opts, pathObj);

        thePath = sticker.makeSvgElement('path',pathObj);
        parmBlock = {          
          el: thePath,
          x: opts.dimensions.x - buffer,
          y : opts.dimensions.y - buffer,
          width: opts.dimensions.width + doubleBuffer,
          height: opts.dimensions.height + doubleBuffer,
          outerClass: outerClass,
          title: opts.title,
          viewBox: viewBox,
        };
        if (opts.cssTransform !== undefined) {
          parmBlock.cssTransform = opts.cssTransform;
        }
        if (opts.metaTag !== undefined) {
          parmBlock.metaTag = opts.metaTag;
        }
        renderParms.push(parmBlock);
      }
      const renderedSvg = sticker.renderSvg(renderParms);
      return renderedSvg;
    },

    makeRightCurlyBracePath: (opts) => {
      let pathObj = {
        stroke: opts.color,
        "stroke-width": opts.strokeWidth,
        "vector-effect": "non-scaling-stroke",
        "stroke-width" : "3",
        "fill-opacity": 0,
        d: "M0,0 A100, 173.20508075688772 0 0 1  100, 173.20508075688772 A100, " +
           "173.20508075688772 0 0 0 200 346.41016151377545 A100, " +
           "173.20508075688772 0 0 0 100, 519.6152422706632 A100, " +
           "173.20508075688772 0 0 1 0, 692.8203230275509"
      };
      sticker.interpretDashing(opts, pathObj);
      const  rightCurlyBracePath = sticker.makeSvgElement('path', pathObj);
      return rightCurlyBracePath;
    },

    makeLeftCurlyBrace: (opts) => {
      const curlyViewBox = '0 0 200 692';
      const curlyBracePath = sticker.makeRightCurlyBracePath({ 
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      const renderedSvg = sticker.renderSvg([
        {
          el: curlyBracePath,
          width: 8,
          height: opts.dimensions.height,
          viewBox: curlyViewBox,
          x: opts.dimensions.x,
          y: opts.dimensions.y,
          cssTransform: "scaleX(-1)" // css transform
        }
      ]);
      return renderedSvg;
    },

    makeRightCurlyBrace: (opts) => {
      const curlyViewBox = '0 0 200 692';
      const curlyBracePath = sticker.makeRightCurlyBracePath({ 
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      const renderedSvg = sticker.renderSvg([
        {
          el: curlyBracePath,
          width: 8,
          height: opts.dimensions.height,
          viewBox: curlyViewBox,
          x: opts.dimensions.x,
          y: opts.dimensions.y
        }
      ]);
      return renderedSvg;
    },

    makeSymmetricCurlyBraces: (opts) => {
      const curlyViewBox = '0 0 200 692';
      const curlyBracePath1 = sticker.makeRightCurlyBracePath({ 
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      const curlyBracePath2 = sticker.makeRightCurlyBracePath({ 
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      const renderedSvg = sticker.renderSvg([
        {
          el: curlyBracePath1,
          width: 8,
          height: opts.dimensions.height,
          viewBox: curlyViewBox,
          x: opts.dimensions.x - 1,
          y : opts.dimensions.y,
          cssTransform: "scaleX(-1)" // css transform
        },
        {
          el: curlyBracePath2,
          width: 8,
          height: opts.dimensions.height,
          viewBox: curlyViewBox,
          x: opts.dimensions.x + opts.dimensions.width - 8 + 1,
          y : opts.dimensions.y,
          dashed: opts.dashed,
          color:opts.color,
          strokeWidth: opts.strokeWidth
        }
      ]);
      //console.log(renderedSvg);
      return renderedSvg;
    },


    makeTopBracket: (opts) => {
      const width = opts.dimensions.width;
      const height = opts.dimensions.height;
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          buffer:0,
          viewBox: [0,0,width,height],
          d: ['M 0 ' + height + ' L 0 0 L ' + width + ' 0 L ' + width + ' ' + height]
        })
      );
    },

    makeBottomBracket: (opts) => {
      const width = opts.dimensions.width;
      const height = opts.dimensions.height;
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          viewBox: [0,0,width,height],
          d: ['M 0 0 L 0 ' + height + ' L ' + width + ' ' + height + ' L ' + width + '0']
        })
      );
    },

    makeLeftBracket: (opts) => {
      const width = opts.dimensions.width;
      const height = opts.dimensions.height;
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          buffer:0,
          viewBox: [0,0,width,height],
          d: ['M ' + width + ' ' + height + ' L 0 ' + height + ' L 0 0 L ' + width + ' 0']
        })
      );
    },

    makeRightBracket: (opts) => {
      const width = opts.dimensions.width;
      const height = opts.dimensions.height;
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          buffer:0,
          viewBox: [0,0,width,height],
          d: ['M 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height]
        })
      );
    },

    makeHorizontalBrackets: (opts) => {
      const width = opts.dimensions.width;
      const height = opts.dimensions.height;
      const bracketHeight1 = Math.min(sticker.minBracketWidth, parseInt(height / 10));
      const bracketHeight2 = Math.max(height - sticker.minBracketWidth, height - parseInt(height / 10));
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          buffer:0,
          viewBox: [0,0,width,height],
          d: ['M 0 ' + bracketHeight1 + ' L 0 0 L ' + width + ' 0 L ' + width + ' ' + bracketHeight1,
              'M 0 ' + bracketHeight2 + ' L 0 ' + height + ' L ' + width + ' ' + height + ' L ' + width + ' ' + bracketHeight2]
        })
      );
    },

    makeVerticalBrackets: (opts) => {
      const width = opts.dimensions.width;
      const height = opts.dimensions.height;
      const bracketWidth1 = Math.min(sticker.minBracketWidth, parseInt(width / 10));
      const bracketWidth2 = Math.max(width - sticker.minBracketWidth, width - parseInt(width / 10));
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          viewBox: [0,0,width,height],
          d: ['M ' + bracketWidth1 + ' 0 L 0 0 L 0 ' + height + ' L ' + bracketWidth1 + ' ' + height,
              'M ' + bracketWidth2 + ' 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L ' + bracketWidth2 + ' ' + height]
        })
      );
    },

    makeRectangle: (opts) => {
      const dimensions = opts.dimensions;
      const buffer = opts.buffer || 4;
      const viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      const viewBox = sticker.makeBufferedViewBox({buffer:buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      let shapeObj = { x: 0,
                       y: 0, 
                       width: dimensions.width,
                       height: dimensions.height,
                       stroke: opts.color,
                       fill: opts.color,
                       "stroke-width": opts.strokeWidth,
                       "fill-opacity":opts.fillOpacity
      };
      sticker.interpretDashing(opts, shapeObj);
      if (opts.rx !== undefined) { // check for roundrect
        shapeObj.rx = opts.rx;
        shapeObj.ry = opts.ry;
      }
      const theRect = sticker.makeSvgElement('rect', shapeObj);
      const parmBlock = {          
        el: theRect,
        x: dimensions.x,
        y : dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        viewBox: viewBox
      };

      const renderedSvg = sticker.renderSvg([parmBlock]);
      return renderedSvg;
    },

    makeRightTriangle: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          viewBox: [0, 0, 100, 125],
          d: ["M 0 125 L 100 125 L 0 0 Z"]
        })
      );
    },

    makeIsocelesTriangle: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          viewBox: [0, 0, 100, 125],
          d: ["M 0 125 L 100 125 L 50 0 Z"],
        })
      );
    },

    makeTheta: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          viewBox: [0, 0, 469, 700],
          d: ["M469 334c-2,440 -453,468 -469,2 -13,-435 472,-460 469,-2zm-383 -20l298 0c-9,-366 -288,-376 -298,-6l0 6zm297 46l-297 0c16,345 279,397 297,11 0,-4 0,-7 0,-11z"],
          fill: opts.color
        })
      );
    },

    makeSigma: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 16, 16],
          d: ['M2,1l5.46,7.27L2,15h12v-4h-1v1c0,0.552-0.448,1-1,1H4.97l4.39-5.52L5.25,2H12c0.552,0,1,0.448,1,1v1h1V1H2z'],
          fill: opts.color
        })
      );
    },

    makeSmiley: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 49, 49],
          d: ['M25,1A24,24,0,1,0,49,25,24,24,0,0,0,25,1Zm0,46A22,22,0,1,1,47,25,22,22,0,0,1,25,47ZM35.77,33.32a1,1,0,0,1-.13,1.41C31.73,38,28.06,39.1,24.9,39.1a16,16,0,0,1-10.63-4.45,1,1,0,0,1,1.45-1.38c0.34,0.35,8.35,8.52,18.63-.08A1,1,0,0,1,35.77,33.32ZM15,19a3,3,0,1,1,3,3A3,3,0,0,1,15,19Zm14,0a3,3,0,1,1,3,3A3,3,0,0,1,29,19Z'],
          fill: opts.color
        })
      );
    },

    makeFrowney: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 100, 125],
          d: ['M50,2.5C23.809,2.5,2.5,23.809,2.5,50S23.809,97.5,50,97.5S97.5,76.191,97.5,50S76.191,2.5,50,2.5z M50,91.684    C27.016,91.684,8.316,72.984,8.316,50S27.016,8.316,50,8.316S91.684,27.016,91.684,50S72.984,91.684,50,91.684z M37.489,41.386    c2.964,0,5.369-2.403,5.369-5.369c0-2.966-2.405-5.368-5.369-5.368c-2.966,0-5.369,2.402-5.369,5.368    C32.12,38.982,34.523,41.386,37.489,41.386z M62.511,41.386c2.965,0,5.369-2.403,5.369-5.369c0-2.966-2.404-5.368-5.369-5.368    c-2.966,0-5.368,2.402-5.368,5.368C57.143,38.982,59.545,41.386,62.511,41.386z M50.001,51.186    c-13.939,0-20.525,9.548-22.06,14.597c-0.467,1.537,0.399,3.161,1.936,3.628c1.539,0.471,3.161-0.399,3.628-1.936    c0.032-0.105,3.336-10.473,16.496-10.473c13.015,0,16.363,10.061,16.494,10.472c0.381,1.255,1.534,2.063,2.781,2.063    c0.28,0,0.564-0.04,0.846-0.127c1.538-0.467,2.405-2.091,1.938-3.627C70.524,60.733,63.939,51.186,50.001,51.186z'],
        })
      );
    },

    makeThumbsUp: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 218, 346.25],
          d: ['M28 263l31 -9c64,42 77,13 92,10 4,0 1,4 17,0 22,-7 31,-19 23,-35 19,-6 21,-18 15,-33 15,-9 15,-26 3,-38 19,-37 -11,-67 -80,-48 -5,-36 11,-59 5,-80 -7,-27 -25,-31 -50,-30 3,68 8,35 -25,101 -27,55 -3,48 -57,63 -6,36 4,70 26,99zm4 -12c-16,-24 -23,-49 -21,-77 48,-14 33,-15 57,-65 33,-71 31,-34 27,-97 31,1 32,26 26,50 -7,27 -6,40 -1,62 26,-7 74,-21 82,6 7,27 -22,40 -35,41l-42 -7c9,-28 36,-19 44,-19l10 -3 7 -13c-29,8 -10,3 -31,4 -24,1 -40,15 -43,40l8 1c-8,7 -13,16 -14,28l9 1c-5,6 -10,15 -12,26l14 3c-5,7 -9,15 -11,26l29 4c-29,10 -50,-1 -74,-20l-29 9zm87 -58c12,-30 27,-10 49,-12 5,0 27,-7 33,-14 24,20 -36,32 -39,33l-43 -7zm-2 27l10 -15c44,7 28,8 70,-4 10,19 -35,26 -35,26l-45 -7zm3 30l9 -17c36,5 26,7 53,0 4,16 -17,22 -23,22l-39 -5z'],
          fill: opts.color
        })
      );
    },

    makeThumbsDown: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 226, 357.5],
          d: ['M18 27l33 4c59,-51 77,-23 92,-23 5,0 0,-4 18,-2 23,3 33,15 28,32 20,4 24,15 20,32 17,7 19,23 8,37 25,36 -1,70 -74,60 0,38 19,59 16,82 -3,27 -21,34 -46,37 -6,-70 3,-37 -40,-99 -35,-52 -10,-48 -67,-56 -11,-36 -6,-71 12,-104zm6 12c-13,26 -16,53 -10,81 51,7 35,11 67,58 44,66 36,29 41,95 32,-7 29,-32 19,-55 -11,-27 -11,-40 -9,-63 27,4 78,10 82,-18 4,-28 -28,-37 -41,-36l-42 13c13,27 39,14 48,13l10 1 9 12c-30,-4 -10,-1 -33,1 -23,2 -41,-9 -49,-34l8 -3c-8,-6 -15,-14 -18,-26l9 -3c-6,-5 -11,-13 -16,-24l15 -5c-7,-6 -12,-15 -15,-25l28 -8c-30,-7 -50,8 -72,30l-31 -4zm96 46c17,28 30,7 52,5 6,-1 29,4 36,9 21,-23 -42,-27 -44,-27l-44 13zm-5 -27l12 14c44,-13 27,-12 72,-6 7,-21 -39,-22 -40,-22l-44 14zm-1 -31l11 16c36,-11 26,-11 54,-7 2,-18 -20,-20 -27,-20l-38 11z'],
          fill: opts.color
        })
      );
    },


    makeStar: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 1024, 1280],
          d: ['M521.19122173 257.59668148l48.67463902 112.36592198c10.61521383 24.46677333 33.65799506 41.42522469 60.32548344 44.14375505l123.62840495 12.55702124-92.30057877 79.48464988c-20.71261235 17.86462815-29.90383408 45.43829333-23.8195042 72.10578173l27.44421136 121.68659752-105.37541531-64.20909827c-11.52139061-6.99050667-24.85513482-10.74466765-38.31833283-10.74466765-13.59265185 0-26.79694222 3.75416098-38.31833286 10.74466765l-105.37541529 64.20909827 27.44421135-121.68659752c5.95487605-26.66748839-3.10689185-54.24115358-23.8195042-72.10578173l-92.30057876-79.48464988 123.62840494-12.55702124c26.53803457-2.71853037 49.71026963-19.5475279 60.32548346-44.14375505l48.1568237-112.36592198m0-117.80298272c-6.2137837 0-12.55702124 3.3657995-15.40500543 10.09739852l-85.43952593 197.28763258c-2.45962272 5.56651457-7.63777581 9.45012939-13.72210568 10.09739853l-216.446799 22.00715063c-14.7577363 1.55344592-20.45370469 19.80643555-9.32067556 29.51547258l163.11182222 140.45740248c4.66033778 4.01306864 6.86105283 10.35630617 5.43706074 16.44063605l-48.1568237 213.98717629c-2.58907653 11.26248297 6.34323753 20.58315852 16.44063604 20.58315852 2.84798419 0 5.95487605-0.77672297 8.67340642-2.45962272l186.15460346-113.40155259c2.71853037-1.68289975 5.69596839-2.45962272 8.80286024-2.45962272s6.08432987 0.77672297 8.80286026 2.45962272l186.15460344 113.40155259c2.84798419 1.68289975 5.82542222 2.45962272 8.67340644 2.45962272 10.09739852 0 19.02971259-9.32067555 16.44063604-20.58315852L693.23535803 565.69679013c-1.4239921-6.08432987 0.77672297-12.42756741 5.43706073-16.44063605l163.11182222-140.45740248c11.26248297-9.70903703 5.43706075-27.96202667-9.32067555-29.51547258l-216.44679901-22.00715063c-6.08432987-0.64726914-11.26248297-4.40143013-13.72210567-10.09739853l-85.43952593-197.28763258c-3.23634569-6.73159902-9.45012939-10.09739852-15.66391309-10.09739852z'],
          fill: opts.color
        })
      );
    },

    makeRibbon: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: '0 0 100 100',
          d: ["M76.979,12.22c-0.366-0.579-1.004-0.93-1.689-0.93H59.165c-0.768,0-1.468,0.439-1.802,1.132l-6.634,13.76l-7.117-13.808  c-0.343-0.666-1.028-1.084-1.777-1.084H24.71c-0.686,0-1.323,0.351-1.689,0.93c-0.367,0.579-0.411,1.306-0.118,1.926l15.213,32.151  c-6.585,4.021-10.99,11.274-10.99,19.538C27.125,78.448,37.387,88.71,50,88.71s22.875-10.262,22.875-22.875  c0-8.264-4.405-15.518-10.99-19.538l15.213-32.151C77.391,13.525,77.347,12.799,76.979,12.22z M27.869,15.29h12.747l14.572,28.271  C53.521,43.172,51.785,42.96,50,42.96c-2.927,0-5.724,0.559-8.299,1.564L27.869,15.29z M68.875,65.835  c0,10.407-8.468,18.875-18.875,18.875s-18.875-8.468-18.875-18.875S39.593,46.96,50,46.96S68.875,55.428,68.875,65.835z   M59.201,42.617l-6.178-11.984l7.397-15.343h11.71L59.201,42.617z M48.207,53.277l-2.999,6.074l-6.703,0.973  c-0.754,0.109-1.38,0.638-1.615,1.361s-0.039,1.519,0.506,2.051l4.852,4.728l-1.146,6.677c-0.128,0.75,0.181,1.509,0.796,1.956  c0.349,0.253,0.762,0.382,1.176,0.382c0.318,0,0.638-0.076,0.931-0.229L50,74.098l5.994,3.151c0.675,0.353,1.491,0.295,2.106-0.152  s0.924-1.206,0.796-1.956l-1.145-6.677l4.852-4.728c0.545-0.532,0.741-1.327,0.506-2.051s-0.861-1.252-1.615-1.361l-6.703-0.973  l-2.997-6.074c-0.337-0.683-1.032-1.115-1.794-1.115C49.239,52.162,48.544,52.595,48.207,53.277z M51.669,62.064  c0.292,0.591,0.855,1,1.507,1.095l3.732,0.542l-2.7,2.632c-0.472,0.46-0.687,1.122-0.576,1.771l0.638,3.72l-3.339-1.756  c-0.582-0.307-1.279-0.307-1.861,0l-3.34,1.756l0.638-3.72c0.11-0.648-0.104-1.311-0.575-1.771l-2.701-2.632l3.732-0.542  c0.651-0.095,1.215-0.504,1.506-1.095L50,58.682L51.669,62.064z"],
          fill: opts.color
        })
      );
    },
    
    makeAxis: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: opts.strokeWidth,
          viewBox: '0 0 90 90',
          d:["M89.7,85.7c0,0.2-0.1,0.3-0.2,0.4l-3.2,2.2c-0.1,0.1-0.2,0.1-0.3,0.1c-0.1,0-0.2,0-0.2-0.1c-0.2-0.1-0.3-0.3-0.3-0.4v-1.2  H13c-0.6,0-1-0.4-1-1V15.8h-1.2c-0.2,0-0.4-0.1-0.4-0.3c-0.1-0.2-0.1-0.4,0-0.5l2.2-3.2c0.2-0.3,0.6-0.3,0.8,0l2.2,3.2  c0.1,0.2,0.1,0.4,0,0.5c-0.1,0.2-0.3,0.3-0.4,0.3H14v68.9h71.4v-1.2c0-0.2,0.1-0.4,0.3-0.4c0.2-0.1,0.4-0.1,0.5,0l3.2,2.2  C89.6,85.4,89.7,85.6,89.7,85.7z"],
          fill: 'solid',
        })
      );
    },

    makeBomb: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: opts.strokeWidth,
          viewBox: '0 0 100 100',
          d:["M44.5,44.4v-3.9c0-1.1-0.9-2-2-2h-5.6c0-2.2,0.3-5.1,1.8-6.9c1.1-1.3,2.6-1.9,4.7-1.9c3.1,0,6.1,1.2,8.9,2.3  c5.4,2.2,11.1,4.4,16.9-1.6c0.6-0.6,0.6-1.5,0-2.1c-0.6-0.6-1.5-0.6-2.1,0c-4.4,4.6-8.5,3-13.6,0.9c-3.1-1.3-6.4-2.6-10-2.6  c-3,0-5.3,1-7,3c-2.2,2.6-2.5,6.3-2.5,8.8h-5.1c-1.1,0-2,0.9-2,2v3.9C18.3,47.9,12.3,56.3,12.3,66c0,12.9,10.4,23.3,23.3,23.3  S59,78.9,59,66C59,56.3,53,47.9,44.5,44.4z M32.9,80.3c-0.2,0.6-0.8,1.1-1.4,1.1c-0.1,0-0.3,0-0.4-0.1c-6.8-2-11.3-8.2-11.3-15.3  c0-3.5,1.1-6.9,3.3-9.7c0.5-0.7,1.4-0.8,2.1-0.3c0.7,0.5,0.8,1.4,0.3,2.1c-1.7,2.3-2.7,5-2.7,7.9c0,5.7,3.8,10.8,9.2,12.4  C32.7,78.6,33.2,79.5,32.9,80.3z",
             "M82.3,14.5c0.5-0.6,0.5-1.6-0.2-2.1c-0.6-0.5-1.6-0.5-2.1,0.2l-8.6,10.1c-0.5,0.6-0.5,1.6,0.2,2.1c0.3,0.2,0.6,0.4,1,0.4  c0.4,0,0.8-0.2,1.1-0.5L82.3,14.5z",
             "M60.7,13.9C60.7,13.9,60.7,13.9,60.7,13.9l3.9,8.7c0,0,0,0,0,0l0.5,1.1c0.3,0.6,0.8,0.9,1.4,0.9c0.2,0,0.4,0,0.6-0.1  c0.8-0.3,1.1-1.2,0.7-2l-0.5-1.1c0,0,0,0,0,0l-3.9-8.7c0,0,0,0,0,0l-0.5-1.1c-0.3-0.8-1.2-1.1-2-0.7c-0.8,0.3-1.1,1.2-0.7,2  L60.7,13.9z",
             "M75.5,32.4c-0.6-0.6-1.6-0.5-2.1,0.1c-0.6,0.6-0.5,1.6,0.1,2.1l9.7,9.2c0.3,0.3,0.7,0.4,1,0.4c0.4,0,0.8-0.2,1.1-0.5  c0.6-0.6,0.5-1.6-0.1-2.1L75.5,32.4z",
             "M86.2,26.6l-10.5,0c-0.8,0-1.5,0.7-1.5,1.5c0,0.8,0.7,1.5,1.5,1.5l10.5,0c0.8,0,1.5-0.7,1.5-1.5  C87.7,27.3,87,26.6,86.2,26.6z",
             "M50.9,21.7l11.6,5.4c0.2,0.1,0.4,0.1,0.6,0.1c0.6,0,1.1-0.3,1.4-0.9c0.4-0.8,0-1.6-0.7-2L52.2,19c-0.7-0.4-1.6,0-2,0.7  C49.9,20.5,50.2,21.3,50.9,21.7z",
             "M69.5,34.8c-0.8,0-1.5,0.7-1.5,1.5l0,11.3c0,0.8,0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5l0-11.3C71,35.4,70.4,34.8,69.5,34.8  z"
          ],
          fill: opts.color
        })
      );
    },
    
    makeCheckmark: (opts) => {
      let dimensions;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
      } else {
        dimensions = { x: opts.dimensions.x, 
                       y: opts.dimensions.y,
                       width:  Math.max(opts.dimensions.width, 25),
                       height: Math.max(opts.dimensions.height, 25)
        };
      }
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: opts.strokeWidth,
          viewBox: '0 0 587 783.75',
          d:["M0 303c61,65 122,129 184,194 134,-166 227,-376 403,-497 -181,160 -285,402 -400,627 -62,-108 -125,-216 -187,-324z"],
          color:'#090',
          fill:'#4f4',
          dimensions:dimensions,
          dashed:undefined
        })
      );
    },

    makeXmark: (opts) => {
      let dimensions, strokeWidth;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 5;
        dimensions = { x: opts.dimensions.x, 
                       y: opts.dimensions.y,
                       width:  Math.max(opts.dimensions.width, 25),
                       height:  Math.max(opts.dimensions.height, 25)
        };
      }
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: strokeWidth,
          viewBox: '0 0 100 100',
          d:["M10 10 L 80 80 M 80 10 L 10 80"],
          color: 'red',
          dimensions: dimensions,
          dashed: undefined
        })
      );
    },

    makePi: (opts) => {
      let dimensions, strokeWidth;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x, 
                       y: opts.dimensions.y,
                       width:  Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: strokeWidth,
          viewBox: '0 0 110 137.5',
          d:["M21.33,40.487h-3.057c0,0,2.938-21.636,19.974-21.636s53.479,0,53.479,0v11.337H74.157c0,0-3.265,22.259-3.265,34.25  c0,11.989,7.242,14.363,10.091,14.363s7.479-5.46,7.479-6.528c0-1.069,0-2.612,0-2.612h3.265c0,0-1.009,21.487-15.848,21.487  c-14.84,0-13.415-24.93-13.296-25.761c0.118-0.831,3.087-35.021,3.087-35.021H47.15c0,0-0.514,26.395-2.256,34.151  c-1.741,7.756-3.481,26.631-13.139,26.631c-9.654,0-6.171-8.586-6.013-9.379c0.157-0.791,7.122-10.289,8.705-14.72  c1.582-4.432,3.799-36.723,3.799-36.723s-9.676-1.613-13.296,4.273C21.33,40.487,21.33,40.487,21.33,40.487z"],
          color: opts.color,
          fill: opts.color,
          dimensions: dimensions,
          dashed: undefined
        })
      );
    },

    makeAlpha: (opts) => {
      let dimensions, strokeWidth;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x, 
                       y: opts.dimensions.y,
                       width:  Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: strokeWidth,
          viewBox: '0 0 1000 1250',
          d:["M893 755c14,-17 39,-19 56,-5 17,15 19,40 4,57 -181,211 -273,23 -329,-153 -254,411 -603,196 -586,-174 16,-346 418,-629 607,-33 47,-101 88,-205 131,-308 9,-20 32,-30 52,-22 21,9 30,32 22,53 -54,130 -106,263 -172,388 37,123 74,361 215,197zm-300 -204c-166,-554 -461,-392 -476,-68 -15,337 264,458 476,68z"],
          color: opts.color,
          fill: opts.color,
          dimensions: dimensions,
          dashed: undefined
        })
      );
    },

    makeBeta: (opts) => {
      let dimensions, strokeWidth;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x, 
                       y: opts.dimensions.y,
                       width:  Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: strokeWidth,
          viewBox: '0 0 1000 1250',
          d:["M291 982c-15,8 -33,2 -40,-13 -8,-14 -3,-32 12,-40 64,-34 46,-199 28,-374 -13,-118 -26,-241 -14,-338 16,-131 74,-218 227,-200 10,2 21,4 32,8 32,11 64,34 86,66 23,33 35,75 29,126 -2,16 -6,33 -12,51 -6,15 -12,30 -20,44 23,10 44,26 63,46 28,31 50,73 61,118 12,45 14,93 2,137 -28,111 -133,196 -358,138 -10,-2 -17,-9 -21,-18 5,118 -8,213 -75,249zm61 -448c6,56 12,112 15,164 5,-15 21,-24 36,-20 182,46 265,-14 286,-95 9,-34 8,-72 -2,-108 -9,-35 -25,-68 -47,-92 -17,-17 -36,-30 -58,-34 -12,13 -24,23 -36,32 -15,11 -29,18 -42,22 -19,5 -36,4 -50,-6 -8,-6 -15,-15 -18,-27 -3,-11 1,-23 9,-30l0 0c38,-35 76,-52 112,-55 11,-15 21,-33 27,-52 5,-14 8,-27 10,-39 4,-34 -4,-63 -19,-84 -15,-21 -36,-36 -57,-44 -7,-2 -13,-4 -20,-4 -107,-14 -148,50 -160,147 -11,91 2,210 14,325z"],
          color: opts.color,
          fill: opts.color,
          dimensions: dimensions,
          dashed: undefined
        })
      );
    },

    makeGrid: (opts) => {
      let dimensions, strokeWidth;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x, 
                       y: opts.dimensions.y,
                       width:  Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      const numGridLines = 10;
      const viewBoxSize = 100;
      const gridInc = viewBoxSize / numGridLines;
      const viewBox = sticker.makeBufferedViewBox({buffer:5, viewBox: [0,0,viewBoxSize,viewBoxSize]});
      let gridCtr, gridVal, d = '';
      for (gridCtr = 0; gridCtr <= numGridLines; ++gridCtr) {
        gridVal = gridCtr * gridInc;
        d += 'M 0 ' + gridVal + ' ' + 'L ' + viewBoxSize + ' ' + gridVal + ' ';
        d += 'M ' + gridVal + ' 0 ' + 'L ' + gridVal + ' ' + viewBoxSize + ' ';
      }

      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: strokeWidth,
          viewBox: viewBox,
          d:[d],
          dimensions: dimensions,
          dashed: undefined
        })
      );
    },

    makeRightSideMarker: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 100, 50],
          d: ["M 0 25 L 25 0 L 100 0 L 100 50 L 25 50 Z"], 
          fill: opts.color,
          outerClass: 'graffiti-right-side-marker',
          buffer: 0,
        })
      );
    },


    makeAngle: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 30, 35],
          transform: "translate(-390 -560)",
          d: ["M401.883,578.324l12.971-12.971l-0.707-0.707L390.793,588H419v-1h-13.524    C405.357,583.749,404.098,580.706,401.883,578.324z M393.207,587l7.969-7.969c2.026,2.192,3.183,4.984,3.3,7.969H393.207z"],
          fill: opts.color,
        })
      );
    },

    makeTrophy: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 2,
          viewBox: [0, 0, 100, 125],
          d: ["M69.402,82.288H30.598c-0.855,0-1.548,0.692-1.548,1.548v8.462c0,0.857,0.693,1.55,1.548,1.55h38.804  c0.854,0,1.549-0.693,1.549-1.55v-8.462C70.951,82.98,70.258,82.288,69.402,82.288z",
              "M93.357,15.879c-1.635-2.293-5.112-4.738-12.479-4.309c0.062-1.208,0.104-2.446,0.123-3.716  c0.017-0.94-0.681-1.703-1.537-1.703H20.536c-0.856,0-1.551,0.762-1.537,1.703c0.019,1.271,0.061,2.508,0.123,3.717  c-7.363-0.43-10.845,2.013-12.479,4.307c-2.331,3.271-2.174,8,0.428,12.978c3.722,7.119,12.165,14.247,22.486,16.61  C36.188,54.68,43.49,57.225,43.49,57.225h13.021c0,0,7.301-2.545,13.934-11.759c10.32-2.365,18.764-9.492,22.486-16.61  C95.532,23.88,95.688,19.15,93.357,15.879z M11.381,26.603c-1.723-3.295-2.007-6.175-0.778-7.9c1.311-1.838,4.444-2.606,8.914-2.228  c1.002,9.551,3.36,16.971,6.236,22.688C19.17,36.406,13.945,31.507,11.381,26.603z M63.782,24.541l-6.49,6.326l1.532,8.933  c0.105,0.611-0.256,0.872-0.803,0.584L50,36.166l-8.023,4.218c-0.547,0.288-0.907,0.026-0.803-0.584l1.533-8.933l-6.49-6.326  c-0.444-0.433-0.306-0.856,0.307-0.945l8.968-1.303l4.011-8.129c0.274-0.556,0.719-0.556,0.993,0l4.011,8.129l8.968,1.303  C64.088,23.685,64.227,24.109,63.782,24.541z M88.619,26.603c-2.564,4.904-7.789,9.804-14.372,12.561  c2.876-5.717,5.233-13.137,6.235-22.688c4.472-0.379,7.604,0.39,8.914,2.228C90.626,20.428,90.342,23.308,88.619,26.603z",
              "M61.506,78.811c-6.724-9.961-5.283-18.379-5.283-18.379H43.777c0,0,1.44,8.418-5.284,18.379H61.506z"
          ],
          fill: opts.color,
        })
      );
    },
    
    makeButtonWithCursor: (fill) => {
      const buttonWithCursor = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 128 120" enable-background="new 0 0 128 128" xml:space="preserve"><path d="M120,28H8c-4.4,0-8,3.6-8,8v32c0,4.4,3.6,8,8,8h81.264l-0.955-4H8c-2.206,0-4-1.794-4-4V36c0-2.206,1.794-4,4-4h112  c2.206,0,4,1.794,4,4v32c0,1.907-1.343,3.5-3.132,3.898l0.358,0.109c1.417,0.431,2.569,1.364,3.32,2.56  C126.629,73.119,128,70.714,128,68V36C128,31.6,124.4,28,120,28z"/><path d="M114.174,81.744l5.973-2.11c0.815-0.288,1.353-1.066,1.333-1.931c-0.019-0.863-0.591-1.617-1.417-1.868l-25.48-7.748  c-0.686-0.21-1.431-0.034-1.952,0.456c-0.522,0.491-0.741,1.225-0.575,1.922l5.773,24.184c0.192,0.805,0.86,1.408,1.681,1.518  c0.82,0.106,1.623-0.297,2.02-1.023l3.009-5.509l9.558,9.766c0.391,0.398,0.909,0.601,1.431,0.601c0.452,0,0.907-0.153,1.28-0.464  l6.476-5.4c0.429-0.357,0.688-0.878,0.716-1.436c0.028-0.557-0.178-1.101-0.567-1.5L114.174,81.744z M115.662,95.281l-10.156-10.377  c-0.379-0.387-0.896-0.601-1.43-0.601c-0.091,0-0.183,0.006-0.274,0.019c-0.628,0.087-1.177,0.467-1.48,1.022l-1.811,3.315  l-3.756-15.732l16.32,4.963l-3.189,1.127c-0.645,0.228-1.128,0.768-1.282,1.434c-0.154,0.665,0.041,1.363,0.519,1.852l9.934,10.148  L115.662,95.281z"/></svg>';
      return buttonWithCursor;
    },

    makeButton: (opts) => {
      const buttonHtml = '<div class="button-icon" style="width:' + opts.width + 'px;height:' + opts.height + 'px;">' + opts.contents + '</div>';
      return buttonHtml;
    },

    makeTerminal: (opts) => {
      const height = parseInt(opts.width * 0.9);
      const terminalHtml = '<div class="terminal-icon" style="width:' + opts.width + 'px;height:' + height + 'px;">' +
                           '&gt;_' +
                           '</div>';
      return terminalHtml;
    },

    makeLock: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 1,
          viewBox: [0, 0, 100, 100],
          d: ["M77.9,41.2h-0.3v-8.9c0-15-11.7-27.6-26.7-28.1c-15.5-0.5-28.3,12-28.3,27.5c0,1.2,1,2.1,2.1,2.1H33c0.9,0,1.7-0.7,1.7-1.7  c0-8.3,6.4-15.5,14.7-15.9c8.9-0.4,16.2,6.7,16.2,15.4v9.4H34.7h-12h-0.6c-4,0-7.3,3.2-7.3,7.3v40c0,4,3.2,7.2,7.2,7.2h55.8  c4,0,7.3-3.2,7.3-7.3v-40C85.1,44.5,81.9,41.2,77.9,41.2z M22.9,87.7v-7l5.5,7H22.9z M34.7,87.7L22.9,72.6v-2.9h4l14.1,18H34.7z   M47.3,87.7l-14.1-18h6.3l14.1,18H47.3z M60,87.7l-14.1-18h6.3l14.1,18H60z M77.1,87.7h-4.5l-14.1-18h6.3l12.3,15.7V87.7z   M77.1,77.3l-5.9-7.6h5.9V77.3z"],
          fill: opts.color,
        }));
    },

    makeSimpleX: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 1,
          viewBox: [0, 0, 100, 100],
          d: ["M75.1,7.3L50,32.3L24.9,7.3c-1.2-1.2-3.1-1.2-4.2,0L5.8,22.1L33,49.3L5.8,76.5l14.8,14.8c1.2,1.2,3.1,1.2,4.2,0L50,66.3  l25.1,25.1c1.2,1.2,3.1,1.2,4.2,0l14.8-14.8L67,49.3l27.2-27.2L79.3,7.3C78.1,6.1,76.2,6.1,75.1,7.3z"],
          fill: opts.color,
        }));
    },

    

    makeHidden: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          strokeWidth: 1,
          viewBox: [0, 0, 100, 100],
          d: ["M 8.9 46.05 Q 7.3 46.05 6.15 47.2 5 48.35 5 50 5 51.6 6.15 52.75 7.3 53.9 8.9 53.9 L 25.65 53.9 Q 27.3 53.9 28.45 52.75 29.6 51.6 29.6 50 29.6 48.35 28.45 47.2 27.3 46.05 25.65 46.05 L 8.9 46.05 M 37.05 68.5 Q 38.2 67.35 38.2 65.75 38.2 64.1 37.05 62.95 35.9 61.85 34.25 61.85 32.65 61.85 31.5 62.95 L 18.2 76.25 Q 17.05 77.4 17.05 79.05 17.05 80.65 18.2 81.8 19.35 82.95 20.95 82.95 22.6 82.95 23.75 81.8 L 37.05 68.5 M 52.75 71.55 Q 51.6 70.4 50 70.4 48.4 70.4 47.25 71.55 46.1 72.7 46.1 74.35 L 46.1 91.05 Q 46.1 92.7 47.25 93.85 48.4 95 50 95 51.6 95 52.75 93.85 53.9 92.7 53.9 91.05 L 53.9 74.35 Q 53.9 72.7 52.75 71.55 M 93.85 47.2 Q 92.7 46.05 91.1 46.05 L 74.35 46.05 Q 72.75 46.05 71.55 47.2 70.4 48.35 70.4 50 70.4 51.6 71.55 52.75 72.75 53.9 74.35 53.9 L 91.1 53.9 Q 92.7 53.9 93.85 52.75 95 51.6 95 50 95 48.35 93.85 47.2 M 81.8 81.8 Q 82.95 80.65 82.95 79.05 82.95 77.4 81.8 76.25 L 68.5 62.95 Q 67.4 61.85 65.75 61.85 64.1 61.85 62.95 62.95 61.85 64.1 61.85 65.75 61.85 67.35 62.95 68.5 L 76.3 81.8 Q 77.4 82.95 79.05 82.95 80.65 82.95 81.8 81.8 M 82.95 20.95 Q 82.95 19.3 81.8 18.15 80.65 17 79.05 17 77.4 17 76.3 18.15 L 62.95 31.45 Q 61.85 32.6 61.85 34.25 61.85 35.85 62.95 37 64.1 38.15 65.75 38.15 67.4 38.15 68.5 37 L 81.8 23.7 Q 82.95 22.55 82.95 20.95 M 53.9 8.9 Q 53.9 7.3 52.75 6.15 51.6 5 50 5 48.4 5 47.25 6.15 46.1 7.3 46.1 8.9 L 46.1 25.65 Q 46.1 27.25 47.25 28.4 48.4 29.55 50 29.55 51.6 29.55 52.75 28.4 53.9 27.25 53.9 25.65 L 53.9 8.9 M 23.75 18.15 Q 22.6 17 20.95 17 19.35 17 18.2 18.15 17.05 19.3 17.05 20.95 17.05 22.55 18.2 23.7 L 31.5 37 Q 32.65 38.15 34.25 38.15 35.9 38.15 37.05 37 38.2 35.85 38.2 34.25 38.2 32.6 37.05 31.45 L 23.75 18.15 Z"],
          fill: opts.color,
        }));
    },

    makeRunningMan: (fill) => {
      const runnerIcon = '<svg xmlns:x="http://ns.adobe.com/Extensibility/1.0/" xmlns:i="http://ns.adobe.com/AdobeIllustrator/10.0/" xmlns:graph="http://ns.adobe.com/Graphs/1.0/" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 100 85" style="enable-background:new 10 10 100 70;" xml:space="preserve"><switch><foreignObject requiredExtensions="http://ns.adobe.com/AdobeIllustrator/10.0/" x="0" y="0" width="1" height="1"/><g i:extraneous="self"><g fill-rule="evenodd" fill="' + fill + '"><path d="M48.8,57.3c-0.8-0.5-1.4-1.2-1.8-2c-1.5,4.3-3.6,9.6-4.7,12.2c-2.9,0.1-9.5-0.6-14.9-1.5c-2.3-0.4-4.5,1.2-4.8,3.5     c-0.4,2.3,1.2,4.5,3.5,4.8c0.2,0,4.6,0.7,9.2,1.2c2.5,0.3,4.6,0.4,6.4,0.4c3.9,0,6.2-0.8,7.4-3c0.9-1.6,3-7.1,4.9-12.2     c-1.2-0.8-2.5-1.7-4-2.7C49.4,57.7,49,57.4,48.8,57.3z"/><path d="M97.4,43.5c-0.5-1.7-2.2-2.8-4-2.3c-0.8,0.2-6.7,1.8-10.3,2.8c-0.1-0.4-0.3-0.8-0.4-1.1c-1.4-4.1-3.5-10.3-8.9-12.4     c-1.2-0.5-4-1.7-5.8-2.5c-7.6-3.3-20.8,0.3-22.5,0.9c-0.9,0.4-2.9,1.1-8.7,12.5C36,43,36.7,45,38.3,45.8c0.5,0.2,1,0.4,1.5,0.4     c1.2,0,2.3-0.7,2.9-1.8c1.9-3.7,4.5-8.2,5.5-9.4c1.3-0.4,4.4-1.1,7.8-1.5c-3.7,5.1-7,13.2-7.6,16.1c-0.8,4.2,1,5.6,1.6,6     c1.4,1,14.2,9.5,16.1,11.5c-0.5,2.9-3.1,11.4-5.4,18.4c-0.7,2.2,0.5,4.6,2.7,5.3c0.4,0.1,0.9,0.2,1.3,0.2c1.8,0,3.4-1.1,4-2.9     c2.2-6.8,6-18.6,5.9-22c-0.1-3.3-3.1-6.2-9.7-10.7c2.1-5.2,5.6-12.7,8.9-16.6c1.2,1.8,2.1,4.3,2.7,6.2c1,2.8,1.6,4.8,3.5,5.7     c0.5,0.3,1.1,0.4,1.6,0.4c0.4,0,0.9-0.1,1.3-0.2c1.4-0.5,8-2.3,12.1-3.4C96.8,47,97.8,45.3,97.4,43.5z"/><ellipse transform="matrix(0.3937 -0.9192 0.9192 0.3937 28.3646 78.9709)" cx="74" cy="18" rx="9" ry="9"/><path d="M10.8,34.5h20.7c1.4,0,2.5-1.1,2.5-2.5s-1.1-2.5-2.5-2.5H10.8c-1.4,0-2.5,1.1-2.5,2.5S9.5,34.5,10.8,34.5z"/><path d="M7.9,45h20.7c1.4,0,2.5-1.1,2.5-2.5s-1.1-2.5-2.5-2.5H7.9c-1.4,0-2.5,1.1-2.5,2.5S6.5,45,7.9,45z"/><path d="M28.1,53c0-1.4-1.1-2.5-2.5-2.5H5c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5h20.7C27,55.5,28.1,54.4,28.1,53z"/></g></g></switch></svg>'
      return runnerIcon;
    },

    makeScan: (fill) => {
      const scanIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" xml:space="preserve"><g><g fill-rule="evenodd" fill="' + fill + '"><path d="M23.3,62.8H9.2C6.9,62.8,5,64.7,5,67v14.2c0,2.3,1.9,4.2,4.2,4.2h14.2c2.3,0,4.2-1.9,4.2-4.2V67    C27.5,64.7,25.6,62.8,23.3,62.8z"/><path d="M90.8,62.8H76.7c-2.3,0-4.2,1.9-4.2,4.2v14.2c0,2.3,1.9,4.2,4.2,4.2h14.2c2.3,0,4.2-1.9,4.2-4.2V67    C95,64.7,93.1,62.8,90.8,62.8z"/><path d="M57.1,62.8H42.9c-2.3,0-4.2,1.9-4.2,4.2v14.2c0,2.3,1.9,4.2,4.2,4.2h14.2c2.3,0,4.2-1.9,4.2-4.2V67    C61.2,64.7,59.4,62.8,57.1,62.8z M57.1,81.1C57.1,81.1,57.1,81.1,57.1,81.1l-14.2,0c0,0,0,0,0,0l0-14.2c0,0,0,0,0,0h14.2    c0,0,0,0,0,0L57.1,81.1z"/><path d="M87.5,52.5l5-24.4l-9,3c-3.4-4.6-7.8-8.4-12.9-11.2c-6.2-3.4-13.3-5.2-20.6-5.2c-22.4,0-40.6,17-40.6,37.8    c0,1.7,1.4,3.1,3.1,3.1s3.1-1.4,3.1-3.1C15.6,35.1,31,20.9,50,20.9c10.7,0,20.7,4.6,27.2,12.2L68.8,36L87.5,52.5z"/></g></g></svg>';
      return scanIcon;
    },

    makeRabbit: (fill) => {
      const rabbitIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns" viewBox="0 0 100 75" version="1.1" x="0px" y="10px"><g stroke="none" stroke-width="1" fill-rule="evenodd" sketch:type="MSPage"><g sketch:type="MSArtboardGroup" transform="translate(0.000000, -7.000000)" fill="' + fill + '"><path d="M60.1164483,76.5101184 C60.1164483,77.7869765 61.1184016,79.097951 62.3543737,79.4324469 L72.798828,82.2590697 C74.9502082,82.841306 76.9428079,85.1218308 77.229578,87.3473934 L77.4381368,88.9659749 L61.2268002,86.7611761 C59.0007748,86.4584288 55.762595,85.1122528 53.9830021,83.7528954 L30.0193357,65.4480423 C18.6673757,64.6909954 9.4627489,56.133214 7.77382209,45.1160791 L4.34635739,45.1647777 C1.94608449,45.1988816 -1.83318034e-16,43.2833095 -1.07537429e-17,40.8862227 L12.0835739,27.3645101 C17.4743573,21.3386402 23.6068695,17.4194231 31.6593886,17.4194231 C32.7498041,17.4194231 33.8233498,17.4912885 34.8755022,17.6305187 C36.0956627,17.7349159 37.3050822,17.9433886 38.4888396,18.2605754 C54.0954993,22.4423673 65.570761,42.6024939 65.570761,42.6024939 C66.516058,44.0861571 68.636741,45.6806441 70.3388841,46.136732 L71.0643059,46.3311082 C72.7686884,46.7877961 75.036606,46.0402598 76.1348435,44.6627794 L79.3667959,40.6090557 L69.0683577,35.5886404 C54.9830017,29.5 58.824985,11.8109045 58.824985,11.8109045 C58.9924242,10.7260817 59.7843012,10.4649372 60.587326,11.2216236 L82.7393229,32.0953411 L64.7779732,12.0675015 C65.0289152,8.20500861 68.1652109,7 68.1652109,7 L85.5324488,34.7272898 L86.921334,36.0360295 L96.0521825,42.4677019 C98.138955,43.9376022 99.8625925,47.2144004 99.8888571,49.7773535 L100.007257,61.3310185 L99.3236978,61.8899026 C97.5857982,63.3108255 94.5445704,63.6651439 92.5224884,62.6881932 L89.3807164,61.1702742 C86.2103299,59.6385304 81.4523901,60.2321429 78.7512966,62.4950512 L69.6842316,70.0912108 C68.6969982,70.9182902 67.3970043,71.7079683 65.972973,72.3860195 C65.450814,57.828347 59.4984737,45.9574271 46.7248907,37.1161254 C45.6127483,36.4326524 43.9592431,38.4195836 44.7777067,39.1109172 C56.0407574,49.2817354 60.1164483,60.3235994 60.1164483,74.5177084 L60.1164483,76.5101184 Z M95.0509461,53.9162538 C96.1764172,53.9162538 97.0887918,53.0084656 97.0887918,51.8886521 C97.0887918,50.7688386 96.1764172,49.8610504 95.0509461,49.8610504 C93.925475,49.8610504 93.0131004,50.7688386 93.0131004,51.8886521 C93.0131004,53.0084656 93.925475,53.9162538 95.0509461,53.9162538 L95.0509461,53.9162538 Z M19.9417759,92 L19.9417759,89.8393536 C19.9417758,87.5932185 21.6918837,85.2820263 23.828826,84.6248277 C23.828826,84.6248277 35.0800582,81.8619915 38.1368268,76.9378159 C38.1368268,76.9378159 46.7248911,83.7447645 46.7248911,83.7447645 C34.7889374,89.6827409 19.9417759,92 19.9417759,92 L19.9417759,92 Z" sketch:type="MSShapeGroup"/></g></g></svg>';
      return rabbitIcon;
    },

    makeTurtle: () => {
      const turtleIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 75 70" enable-background="new 0 0 95 95" xml:space="preserve"><path d="M87.242,46.239c-5.27,0-9.811,1.512-10.09,1.061c-0.281-0.445,1.796-1.456,3.025-2.802  C69.529,35.867,66.388,23.76,47.223,23.76c-19.398,0-24.78,18.723-35.316,28.476l1.905,1.904c0,0-3.586,1.238-6.277,1.57  c-2.691,0.336-6.951,0.741-6.951,1.348c0,0.531,5.606,0.896,8.407,0.896c2.804,0,7.513-0.338,7.513-0.338s0.337,0.445-2.47,1.342  c-2.804,0.9-3.471,1.686-5.49,4.266c-2.014,2.578-4.215,4.748-4.215,5.713c0,1.09,0.445,1.812,2.014,1.812S9.034,71,10.551,71  c2.909,0,2.909-1.807,3.694-3.152c0.789-1.348,1.362-2.158,2.258-2.943c0.901-0.787,2.02-1.008,3.474-1.568  c1.456-0.564,3.702-1.686,3.702-1.686s3.813,1.461,10.424,1.461c6.617,0,18.836-0.34,24.327-0.34c5.493,0,6.562-2.295,7.906-2.295  c0.672,0,3.981,1.965,3.981,2.748c0,1.117-5.161,4.93-5.161,6.051c0,1.125,1.795,1.965,5.05,1.965c4.653,0,5.205-2.605,6.501-4.207  c1.401-1.734,2.572-3.363,2.572-5.383c0-2.521-5.042-4.818-5.042-4.818s1.011-1.571,3.025-1.571c2.017,0,6.056,0.45,10.428,0.45  c4.373,0,6.727,0.56,6.727-3.589C94.417,47.976,92.514,46.239,87.242,46.239z M89.167,50.5c-0.553,0-1-0.447-1-1s0.447-1,1-1  s1,0.447,1,1S89.72,50.5,89.167,50.5z"/></svg>';
      return turtleIcon;
    },

    makeSnail: () => {
      const snailIcon = '<svg style="transform:scaleX(-1.0)" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" version="1.1" x="0px" y="5px" viewBox="0 0 75 75"><g transform="translate(0,-952.36218)"><path style="text-indent:0;text-transform:none;direction:ltr;block-progression:tb;baseline-shift:baseline;color:#000000;enable-background:accumulate;" d="m 63.748703,971.36229 c -5.43917,0.046 -12.9678,1.9026 -17.33056,4.9688 -5.33006,3.7325 -9.84923,9.9737 -12.23149,20.2812 -1.91437,7.74631 -1.56839,15.38211 1.72054,19.75001 5.65023,-0.3712 12.79569,-0.6555 19.30136,-0.4375 -5.52288,-4.5469 -7.39127,-10.3988 -7.25756,-17.56251 -0.0291,-9.4042 7.41348,-15 14.82795,-15 6.96147,0.06 12.98292,5.6893 12.88842,13 -0.0443,5.72511 -4.66524,9.92801 -9.91658,10.00001 -3.86287,-0.055 -8.81178,-2.1402 -8.91553,-7.00003 0.012,-3.41788 2.27613,-6.76628 5.94369,-6.99998 0.52311,-0.01 1.00104,0.4716 1.00104,1 0,0.5284 -0.47793,1.01 -1.00104,1 -2.58389,0.4032 -3.81164,2.1726 -3.94161,4.99998 0.0869,3.54803 4.10317,4.92403 6.91345,5.00003 4.15393,-0.085 7.88782,-3.7511 7.94578,-8.00001 -0.0251,-5.3606 -4.55816,-11 -10.91762,-11 -6.44788,0 -12.88287,4.6227 -12.85715,12.9688 -0.0323,6.38281 1.10231,13.05131 8.54015,17.68741 10.33074,0.4959 17.71944,1.8254 22.77372,2.625 3.622699,-1.5245 6.11839,-4.1742 7.789365,-8 1.71466,-3.9255 2.5026,-9.064 2.5026,-15.25001 0,-13.3656 -12.517635,-24.0313 -27.778925,-24.0312 z m -45.73514,1 c -1.65858,0 -3.00313,1.3431 -3.00313,3 0,1.6569 1.34455,3 3.00313,3 0.59787,0 1.15869,-0.1992 1.62669,-0.5 1.92801,1.5462 3.44429,3.6637 3.409799,5.9375 -0.0532,2.3056 -1.432899,5.3535 -2.09593,10.1875 -0.37363,-0.053 -0.78261,-0.094 -1.18874,-0.094 -0.58486,0.01 -1.18456,0.1249 -1.81439,0.2813 0.087,-2.7692 -0.50124,-4.9363 -1.34515,-7.0625 -0.88646,-2.2334 -2.73222,-4.4208 -5.91241,-7.5 0.18193,-0.3868 0.31283,-0.7944 0.31283,-1.25 0,-1.6569 -1.3445495,-3 -3.0031295,-3 -1.65858,0 -3.00313,1.3431 -3.00313,3 0,1.6569 1.34455,3 3.00313,3 0.46283,0 0.89106,-0.1257 1.28258,-0.3125 3.0970895,3.0036 4.7355995,4.9984 5.4431695,6.7813 0.74291,1.8716 1.40489,3.8601 1.15746,7 -0.16002,0.067 -0.31086,0.1478 -0.46924,0.2187 -0.89952,8.26371 -0.58523,17.83861 2.47133,25.28131 3.12374,7.606 8.840111,13.0022 19.30135,13.0312 l 57.810216,0 c -0.672391,-1.924 -2.13834,-4.398 -4.410841,-6.7188 -2.40769,-2.4191 -5.888875,-4.6967 -9.635035,-6 -8.34215,-1.2926 -22.74908,-3.8874 -46.07925,-2.2187 -2.51776,-0.2143 -4.76029,-1.7063 -6.06882,-3.6563 -3.74447,-5.5541 -3.29333,-13.0509 -5.25548,-19.75001 -0.18057,-0.1675 -0.39608,-0.3318 -0.65693,-0.4687 0.62315,-4.7755 2.09036,-7.7341 2.1585,-10.6875 -0.1,-3.42 -1.90212,-5.6714 -4.19187,-7.5938 0.0934,-0.2898 0.15641,-0.5852 0.15641,-0.9062 0.0525,-1.7066 -1.59672,-2.9573 -3.00312,-2.9998 z" fill="#000000" fill-opacity="1" stroke="none" marker="none" visibility="visible" display="inline" overflow="visible"/></g></svg>';
      return snailIcon;
    },

    makeSprayCanIcon: () => {
      const sprayCanIcon = '<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" style="width:20px;height:12px;" viewBox="0 0 88 88" enable-background="new 0 0 100 100" xml:space="preserve"><path d="M30.292,91.893c-0.277,0-0.552-0.114-0.75-0.338l-2.614-2.956  c-0.366-0.413-0.327-1.046,0.086-1.411c0.414-0.365,1.047-0.327,1.412,0.087l2.614,2.956c0.366,0.413,0.327,1.046-0.086,1.411  C30.764,91.81,30.528,91.893,30.292,91.893z M26.219,85.882c-0.332,0-0.656-0.165-0.847-0.466l-1.656-2.622  c-0.295-0.467-0.155-1.085,0.312-1.38c0.465-0.295,1.084-0.156,1.379,0.312l1.656,2.622c0.295,0.467,0.155,1.085-0.312,1.38  C26.586,85.832,26.402,85.882,26.219,85.882z M10.305,85.543c-0.413,0-0.799-0.257-0.943-0.668L8.17,81.488  c-0.183-0.521,0.091-1.092,0.612-1.275c0.519-0.188,1.092,0.091,1.275,0.611l1.191,3.387c0.183,0.521-0.091,1.092-0.612,1.275  C10.527,85.525,10.415,85.543,10.305,85.543z M84.585,81.594c-0.552,0-1-0.447-1-1v-2.37c0-0.553,0.448-1,1-1s1,0.447,1,1v2.37  C85.585,81.146,85.137,81.594,84.585,81.594z M23.399,79.747c-0.364,0-0.715-0.199-0.892-0.546  c-5.812-11.412-2.957-18.242-0.737-21.298c0.626-0.862,1.326-1.614,2.066-2.26c-0.73-1.527-1.142-3.388-0.999-5.575  c0.398-6.072,3.779-9.768,7.464-11.549c-0.075-0.425-0.104-0.851-0.079-1.273c0.373-6.19,3.492-11.47,9.269-15.692  c0.446-0.325,1.071-0.229,1.397,0.218c0.326,0.445,0.229,1.071-0.217,1.397c-5.273,3.854-8.117,8.631-8.453,14.198  c-0.008,0.129-0.006,0.263,0.004,0.398c0.222-0.067,0.444-0.129,0.665-0.185c3.565-0.885,6.866-0.192,8.028,1.689  c0.469,0.759,0.976,2.358-0.893,4.539c-1.135,1.327-2.825,1.668-4.636,0.935c-1.701-0.688-3.474-2.361-4.438-4.311  c-2.501,1.267-5.737,4.008-6.114,9.766c-0.107,1.637,0.158,3.044,0.651,4.221c2.304-1.447,4.773-1.989,6.625-1.696  c1.512,0.238,2.556,1.021,2.941,2.201c0.958,2.938-0.12,4.43-0.848,5.059c-1.396,1.204-3.763,1.251-6.033,0.122  c-1.153-0.574-2.318-1.482-3.266-2.72c-0.546,0.499-1.059,1.064-1.516,1.693c-3.367,4.637-3.047,11.46,0.901,19.214  c0.25,0.492,0.055,1.095-0.438,1.346C23.707,79.712,23.552,79.747,23.399,79.747z M26.495,56.169  c0.748,0.979,1.662,1.695,2.567,2.146c1.498,0.745,3.075,0.81,3.834,0.153c0.819-0.707,0.51-2.136,0.253-2.925  c-0.18-0.551-0.834-0.764-1.352-0.845C30.364,54.474,28.363,54.982,26.495,56.169z M32.819,39.677  c0.718,1.374,1.986,2.676,3.316,3.213c1.519,0.616,2.158-0.135,2.368-0.381c0.447-0.522,1.134-1.501,0.71-2.188  c-0.581-0.94-2.979-1.512-5.843-0.799C33.215,39.562,33.029,39.611,32.819,39.677z M8.299,77.702c-0.497,0-0.927-0.369-0.991-0.875  L6.76,72.481c-0.069-0.548,0.319-1.048,0.867-1.117c0.546-0.063,1.048,0.318,1.117,0.867l0.548,4.346  c0.069,0.548-0.319,1.048-0.867,1.117C8.383,77.699,8.341,77.702,8.299,77.702z M84.585,75.176c-0.552,0-1-0.447-1-1v-7.112  c0-0.553,0.448-1,1-1s1,0.447,1,1v7.112C85.585,74.729,85.137,75.176,84.585,75.176z M7.632,68.187c-0.552,0-1-0.447-1-1v-4.063  c0-0.553,0.448-1,1-1s1,0.447,1,1v4.063C8.632,67.739,8.185,68.187,7.632,68.187z M84.585,63.322c-0.552,0-1-0.447-1-1V37.405  c0-0.553,0.448-1,1-1s1,0.447,1,1v24.917C85.585,62.875,85.137,63.322,84.585,63.322z M7.658,59.402c-0.009,0-0.018,0-0.027,0  c-0.552-0.016-0.988-0.475-0.973-1.026c0.345-12.844,4.494-18.087,7.337-20.179c0.154-0.413,0.33-0.842,0.53-1.288  c3.832-8.567,13.136-16.174,25.527-20.871c0.517-0.194,1.094,0.064,1.29,0.581s-0.064,1.094-0.581,1.29  c-11.451,4.34-20.123,11.193-23.981,18.909c1.926-0.503,3.74-0.106,4.861,1.103c1.118,1.207,1.284,3.004,0.442,4.807  c-1.462,3.134-4.531,4.828-6.84,3.769c-1.321-0.604-2.312-2.105-2.115-4.675c-2.346,3.048-4.25,8.389-4.471,16.607  C8.643,58.972,8.198,59.402,7.658,59.402z M15.668,39.46c-1.003,3-0.587,4.764,0.406,5.218c1.131,0.513,3.128-0.506,4.196-2.796  c0.5-1.071,0.465-1.995-0.097-2.603c-0.686-0.739-2.026-0.88-3.414-0.357C16.398,39.058,16.033,39.236,15.668,39.46z M44.426,20.661  c-0.358,0-0.705-0.192-0.884-0.531c-0.259-0.487-0.074-1.093,0.414-1.352c1.179-0.627,2.449-1.23,3.774-1.794  c0.51-0.218,1.096,0.021,1.312,0.528c0.216,0.508-0.02,1.096-0.528,1.312c-1.272,0.542-2.49,1.12-3.619,1.72  C44.745,20.624,44.584,20.661,44.426,20.661z M43.329,16.909c-0.403,0-0.784-0.246-0.935-0.646c-0.196-0.517,0.064-1.094,0.581-1.29  c0.439-0.166,0.782-0.279,1.084-0.294c0.085-0.022,0.199-0.055,0.351-0.1c0.527-0.157,1.085,0.147,1.241,0.679  c0.156,0.53-0.148,1.085-0.678,1.241c-0.34,0.1-0.648,0.189-0.925,0.207c-0.085,0.031-0.203,0.076-0.364,0.138  C43.566,16.889,43.447,16.909,43.329,16.909z M55.574,16.296c-0.435,0-0.834-0.285-0.96-0.724c-0.153-0.531,0.154-1.085,0.685-1.237  c0.778-0.224,1.567-0.438,2.365-0.641c0.539-0.138,1.08,0.188,1.216,0.722c0.137,0.535-0.187,1.079-0.722,1.216  c-0.779,0.199-1.548,0.407-2.308,0.625C55.758,16.283,55.665,16.296,55.574,16.296z M48.571,15.53c-0.456,0-0.868-0.313-0.974-0.777  c-0.124-0.538,0.213-1.074,0.751-1.197c1.599-0.366,3.268-0.689,4.961-0.96c0.542-0.093,1.058,0.284,1.146,0.829  c0.087,0.546-0.284,1.059-0.829,1.146c-1.65,0.265-3.276,0.579-4.832,0.935C48.72,15.522,48.645,15.53,48.571,15.53z M61.835,13.657  c-0.522,0-0.962-0.406-0.997-0.935c-0.036-0.552,0.382-1.027,0.933-1.063c0.938-0.061,1.89-0.11,2.857-0.146  c0.543-0.049,1.017,0.409,1.037,0.961c0.021,0.553-0.41,1.017-0.962,1.037c-0.949,0.036-1.883,0.084-2.803,0.145  C61.879,13.656,61.857,13.657,61.835,13.657z M90.627,90.353H60.354c-2.063,0-3.74-1.578-3.74-3.519v-55.19  c0-0.67,0.2-1.297,0.547-1.831c-0.36-0.715-0.547-1.488-0.547-2.153v-1.615c0-1.949,1.587-4.036,3.95-4.036h0.668  c0.846-2.483,2.916-6.444,6.424-6.444h0.961V9.107c0-1.104,0.896-2,2-2h9.747c1.104,0,2,0.896,2,2v6.456h1.303  c3.528,0,5.423,3.941,6.154,6.444h0.243c2.424,0,4.304,2.17,4.304,4.036v1.668c0,0.616-0.217,1.336-0.606,2.014  c0.383,0.552,0.606,1.211,0.606,1.918v55.19C94.368,88.774,92.69,90.353,90.627,90.353z M60.614,86.353h29.753V32.125H60.614V86.353  z M60.795,28.125h29.177c0.135-0.088,0.331-0.344,0.395-0.516v-1.386c-0.081-0.105-0.237-0.216-0.304-0.216h-29.42  c-0.015,0.026-0.027,0.057-0.031,0.077l0.002,1.574C60.624,27.772,60.71,27.991,60.795,28.125z M65.55,22.008h20.043  c-0.534-1.222-1.322-2.444-1.926-2.444h-16.01C67.005,19.563,66.162,20.775,65.55,22.008z M72.618,15.563h5.747v-4.456h-5.747  V15.563z"/>';
      return sprayCanIcon;
    },

    makeSettingsIcon: (opts) => {
      return sticker.makeSimplePath(
        $.extend({}, true, opts, {
          viewBox: [0, 0, 100, 100],
          d: [ "M49.71,95c-2.757,0-3.253-2.49-3.871-5.594c-0.733-3.752-2.109-5.723-4.478-6.466    c-0.056-0.018-0.139-0.054-0.214-0.094c-0.562-0.147-1.115-0.307-1.663-0.486c-2.331-0.595-4.53,0.338-7.074,3.036    c-2.354,2.489-4.2,4.437-6.758,2.393l-1.186-0.943c-0.333-0.264-0.585-0.462-2.394-1.91c-0.025-0.018-0.049-0.037-0.073-0.057    c-0.01-0.008-0.02-0.015-0.03-0.023l-2.008-1.615c-0.456-0.368-0.456-0.368-1.456-1.162l-0.12-0.096    c-2.544-2.051-1.06-4.266,0.817-7.071c2.121-3.157,2.54-5.525,1.394-7.735l0.001,0c-0.024-0.048-0.047-0.101-0.066-0.154    c-0.294-0.508-0.566-1.032-0.834-1.552c-1.227-2.076-3.449-2.978-7.166-2.882c-3.442,0.089-6.108,0.155-6.471-3.086l-0.16-1.458    c-0.049-0.451-0.075-0.697-0.345-3.105l0.961-0.217l-0.972,0.109l-0.508-4.569c-0.361-3.253,2.258-3.767,5.575-4.418    c3.736-0.741,5.708-2.121,6.453-4.485c0.015-0.05,0.045-0.118,0.077-0.182c0.133-0.503,0.305-1.122,0.513-1.732    c0.568-2.3-0.366-4.495-3.051-7.035c-2.499-2.37-4.433-4.204-2.394-6.764l2.871-3.585c0.018-0.027,0.046-0.064,0.066-0.089    l2.877-3.583c2.039-2.558,4.261-1.065,7.075,0.827c3.153,2.112,5.524,2.529,7.722,1.38c0.038-0.02,0.087-0.04,0.138-0.058    c0.542-0.31,1.052-0.571,1.571-0.833c2.074-1.219,2.98-3.443,2.882-7.181c-0.09-3.432-0.16-6.087,3.084-6.464l9.241-1.029    c3.239-0.354,3.773,2.269,4.426,5.593c0.725,3.714,2.104,5.686,4.478,6.437c0.056,0.018,0.141,0.056,0.218,0.096    c0.544,0.141,1.092,0.304,1.628,0.473c2.345,0.607,4.551-0.321,7.092-3.028c2.38-2.499,4.214-4.425,6.761-2.394l1.256,1.001    c0.307,0.243,0.642,0.509,2.327,1.858c0.018,0.013,0.035,0.027,0.052,0.042c0.02,0.015,0.038,0.031,0.053,0.043l3.58,2.864    c2.535,2.039,1.069,4.237-0.785,7.021l-0.064,0.096c-2.087,3.111-2.507,5.481-1.361,7.686c0.022,0.042,0.045,0.1,0.065,0.16    c0.26,0.453,0.498,0.918,0.741,1.393l0.021,0.04c0.008,0.012,0.016,0.025,0.023,0.038c1.246,2.152,3.475,3.058,7.215,2.955    c3.451-0.087,6.11-0.156,6.469,3.088l0.506,4.527c0.008,0.041,0.013,0.082,0.016,0.122c0.001,0.011,0.003,0.021,0.004,0.031    l0.134,1.238c0.17,1.562,0.17,1.562,0.235,2.134l0.136,1.196c0,0.002,0,0.004,0,0.006c0.348,3.233-2.248,3.751-5.535,4.407    l-0.1,0.02c-3.676,0.719-5.647,2.096-6.396,4.465c-0.018,0.057-0.06,0.151-0.1,0.229c-0.126,0.489-0.289,1.049-0.469,1.616    c-0.61,2.336,0.321,4.543,3.033,7.107c2.489,2.365,4.424,4.205,2.39,6.755c-0.684,0.853-0.836,1.045-1.038,1.301    c-0.236,0.299-0.541,0.684-1.831,2.297c-0.018,0.023-0.04,0.047-0.062,0.071l-2.883,3.598c-2.032,2.537-4.235,1.07-7.025-0.786    l-0.089-0.059c-3.109-2.091-5.479-2.513-7.687-1.368c-0.039,0.02-0.094,0.043-0.15,0.063c-0.478,0.275-1.001,0.555-1.536,0.818    c-2.089,1.218-3,3.445-2.896,7.188c0.095,3.422,0.169,6.102-3.088,6.466l-1.591,0.182c-0.389,0.046-0.814,0.096-2.977,0.339    c-0.034,0.004-0.069,0.006-0.103,0.006v0c-0.001,0-0.008,0.003-0.041,0.005c-1.837,0.205-2.403,0.266-2.773,0.306    c-0.386,0.042-0.558,0.06-1.752,0.197C50.07,94.99,49.885,95,49.71,95z M42.039,81.104c4,1.332,5.169,5.109,5.704,7.848    c0.741,3.722,1.019,4.213,2.307,4.072c1.195-0.137,1.367-0.155,1.757-0.197c0.372-0.04,0.942-0.102,2.807-0.31    c0.014-0.002,0.028-0.003,0.043-0.004c0.043-0.005,0.093-0.009,0.128-0.009c2.086-0.236,2.511-0.286,2.898-0.331l1.601-0.183    c1.291-0.145,1.455-0.684,1.351-4.438c-0.08-2.851,0.242-6.851,3.927-8.995c0.573-0.285,1.075-0.553,1.569-0.838    c0.056-0.032,0.136-0.066,0.212-0.091c3.785-1.889,7.288-0.046,9.604,1.513l0.085,0.056c3.078,2.049,3.614,2.192,4.415,1.192    l2.875-3.589c0.013-0.016,0.074-0.088,0.088-0.104c0.008-0.009,0.016-0.017,0.024-0.025l0.003-0.003    c1.239-1.552,1.543-1.936,1.778-2.234c0.204-0.258,0.357-0.451,1.045-1.309c0.803-1.006,0.539-1.502-2.173-4.079    c-2.079-1.965-4.673-5.008-3.601-9.104c0.188-0.596,0.345-1.137,0.492-1.692c0.019-0.074,0.066-0.181,0.112-0.267    c1.32-4.013,5.112-5.19,7.86-5.728l0.097-0.019c3.625-0.724,4.11-1.001,3.973-2.277l-0.136-1.191    c-0.066-0.575-0.066-0.575-0.236-2.145l-0.134-1.233c-0.002-0.013-0.003-0.026-0.005-0.039c-0.004-0.024-0.008-0.048-0.011-0.072    l-0.511-4.57c-0.141-1.279-0.675-1.445-4.392-1.349c-2.88,0.083-6.843-0.229-8.992-3.846c-0.029-0.04-0.055-0.082-0.078-0.127    l-0.063-0.123c-0.243-0.475-0.48-0.94-0.744-1.393c-0.036-0.062-0.073-0.151-0.099-0.235c-1.907-3.722-0.053-7.256,1.514-9.59    l0.063-0.094c2.045-3.068,2.19-3.604,1.189-4.409L76.8,16.676c-0.096-0.053-0.175-0.118-0.238-0.192    c-1.56-1.248-1.884-1.505-2.181-1.741l-1.261-1.006c-1.004-0.8-1.499-0.541-4.068,2.157c-3.053,3.252-6.017,4.42-9.104,3.617    c-0.592-0.185-1.151-0.35-1.701-0.49c-0.07-0.018-0.138-0.043-0.203-0.076c-0.019-0.01-0.05-0.028-0.081-0.047    c-4.002-1.32-5.176-5.11-5.712-7.857c-0.73-3.718-1.007-4.21-2.298-4.066l-9.238,1.029c-1.295,0.15-1.447,0.644-1.349,4.399    c0.076,2.885-0.248,6.876-3.9,9.019c-0.584,0.297-1.105,0.564-1.616,0.858c-0.057,0.033-0.136,0.067-0.212,0.093    c-3.699,1.921-7.246,0.064-9.588-1.507c-3.15-2.118-3.691-2.267-4.497-1.257l-2.879,3.586c0.016-0.014-0.011,0.02-0.065,0.088    l-2.87,3.584c-0.806,1.012-0.544,1.507,2.163,4.074c2.071,1.959,4.643,4.975,3.63,9.053c-0.213,0.634-0.373,1.211-0.525,1.786    c-0.019,0.071-0.058,0.165-0.101,0.246c-1.297,3.988-5.099,5.177-7.854,5.724c-3.725,0.731-4.212,1.008-4.07,2.293l0.508,4.568    l0.011,0.108c0.27,2.414,0.297,2.66,0.346,3.111l0.159,1.453c0.143,1.278,0.675,1.441,4.406,1.348    c2.867-0.079,6.849,0.247,8.999,3.893c0.296,0.574,0.57,1.101,0.868,1.609c0.042,0.071,0.074,0.146,0.097,0.225    c1.893,3.754,0.046,7.266-1.514,9.587c-2.112,3.155-2.26,3.697-1.255,4.507l0.114,0.091c1.008,0.8,1.008,0.8,1.468,1.171    l1.993,1.603c0.051,0.033,0.1,0.071,0.144,0.114c1.773,1.419,2.022,1.616,2.352,1.877l1.193,0.949    c1.012,0.809,1.511,0.545,4.099-2.19c1.935-2.052,4.959-4.639,9.06-3.588c0.61,0.198,1.165,0.356,1.729,0.502    c0.057,0.015,0.112,0.034,0.165,0.059C41.954,81.056,41.998,81.08,42.039,81.104z M21.972,84.854c0,0.001,0.002,0.002,0.006,0.005    C21.976,84.858,21.974,84.856,21.972,84.854z M41.9,81.059c0.027,0.008,0.054,0.017,0.08,0.025    C41.956,81.075,41.929,81.066,41.9,81.059z M66.309,77.644c-0.026,0.011-0.054,0.025-0.083,0.043    C66.254,77.673,66.282,77.658,66.309,77.644z M22.277,66.181c0,0,0.001,0.001,0.001,0.002    C22.278,66.182,22.277,66.181,22.277,66.181z M81.071,58.039c-0.004,0.011-0.008,0.024-0.011,0.036    C81.064,58.064,81.068,58.051,81.071,58.039z M92.594,45.606c0,0.001,0,0.001,0.001,0.002    C92.595,45.608,92.595,45.607,92.594,45.606z M92.593,45.605L92.593,45.605L92.593,45.605z M92.502,45.268    c0,0.011,0,0.028,0.003,0.051C92.504,45.301,92.503,45.283,92.502,45.268z M58.046,18.927c0.004,0.001,0.009,0.003,0.013,0.004    C58.055,18.929,58.051,18.928,58.046,18.927z M76.969,16.756C76.969,16.756,76.969,16.756,76.969,16.756    C76.969,16.756,76.969,16.756,76.969,16.756z M76.967,16.755L76.967,16.755L76.967,16.755z M76.965,16.754    C76.965,16.754,76.965,16.755,76.965,16.754C76.965,16.755,76.965,16.754,76.965,16.754z M76.963,16.754    C76.963,16.754,76.963,16.754,76.963,16.754C76.963,16.754,76.963,16.754,76.963,16.754z M76.961,16.753L76.961,16.753    L76.961,16.753z M49.964,65.65c-3.537,0-6.945-1.189-9.747-3.43c-3.266-2.611-5.318-6.337-5.777-10.491    c-0.951-8.579,5.252-16.333,13.827-17.286c4.16-0.464,8.243,0.721,11.506,3.332c3.264,2.612,5.315,6.34,5.777,10.499    c0.462,4.154-0.722,8.24-3.335,11.504s-6.339,5.315-10.492,5.774C51.134,65.617,50.547,65.65,49.964,65.65z M50.025,36.301    c-0.512,0-1.026,0.029-1.543,0.086c-7.503,0.834-12.93,7.62-12.098,15.126c0.402,3.634,2.197,6.893,5.054,9.178    c2.857,2.284,6.433,3.32,10.069,2.916c0,0,0,0,0,0c3.633-0.401,6.893-2.195,9.179-5.051c2.287-2.857,3.323-6.432,2.919-10.066    c-0.405-3.639-2.2-6.902-5.055-9.188C56.099,37.342,53.119,36.301,50.025,36.301z"],
          fill: opts.color,
        })
      );
    },

    makeNoEntryIcon: (fill) => {
      const noEntryIcon = '<svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 1" viewBox="0 0 100 100" x="0px" y="0px"><g fill-rule="evenodd" fill="' + fill + '"><path data-name="Compound Path" d="M50,89.11A39.11,39.11,0,1,0,22.33,77.66,39,39,0,0,0,50,89.11ZM72,72a31.17,31.17,0,0,1-41.28,2.42l43.71-43.7A31.17,31.17,0,0,1,72,72ZM28,28a31.16,31.16,0,0,1,40.72-2.86L25.14,68.71A31.17,31.17,0,0,1,28,28Z"/></g></svg>';
      return noEntryIcon;
    },

    makeTrashIcon: (fill) => {
      const trashIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 26" version="1.1" x="0px" y="0px"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="scale(1.2 1.2) translate(-2 0)"><rect x="0" y="0" width="24" height="24"/><path d="M5,6 L5.73274082,20.8571429 C5.73274082,20.8571429 5.99625939,22 6.98958614,22 L11.598019,22 L12.4359159,22 L17.0443487,22 C18.0380944,22 18.301613,20.8571429 18.301613,20.8571429 L19,6 L5,6 Z M15.5,8 L15.5,8 L15.5,8 C15.2205531,8 14.9908183,8.22036187 14.9791847,8.49956654 L14.5208153,19.5004335 L14.5208153,19.5004335 C14.5097883,19.7650799 14.7153876,19.9885573 14.980034,19.9995842 C14.9866857,19.9998614 14.9933425,20 15,20 L15,20 L15,20 C15.2794469,20 15.5091817,19.7796381 15.5208153,19.5004335 L15.9791847,8.49956654 L15.9791847,8.49956654 C15.9902117,8.23492012 15.7846124,8.01144271 15.519966,8.00041578 C15.5133143,8.00013862 15.5066575,8 15.5,8 Z M9.47918818,19.5003499 L9.02097843,8.49965006 L9.02097843,8.49965006 C9.00934688,8.22039979 8.77957571,8 8.50008331,8 L8.50008331,8 L8.50008331,8 C8.23515945,8 8.02039624,8.21476322 8.02039624,8.47968707 C8.02039624,8.48634356 8.02053479,8.49299933 8.02081182,8.49965006 L8.47902157,19.5003499 L8.47902157,19.5003499 C8.49065312,19.7796002 8.72042429,20 8.99991669,20 L8.99991669,20 L8.99991669,20 C9.26484055,20 9.47960376,19.7852368 9.47960376,19.5203129 C9.47960376,19.5136564 9.47946521,19.5070007 9.47918818,19.5003499 Z M8.00719509,3 L5.11111111,3 L5.11111111,3 C4.49746139,3 4,3.49746139 4,4.11111111 L4,4.11111111 L4,5 L20,5 L20,4.11111111 C20,3.49746139 19.5025386,3 18.8888889,3 L15.9926121,3 C15.9368649,2.4385197 15.4631369,2 14.8869871,2 L9.11301289,2 C8.99358834,2 8.87494478,2.0192532 8.76164871,2.05701856 C8.33332638,2.19979267 8.04982846,2.57814658 8.00719509,3 Z M12,8 C12.2761424,8 12.5,8.22385763 12.5,8.5 L12.5,19.5 C12.5,19.7761424 12.2761424,20 12,20 C11.7238576,20 11.5,19.7761424 11.5,19.5 L11.5,8.5 C11.5,8.22385763 11.7238576,8 12,8 Z" fill="#000000"/></g></g></svg>';
      return trashIcon;
    },

    makeCompressTimeIcon: (fill) => {
      const compressTimeIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="-434 236 90 80" style="enable-background:new -434 236 90 90;" xml:space="preserve"><g fill-rule="evenodd" fill="' + fill + '"><path d="M-354.9,251.1h-5.3h-2.6v2.6v27.8c-0.1-0.3-0.3-0.5-0.5-0.8l-29.1-29.1c-0.5-0.5-1-0.7-1.3-0.5c-0.4,0.2-0.5,0.6-0.5,1.3   v29.1c-0.1-0.3-0.3-0.5-0.5-0.8l-29.1-29.1c-0.5-0.5-1-0.7-1.3-0.5c-0.4,0.2-0.5,0.6-0.5,1.3v60.4c0,0.7,0.2,1.1,0.5,1.3   c0.4,0.2,0.8,0,1.3-0.5l29.1-29.1c0.2-0.2,0.4-0.5,0.5-0.8v29.1c0,0.7,0.2,1.1,0.5,1.3c0.4,0.2,0.8,0,1.3-0.5l29.1-29.1   c0.2-0.2,0.4-0.5,0.5-0.8v27.8v2.6h2.6h5.3h2.6v-2.6v-57.8v-2.6H-354.9z"/></g></svg>';
      return compressTimeIcon;
    },

    makeSmallUdacityIcon: (opts) => {
      const udacityHtml = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" width="' +
                          opts.width + 'px" height="' + opts.height + 'px" viewBox="0 0 32 32" ' +
                          'enable-background="new 0 0 32 32">' +
                          '<image x="0" y="0" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJN AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABOFBMVEUAs+YAsuYKvOkSveo1 xezR8vv6/v6I3PQowuu+7Pn///+V4PUCu+my6Pgdv+u66/ln0/Hv+v31/P531/P9/v8At+j3/f7a 9PxLy+/+//8twuzM8Pv8/v9t1fLt+v3u+v1v1fIAtOeY4fXg9vxKy+6S3/UAuOgAtecAs+f2/P4g v+ut5/d21/NXzvCg4/ZWzvDi9/zT8vs9yO3l+PwAuenc9fuX4fWG3PPC7frD7fpHyu4zxez7/v84 xu3s+f0MvOp42POo5fdUzu/U8vxZz/CR3/Wr5vfS8vvn+P0rw+wPvOokwOv5/f606fgAuunX8/xr 1PLQ8ftSze8AtugnwuuU4PUEu+nW8/yJ3PQYv+qQ3/TP8fuq5vfh9vzB7fq/7Pn0/P5w1fI3xu2s 5/fm+PyN3vQ5x+0xxOwxFuTVAAAAAWJLR0QKaND0VgAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAd0 SU1FB+IKHAUqGL3rdjoAAAFBSURBVDjL5dPZUsIwFAbgBMTqj6BiF0FcsGLdEaniUtwVVMR93/f3 fwPbkpS0Os5wbW7Sk/NN0ov/EEL/XIQ0AUgo0Az7QUukVRLbbe2ICqAjBns12vHOes0A6epGokf2 gCKp0HqTHkj1AbEQTXPQP4DBoQz1wLAMfcQ+9wCQHbU3DwCSQf3ArQUwRv8RUINgPAB0TIhAgRYA k5gSwTRmGEgj457nMOt+EBeQPOYYKMCsR2oeC85uwn6cFrHIE7WE5frVKxaydl1CnpJicnWNg3Vs sN/ftLC1bexgN1dGZc8L7b4lHzBR0oGq5aTtsCakOoojhQnj+MRpF059sT8rIxLmeTyvQL7gnof2 8grq9Y07C7dV3KV+Do5yb9/78PikAc8v4rA1Buf1LeE8/v5h+qZLHD0j/vlVo4HV1PD+Dr4BCLwn yyZy1tMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMTAtMjhUMTI6NDI6MjQtMDc6MDC16UJJAAAA JXRFWHRkYXRlOm1vZGlmeQAyMDE4LTEwLTI4VDEyOjQyOjI0LTA3OjAwxLT69QAAAABJRU5ErkJg gg==" width="32" height="32"></image>' + 
                          '</svg>';
      return udacityHtml;
    },

    makeLabelHtml: (opts) => {
      const dimensions = opts.dimensions;
      
      const labelAttr = {
        style: 'width:' + dimensions.width + 'px;' + 'height:' + dimensions.height + 'px;' + 'left:' + dimensions.x + 'px;' + 'top:' + dimensions.y + 'px;' +
               'opacity:' + opts.opacity + ';color:' + opts.color + ';padding-top:10px;'
      };
      
      const labelHtml = '<div class="graffiti-sticker-inner">' + 
                        sticker.makeElementHtml('div', labelAttr, '<div>' + opts.label + '</div>') + 
                        '</div>';
      return labelHtml;
    },

    // create label with SVG. legacy code in case i ever need it but now using the above fn makeLabelHtml since more efficient.
    makeLabelSvg: (opts) => {
      const dimensions = opts.dimensions;
      const buffer = opts.buffer || 4;
      const viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      const viewBox = sticker.makeBufferedViewBox({buffer:buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      let shapeObj = { x: 0,
                       y: 16, 
                       text: opts.label,
                       "font-size": 18,
                       width: dimensions.width,
                       height: dimensions.height,
                       stroke: opts.color,
                       fill: opts.color,
                       dashed: opts.dashed,
                       "stroke-width": opts.strokeWidth,
                       "fill-opacity":opts.fillOpacity
      };
      sticker.interpretDashing(opts, shapeObj);
      const theLabel = sticker.makeSvgElement('text', shapeObj);
      const parmBlock = {          
        el: theLabel,
        x: dimensions.x,
        y : dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        viewBox: viewBox,
      };

      const renderedSvg = sticker.renderSvg([parmBlock]);
      return renderedSvg;
    },

    makeCustom: (opts) => {
      const dimensions = opts.dimensions;
      let customHtml = '<img src="' + opts.imageUrl + '" style="width:' + dimensions.width + 'px;height:' + dimensions.height + 'px;' +
                       'top:' + dimensions.y + 'px;left:' + dimensions.x + 'px;opacity:1.0;';
      if (opts.cssTransform !== undefined) {
        customHtml += 'transform:' + opts.cssTransform;
      }
      customHtml += '">';

      return customHtml;
    },

  }

  sticker.minBracketWidth = 6;
  return (sticker);

});

define('js/selectionSerializer.js',[], function() {
  // From npm package: serialize-selection, MIT license
  // restore the selection specified by the given state and reference node, and
  // return the new selection object
  const selectionSerializer = {

    // https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript
    clearWindowSelection: () => {
      if (window.getSelection) {
        if (window.getSelection().empty) {  // Chrome
          window.getSelection().empty();
        } else if (window.getSelection().removeAllRanges) {  // Firefox
          window.getSelection().removeAllRanges();
        }
      } else if (document.selection) {  // IE?
        document.selection.empty();
      }
    },

    // serialize the current selection offsets using given node as a reference point
    get: (referenceNode) => {
      referenceNode = referenceNode || document.body;

      const sel = window.getSelection();
      const range = sel.rangeCount ? sel.getRangeAt(0).cloneRange() : document.createRange();
      const startContainer = range.startContainer;
      const parentNode = startContainer.parentNode;
      const startOffset = range.startOffset;
      let state = { 
        content: range.toString() 
      };

      // move the range to select the contents up to the selection
      // so we can find its character offset from the reference node
      range.selectNodeContents(referenceNode);
      range.setEnd(startContainer, startOffset);

      state.start = range.toString().length;
      state.end = state.start + state.content.length;

      return { 
        state: state,
        empty: (state.start === state.end)
      }
    },

    restore: (selectionSerialized) => {
      const referenceNode = selectionSerialized.referenceNode || document.body;
      const state = selectionSerialized.state;

      let currentNodeCharIndex = 0;
      let nodes = [referenceNode];
      let sel = window.getSelection();
      let existingRange;
      if (sel.rangeCount > 0) {
        //existingRange = sel.getRangeAt(0);
        //console.log('removing existing range:', existingRange);
        sel.removeAllRanges();
      }

      let range = document.createRange();
      let node;
      let nextNodeCharIndex;

      range.setStart(referenceNode, 0);
      range.collapse(true);

      while (node = nodes.pop()) {
        if (node.nodeType === 3) { // text_node
          nextNodeCharIndex = currentNodeCharIndex + node.length;

          // if this node contains the character at the start index, set this as the
          // starting node with the correct offset
          if (state.start >= currentNodeCharIndex && state.start <= nextNodeCharIndex) {
            range.setStart(node, state.start - currentNodeCharIndex);
          }

          // if this node contains the character at the end index, set this as the
          // ending node with the correct offset and stop looking
          if (state.end >= currentNodeCharIndex && state.end <= nextNodeCharIndex) {
            range.setEnd(node, state.end - currentNodeCharIndex);
            break;
          }

          currentNodeCharIndex = nextNodeCharIndex;
        } else {

          // get child nodes if the current node is not a text node
          let i = node.childNodes.length;
          while (i--) {
            nodes.push(node.childNodes[i]);
          }
        }
      }

      sel.addRange(range);
      return sel;
    },

  }

  return (selectionSerializer);

});

define('js/workspace.js',[
  'js/state.js'
], function(state) {  
  const BELLATRIX_URL = 'https://bellatrix.udacity.com';
  const NEBULA_URL = 'https://nebula.udacity.com';

  function getToken() {
    const kernelName = Jupyter.notebook.kernel.name;
    const executeCallbackObject = (callback) => ({
      iopub: {
        output: (data) => {
          let tokenText = '';
          if (kernelName === 'ir') {
            tokenText = data.content.data && data.content.data['text/html'];
            tokenText = tokenText.replace(/'/g, "");
          } else {
            tokenText = data.content.text;
          }
          tokenText ? callback(tokenText) : null
        }
      }
    });
    return new Promise((resolve, reject) => {
      const gcloudMetadaUrl = 'http://metadata.google.internal/computeMetadata/v1/instance/attributes/keep_alive_token';
      let bashCommand = '';
      let execOptions = {}
      if (kernelName === 'ir') {
        bashCommand = `system('curl "${gcloudMetadaUrl}" -H "Metadata-Flavor: Google" -s --fail', intern=TRUE)`;
        execOptions = {
          silent: false
        };
      } else {
        bashCommand = `!curl "${gcloudMetadaUrl}" -H "Metadata-Flavor: Google" -s --fail`;
      }
      Jupyter.notebook.kernel.execute(
        bashCommand,
        executeCallbackObject(output => resolve(output)),
        execOptions
      );
    });
  }

  function getWorkspace(token) {
    return new Promise((resolve, reject) => {
      var xhr = new XMLHttpRequest();
      xhr.open("POST", `${NEBULA_URL}/api/v1/remote/me`);
      xhr.setRequestHeader("Authorization", "Star " + token);
      xhr.onload = function () {
        if (this.status >= 200 && this.status < 300) {
          resolve(JSON.parse(xhr.response));
        } else {
          reject({
            status: this.status,
            statusText: xhr.statusText
          });
        }
      };
      xhr.onerror = function () {
        reject({
          status: this.status,
          statusText: xhr.statusText
        });
      };
      xhr.send();
    });
  }
        
  const workspace = {
    token: null,
    usageReportSent: false,
    getWorkspace: () => {
      if (!workspace.isUdacityEnv()) {
        return Promise.resolve({
          userId: 'dev',
          coco: true
        })
      }
      return getToken().then(token => {
        workspace.token = token;
        return getWorkspace(token);
      });
    },
    isUdacityEnv: () => {
      const hostname = location.hostname;
      return (
        hostname.endsWith('udacity.com' ) ||
        hostname.endsWith('udacity-student-workspaces.com')
      );
    },
    setWorkspace: () => {
      return workspace.getWorkspace()
      .then(data => {
        state.setUserId(data.userId);
        state.setWorkspace(data);
      })
      .catch(err => console.error(err));
    },
    trackUsageStats: () => {
      if (!workspace.usageReportSent && workspace.isUdacityEnv()) {
        let stats = state.getUsageStats();
        stats.workspace = state.getWorkspace();
        let xhr = new XMLHttpRequest();
        // Async is set to false to make this request work on unload event
        xhr.open("POST", `${BELLATRIX_URL}/api/v1/graffiti/stats`, false);
        xhr.setRequestHeader("Content-Type", "application/json");
        // Required to allow cookie to be set crossDomain
        xhr.withCredentials = true;
        xhr.send(JSON.stringify(stats));
        workspace.usageReportSent = true;
      }
    }
  }

  return workspace;
});

define('js/graffiti.js',[
  'base/js/dialog',
  'base/js/events',
  'notebook/js/textcell',
  'js/LZString.js',
  'js/state.js',
  'js/utils.js',
  'js/audio.js',
  'js/storage.js',
  'js/sticker.js',
  'js/localizer.js',
  'js/selectionSerializer.js',
  'js/workspace.js',
  'js/terminals.js',
  'js/batchRunner.js',
  'components/marked/lib/marked'
], function(dialog, events, textCell, LZString, state, utils, audio, storage, stickerLib, localizer, selectionSerializer, workspace, terminalLib, batchRunner, marked) {
  const Graffiti = (function() {
    const graffiti = {

      init: () => {
        console.log('Graffiti: Main constructor running.');
        
        utils.loadCss([
          '/nbextensions/graffiti-dist/graffiti.css',
          '/nbextensions/graffiti-dist/xterm.css'
        ]);

        const location = document.location;

        const currentAccessLevel = state.getAccessLevel();

        graffiti.LZString = LZString;
        graffiti.rewindAmt = 1;  // seconds
        graffiti.rewindSkipEditAmt = 0.05;  // seconds
        graffiti.CMEvents = {};
        graffiti.halfBullseye = 12;
        graffiti.sitePanel = $('#site');
        graffiti.notebookPanel = $('#notebook');
        graffiti.notebookContainer = $('#notebook-container');
        graffiti.notebookContainerPadding = parseInt(graffiti.notebookContainer.css('padding').replace('px',''));
        graffiti.penColor = 'black';

        graffiti.recordingIntervalMs = 10; // In milliseconds, how frequently we sample the state of things while recording.
        graffiti.playbackIntervalMs = graffiti.recordingIntervalMs;  // In milliseconds, loop speed for playback.  Must match recordingIntervalMs.
        graffiti.highlightMarkText = undefined;
        graffiti.cmLineHeight = 17.0001; // line height of code mirror lines as styled in Jupyter
        graffiti.cmLineFudge = 8; // buffer between lines
        graffiti.cmLineTipFudge = 6; // buffer between lines for tip display
        graffiti.tipAboveFudge = 14;
        graffiti.tokenRanges = {};
        graffiti.canvases = { 
          permanent: {}, // these canvases persist drawings throughout the lifespan of the recording
          temporary: {}  // these canvases get wiped a couple seconds after the person stops drawing
        };
        graffiti.stickers = {
          permanent: {}, // these stickers persist throughout the lifespan of the recording
          temporary: {}  // these stickers fade out a couple seconds after the person finishes placing them
        };

        graffiti.lastUpdateControlsTime = utils.getNow();
        graffiti.notificationMsgs = {};
        graffiti.panelFadeTime = 350;
        graffiti.windowSizeCheckInterval = 250; // ms
        graffiti.windowSizeChangeTime = undefined;
        graffiti.skipKeyDownTimer = undefined;
        graffiti.skipKeyCode = 18; // key code of whatever key starts a skip (alt/option)

        graffiti.scrollNudgeSmoothIncrements = 6;
        graffiti.scrollNudgeQuickIncrements = 4;
        graffiti.scrollNudge = undefined;
        graffiti.penColors = {
          'black'  : '000000',
          'white'  : 'ffffff',
          'red'    : 'ff0000',
          'green'  : '00ff00',
          'blue'   : '0000ff',
          'yellow' : 'ffff00',
          'orange' : 'ff9900',
          'purple' : '8a2be2',
          'brown'  : '996600',
        };
        graffiti.minimumStickerSize = 20; // pixels
        graffiti.minimumStickerSizeWithBuffer = graffiti.minimumStickerSize + 10;
        graffiti.previousActiveTakeId = undefined;
        graffiti.forcedGraffitiTooltipRefresh = false;
        graffiti.MarkdownCell = textCell.MarkdownCell;

        if (currentAccessLevel === 'create') {
          storage.ensureNotebookGetsGraffitiId();
          storage.ensureNotebookGetsFirstAuthorId();
        }

        // Init language strings
        localizer.init().then(() => { 
          // Set up the button that activates Graffiti on new notebooks and controls visibility of the control panel if the notebook has already been graffiti-ized.
          graffiti.updateSetupButton();
          if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) { // do not try to load the manifest if this notebook has not yet been graffiti-ized.
            storage.loadManifest(currentAccessLevel).then(() => {
              utils.createApiSymlink();
              graffiti.initInteractivity();
            }).catch((ex) => {
              console.log('Graffiti: Not setting up Graffiti because this notebook has never had any authoring done yet (no recordingId).');
              console.log(ex);
            });
          }
        });
        
      },

      provideAPIKeyExamples: () => {
        let recorderApiKeyCell = Jupyter.notebook.insert_cell_below('code');
        let invocationLine = 
          "# Graffiti Id: " + graffiti.recordingAPIKey + "\n\n" +
          "# --------------------------------------\n" +
          "import jupytergraffiti\n" +
          "# jupytergraffiti.api.play_recording('" + graffiti.recordingAPIKey + "')\n" +
          "# jupytergraffiti.api.play_recording_with_prompt('" + graffiti.recordingAPIKey +
          "', '![idea](../images/lightbulb_small.jpg) Click **here** to learn more.')\n" +
          "# jupytergraffiti.api.stop_playback()\n" +
          "# jupytergraffiti.api.remove_unused_takes('" + graffiti.recordingAPIKey + "')\n" +
          "# jupytergraffiti.api.remove_all_unused_takes()\n";
        recorderApiKeyCell.set_text(invocationLine);          
        Jupyter.notebook.select_next();
        recorderApiKeyCell.code_mirror.focus();
      },

      bindControlPanelCallbacks: (parent, callbacks) => {
        if (callbacks !== undefined) {
          let cb, id, elem;
          for (cb of callbacks) {
            for (id of cb.ids) {
              parent.find('#' + id).on(cb.event, cb.fn);
            }
          }
        }
      },

      setNotifier: (notificationMsg, callbacks) => {
        const notifierPanel = graffiti.controlPanelIds['graffiti-notifier'];
        notifierPanel.show().children().hide();
        if (!graffiti.notificationMsgs.hasOwnProperty(notificationMsg)) {
          const notificationId = 'graffiti-notification-' + utils.generateUniqueId();
          const notificationHtml = $('<div id="' + notificationId + '">' + notificationMsg + '</div>');
          notificationHtml.appendTo(notifierPanel);
          const newNotificationDiv = notifierPanel.find('#' + notificationId);
          graffiti.notificationMsgs[notificationMsg] = newNotificationDiv;
          graffiti.bindControlPanelCallbacks(newNotificationDiv, callbacks);
        }
        graffiti.notificationMsgs[notificationMsg].show();
      },

      setJupyterMenuHint: (hint, classOverride) => {
        if (graffiti.jupyterMenuHint === undefined) {
          const jupyterMainToolbar = $('#maintoolbar-container');
          const menuHintDiv = $('<span class="graffiti-jupyter-menu-hint-shell"></span>');
          graffiti.jupyterMenuHint = menuHintDiv.appendTo(jupyterMainToolbar);
        }
        const override = (classOverride !== undefined ? classOverride : '');
        const hintHtml = '<span class="graffiti-jupyter-menu-hint ' + override + '">' + hint + '</span>';
        graffiti.jupyterMenuHint.html(hintHtml).show();
      },

      clearJupyterMenuHint: () => {
        if (graffiti.jupyterMenuHint !== undefined) {
          graffiti.jupyterMenuHint.hide();
        }
      },

      startPanelDragging: (e) => {
        console.log('Graffiti: dragging control panel');
        const controlPanelPosition = graffiti.outerControlPanel.position();
        const pointerPosition = state.getPointerPosition();
        state.setControlPanelDragging(true);
        state.setControlPanelDragOffset({ left: pointerPosition.x - controlPanelPosition.left, top: pointerPosition.y - controlPanelPosition.top });
        e.preventDefault();
        e.stopPropagation();
      },
      
      // Skips functionality
      toggleRecordingSkip: () => {
        if (state.getActivity() !== 'recording') {
          state.stopSkipping();
          return;
        }
        state.toggleSkipping();
        if (state.isSkipping()) {
          $('#graffiti-btn-end-recording').html(localizer.getString('RECORDING_HINT_4'));
        } else {
          $('#graffiti-btn-end-recording').html(localizer.getString('RECORDING_HINT_1'));
        }
      },

      // This function is sort of a hack. It creates a new Graffiti to be placed in this cell, wrapping the markdown in it.
      // It repeats some of the functionality of finishGraffiti() without UX interactions, which is unfortunate. Refactor really needed.
      createGraffitizedMarkdown: (cell, markdown, tooltipCommands, tooltipDirectives) => {
        const recordingKey = utils.generateUniqueId();
        const cellId = utils.getMetadataCellId(cell.metadata);
        const recordingRecord = $.extend(true, {
          cellId: cellId,
          cellType: 'markdown',
          createDate: utils.getNow(),
          inProgress: false,
          tokens: $.extend({}, graffiti.selectedTokens.tokens),
          range: $.extend({}, graffiti.selectedTokens.range),
          allTokensString: graffiti.selectedTokens.allTokensString,
          markdown: tooltipDirectives.join("\n") + "\n",
          authorId: state.getAuthorId(),
          authorType: state.getAuthorType(),
          activeTakeId: undefined, // this will be replaced with an id for the first movie recording made
          takes: {},
          hasMovie: true, // this is set to true but the non-existent will be ignored because this will run a terminal command
        }, tooltipCommands);
        state.setSingleManifestRecording(cellId, recordingKey, recordingRecord);
        storage.storeManifest();
        const spanOpenTag = '<span class="graffiti-highlight graffiti-' + cellId + '-' + recordingKey + '"><i></i>';
        const graffizedContents = spanOpenTag + markdown + '</span>';
        return { 
          recordingKey: recordingKey,
          markdown: graffizedContents 
        };
      },

      // Create a button with a graffiti that doesn't do anything, but is ready to attach a recording to. This is merely to help
      // authors who don't know much html create buttons more easily.
      createGraffitiButtonAboveSelectedCell: (opts) => {
        const selectedCellIndex = Jupyter.notebook.get_selected_index();
        const selectedCell = Jupyter.notebook.get_selected_cell();

        const buttonCell = Jupyter.notebook.insert_cell_above('markdown', selectedCellIndex);
        const buttonCellId = utils.getMetadataCellId(buttonCell.metadata);
        const buttonCellIndex = utils.findCellIndexByCellId(buttonCellId);
        Jupyter.notebook.select(buttonCellIndex); // critical step, otherwise, the cell will not render correctly
        const cm = buttonCell.code_mirror;
        cm.execCommand('selectAll');
        const params = { cell: buttonCell, clear: true };
        graffiti.refreshGraffitiHighlights(params);
        graffiti.selectedTokens = utils.findSelectionTokens(buttonCell, graffiti.tokenRanges, state);

        let buttonLabel = 'Graffiti Sample Button (edit me)';
        let tooltipCommands = {
          autoPlay: 'never',
          playOnClick: true,
          hideTooltip: true,
          narratorName: undefined,
          narratorPicture: undefined,
          stickerImageUrl: undefined,
          silenceWarnings: true,
        };
        let tooltipDirectives = [
          '%%play_on_click',
          '%%hide_tooltip',
          '%%button_name No Movie Here Yet',
          'Edit this markdown cell to customize the Graffiti for this button, and to record a new movie.<br><br>' +
          '_(NB: The default movie that was created with this button is a *placeholder* and it will *not* play.)_',
        ];
        if (opts !== undefined) {
          if (opts.tooltipCommands !== undefined) {
            $.extend(tooltipCommands, opts.tooltipCommands);
            if (opts.tooltipCommands.hasOwnProperty('labelSwaps')) {
              buttonLabel = opts.tooltipCommands.labelSwaps[0];
            }
          }
          if (opts.tooltipDirectives !== undefined) {
            _.uniq($.merge(tooltipDirectives, opts.tooltipDirectives));
          }
        }
        const rawButtonMarkdown = '<button>' + buttonLabel + '</button>';
        const graffitizedData = graffiti.createGraffitizedMarkdown(buttonCell, rawButtonMarkdown, tooltipCommands, tooltipDirectives);

        buttonCell.set_text(graffitizedData.markdown);
        buttonCell.render();

        let finalCell = buttonCell;
        if (selectedCell.cell_type === 'markdown') {
          const selectedCellContents = selectedCell.get_text();
          const tagsRe = utils.createGraffitiTagRegex();
          match = tagsRe.exec(selectedCellContents);
          if (match !== null) {
            // For author's convenience,  move this button to the currently selected cell
            // (because it had one or more buttons already), 
            // and delete the cell we added to create the button.
            const newContents = selectedCellContents + "\n" + graffitizedData.markdown;
            selectedCell.set_text(newContents);
            Jupyter.notebook.delete_cell(buttonCellIndex);
            utils.rerenderMarkdownCell(selectedCell);
            finalCell = selectedCell;
          }
        }

        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();

        return finalCell;
      },

      createTerminalSuiteAboveSelectedCell: () => {
        graffiti.setJupyterMenuHint(localizer.getString('INSERT_TERMINAL_SUITE_STATUS'));
        const terminalSuite = {};
        const selectedCellIndex = Jupyter.notebook.get_selected_index();

        const codeCell = Jupyter.notebook.insert_cell_above('code', selectedCellIndex);
        const codeCommentString = utils.getCodeCommentString();
        codeCell.set_text(codeCommentString + "\n" + codeCommentString + ' ' +
                          "Paste code here. It will execute the graffiti associated with the button when shift-enter is pressed.\n" +
                          codeCommentString + "\n");
        terminalSuite.codeCellId = utils.getMetadataCellId(codeCell.metadata);

        const terminalCell = terminalLib.createTerminalCellAboveSelectedCell(selectedCellIndex + 1);
        terminalSuite.terminalCellId = terminalCell.term.id; // initially the term id is the same as the cellId of the cell it lives in.

        const buttonCell = Jupyter.notebook.insert_cell_below('markdown', selectedCellIndex + 1);
        const buttonCellId = utils.getMetadataCellId(buttonCell.metadata);
        const buttonCellIndex = utils.findCellIndexByCellId(buttonCellId);
        Jupyter.notebook.select(buttonCellIndex); // critical step, otherwise, the cell will not render correctly
        const cm = buttonCell.code_mirror;
        cm.execCommand('selectAll');
        const params = { cell: buttonCell, clear: true };
        graffiti.refreshGraffitiHighlights(params);
        graffiti.selectedTokens = utils.findSelectionTokens(buttonCell, graffiti.tokenRanges, state);

        const tooltipCommands = {
          autoPlay: 'never',
          playOnClick: true,
          hideTooltip: true,
          narratorName: undefined,
          narratorPicture: undefined,
          stickerImageUrl: undefined,
          saveToFile: [{ cellId: terminalSuite.codeCellId, path: './graffiti_sample.txt' }],
          terminalCommand: { terminalId: terminalSuite.terminalCellId, command: 'cat ./graffiti_sample.txt' },
        };
        const tooltipDirectives = [
          '%%play_on_click',
          '%%hide_tooltip',
          '%%save_to_file' + ' ' + terminalSuite.codeCellId + ' "' + tooltipCommands.saveToFile[0].path + '"',
          '%%terminal_command' + ' ' + terminalSuite.terminalCellId + ' "' + tooltipCommands.terminalCommand.command + '"'
        ];
        const rawButtonMarkdown = '<button>Run Code</button>';
        const graffitizedData = graffiti.createGraffitizedMarkdown(buttonCell, rawButtonMarkdown, tooltipCommands, tooltipDirectives);
        buttonCell.set_text(graffitizedData.markdown);
        buttonCell.render();
        terminalSuite.buttonCellId = utils.getMetadataCellId(buttonCell.metadata);

        // Wire up the code cell to execute the button graffiti when shift-enter/ctrl-enter is pressed in it.
        const targetGraffitiId = utils.composeGraffitiId(terminalSuite.buttonCellId, graffitizedData.recordingKey);
        utils.setCellGraffitiConfigEntry(codeCell, 'executeCellViaGraffiti', targetGraffitiId);

        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();
        
        graffiti.clearJupyterMenuHint();
        // Save the contents of the code cell to its file even before any edits have happened, so any terminal commands in the button will find any
        // file being referred to.
        state.refreshCellIdToGraffitiMap();
        graffiti.executeSaveToFileDirectives(terminalSuite.codeCellId);
        return terminalSuite;      
      },

      setupOneControlPanel: (elemId,elemHtml, callbacks) => {
        if (graffiti.controlPanelIds === undefined) {
          graffiti.controlPanelIds = {};
        }
        const fullHtml = '<div class="graffiti-control-panel" id="' + elemId +'">' + elemHtml + '</div>';
        const elem = $(fullHtml);
        elem.appendTo(graffiti.controlPanelsShell);
        graffiti.controlPanelIds[elemId] = graffiti.controlPanelsShell.find('#' + elemId);
        graffiti.bindControlPanelCallbacks(graffiti.controlPanelIds[elemId], callbacks);
      },

      setupPlaybackCursor: () => {
        const cursorSize = 30;
        const iconConfiguration = {
          dimensions: {
            x: 0, y: 0, width: cursorSize, height: cursorSize 
          },
          color:'black',
          strokeWidth:2,
          fillOpacity:0,
        };

        const bullsEye = stickerLib.makeBullsEye(iconConfiguration);
        const graffitiCursor = $('<div id="graffiti-cursor" name="cursor" class="graffiti-cursor">' +
                                 '  <div id="graffiti-cursor-normal-cells">' + bullsEye + '</div>' +
                                 '  <div id="graffiti-cursor-terminal-cells"></div>' +
                                 '</div>');
        graffitiCursor.appendTo(header);
      },

      setupControlPanels: () => {
        let previousPlayState;
        if ($('#graffiti-outer-control-panel').length == 0) {
          const outerControlPanel = $('<div id="graffiti-outer-control-panel">' +
                                      '  <div id="graffiti-inner-control-panel">' +
                                      '    <div class="graffiti-small-dot-pattern" id="graffiti-drag-handle">&nbsp;&nbsp;</div>' +
                                      '    <div id="graffiti-control-panels-shell"></div>' +
                                      '  </div>' +
                                      '</div>');
          //const header = $('#header');
          outerControlPanel.appendTo($('body'));
          graffiti.setupPlaybackCursor();
        }

        graffiti.graffitiCursorShell = $('#graffiti-cursor');
        graffiti.graffitiNormalCursor = $('#graffiti-cursor-normal-cells');
        graffiti.graffitiTerminalCursor = $('#graffiti-cursor-terminal-cells');
        graffiti.outerControlPanel = $('#graffiti-outer-control-panel');
        graffiti.outerControlPanel.hide();
        graffiti.controlPanelsShell = $('#graffiti-control-panels-shell');

        $('body').on('mouseup', (e) => {
          if (state.getControlPanelDragging()) {
            console.log('Graffiti: no longer dragging control panel');
            state.setControlPanelDragging(false);
            e.preventDefault();
            e.stopPropagation();
          }
        });

        const logoText = 'graffiti';
        graffiti.setupOneControlPanel('graffiti-control-panel-title', 
                                      '<div>' + stickerLib.makeSmallUdacityIcon({width:20,height:20}) + '</div><div id="graffiti-logo-text">' + logoText + '</div>');

        const dragHandle = $('#graffiti-drag-handle,#graffiti-control-panel-title');
        dragHandle.on('mousedown', (e) => {
          graffiti.startPanelDragging(e); 
        });

        graffiti.windowResizeHandler = (opts) => {
          //console.log('Graffiti: windowResizeHandler');
          if (opts === undefined || (opts !== undefined && opts.force)) {
            graffiti.resizeCanvases();
            terminalLib.refitAllTerminals();
            if (graffiti.outerControlPanel.is(':visible')) {
              graffiti.placeControlPanel( { keepInView: true });
              state.setControlPanelDragging(false);
              // Need to redraw all current stickers here if playing
              const activity = state.getActivity();
              if ((activity === 'playing') || (activity === 'playbackPaused')) {
                graffiti.wipeAllStickerDomCanvases();
                graffiti.redrawAllDrawings();
              }
            }
            graffiti.refreshAllGraffitiSideMarkers();
          }
        };

        // Debounce is no longer needed as we're handling resizes of the notebook container with setTimeout calls, below this.
        //const windowResizeDebounced = _.debounce(graffiti.windowResizeHandler, 100);

        // Watch the notebook container width. If it changes, we will need to handle a resize to redraw many elements.
        graffiti.notebookContainerWidth = graffiti.notebookContainer.width();
        graffiti.performWindowResizeCheck = () => {
          const newWidth = graffiti.notebookContainer.width();
          const newHeight = $(window).height();
          if ((newWidth !== graffiti.notebookContainerWidth) || (newHeight !== graffiti.notebookContainerHeight)) {
            graffiti.notebookContainerWidth = newWidth;
            graffiti.notebookContainerHeight = newHeight;
            const now = utils.getNow();
            // Sort of simple debounce technique
            if (graffiti.windowSizeChangeTime === undefined) {
              graffiti.windowResizeHandler();
              graffiti.windowSizeChangeTime = now;
            } else if (now - graffiti.windowSizeChangeTime > 100) { //  try not to resize more frequently than every 100ms
              graffiti.windowResizeHandler();              
              graffiti.windowSizeChangeTime = now;
            }
          }
          setTimeout(graffiti.performWindowResizeCheck, graffiti.windowSizeCheckInterval);
        };
        setTimeout(graffiti.performWindowResizeCheck, graffiti.windowSizeCheckInterval);

        const iconConfiguration = {
          dimensions: { x: 0, y: 0, width: 8, height: 8 },
          color:'black',
          strokeWidth:1,
          fillOpacity: 0
        };
        const settingsIcon = stickerLib.makeSettingsIcon(iconConfiguration);

        const iconSize = 22;
        const iconColor = '#666'
        const iconStrokeWidth = 1;
        const iconFatStrokeWidth = 2;
        const iconMargin = 6;
        const smallIconMargin = 2;
        const iconDimensions = { x: iconMargin, y:iconMargin, width:iconSize - iconMargin,height:iconSize - iconMargin };
        const largeIconDimensions = { x: smallIconMargin, y:smallIconMargin, width:iconSize + smallIconMargin,height:iconSize + smallIconMargin };
        const defaultIconConfiguration = {
          dimensions: iconDimensions,
          color:iconColor,
          iconUsage: true,
          strokeWidth:iconStrokeWidth,
          fillOpacity: 0
        };
        const solidIconConfiguration = $.extend({}, defaultIconConfiguration, { fillOpacity: 1 });
        const solidFatIconConfiguration = $.extend({}, true, solidIconConfiguration, { strokeWidth:iconFatStrokeWidth });
        const largeIconConfiguration = $.extend({}, true, defaultIconConfiguration, { buffer: 1, dimensions:largeIconDimensions });
        const roundRectConfiguration = $.extend({}, true, largeIconConfiguration, { rx: 6, ry: 6 });


        graffiti.setupOneControlPanel('graffiti-record-controls', 
                                      '  <button class="btn btn-default" id="graffiti-create-btn" title="' + localizer.getString('CREATE_1') + '">' +
                                      '<i class="fa fa-edit"></i>&nbsp; <span>' + localizer.getString('CREATE_1') + '</span></button>' +
                                      '  <button class="btn btn-default" id="graffiti-edit-btn" title="' + localizer.getString('EDIT_TOOLTIP') + '">' +
                                      '  <span style="position:absolute;margin-top:4px;margin-left:2px;">' + settingsIcon + '</span> ' +
                                      '  <span style="padding-left:16px;">' +  localizer.getString('EDIT') + '</span></button>' +
                                      '  <button class="btn btn-default" id="graffiti-begin-recording-btn" title="' + localizer.getString('RECORD_MOVIE') + '">' +
                                      '<i class="fa fa-film graffiti-recorder-button"></i>&nbsp;<span>' + localizer.getString('RECORD') + '</span></button>' +
                                      '  <button class="btn btn-default" id="graffiti-begin-rerecording-btn" title="' + localizer.getString('RERECORD_MOVIE') + '">' +
                                      '<i class="fa fa-film graffiti-recorder-button"></i>&nbsp;<span>' + localizer.getString('RERECORD') + '</span></button>' +
                                      '  <button class="btn btn-default" id="graffiti-remove-btn" title="' + localizer.getString('REMOVE_GRAFFITI') + '">' +
                                      '<i class="fa fa-trash"></i></button>',
                                      [
                                        {
                                          ids: ['graffiti-create-btn', 'graffiti-edit-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.editGraffiti();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-begin-recording-btn', 'graffiti-begin-rerecording-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.beginMovieRecordingProcess();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-remove-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.removeGraffitiWithPrompt();
                                          }
                                        },
                                      ]
        );

        graffiti.setupOneControlPanel('graffiti-finish-edit-controls', 
                                      '<button class="btn btn-default" id="finish-graffiti-btn" title="' +
                                      localizer.getString('SAVE_GRAFFITI') + '">' + localizer.getString('SAVE_GRAFFITI') + '</button>',
                                      [
                                        {
                                          ids: ['finish-graffiti-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.finishGraffiti(true);
                                          }
                                        }
                                      ]
        );

        graffiti.setupOneControlPanel('graffiti-start-recording-controls', 
                                      '<button class="btn btn-default" id="btn-start-recording" title="' + localizer.getString('START_RECORDING') + '">' +
                                      '<i class="fa fa-pause recorder-start-button"></i>&nbsp;' + localizer.getString('START_RECORDING') + '</button>',
                                      [
                                        {
                                          ids: ['btn-start-recording', 'btn-restart-recording'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.finishGraffiti(true);
                                          }
                                        }
                                      ]
        );

        graffiti.setupOneControlPanel('graffiti-recording-controls', 
                                      '<div id="graffiti-recording-button-help-shell">' +
                                      '  <div id="graffiti-btn-end-recording" class="graffiti-recording-button-help">' +
                                      localizer.getString('RECORDING_HINT_1') +
                                      '  </div>' +
                                      '  <div class="graffiti-recording-button-help">' +
                                      '    <div>' + localizer.getString('RECORDING_HINT_2') + '</div>' +
                                      '    <div>' + localizer.getString('RECORDING_HINT_3') + '</div>' +
                                      '  </div>' +
                                      '</div>' + 
                                      '<div id="graffiti-recording-status">' +
                                      '  <div id="graffiti-recording-flash-icon"></div>' +
                                      '  <div id="graffiti-time-display-recording"></div>' +
                                      '</div>',
                                      [
                                        {
                                          ids: ['graffiti-btn-end-recording'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.toggleRecording();
                                          }
                                        }
                                      ]
        );

        // controls which recording takes are the activeTake
        graffiti.setupOneControlPanel('graffiti-takes-controls',
                                      '<div id="graffiti-takes-controls-outer">' +
                                      '  <div id="graffiti-takes-title">' + localizer.getString('TAKES') + ':</div>' +
                                      '  <div id="graffiti-takes-list"></div>' +
                                      '</div>',
                                      [
                                        {
                                          ids: ['graffiti-takes-list'],
                                          event: 'click',
                                          fn: (e) => {
                                            const target = $(e.target);
                                            let choice;
                                            if (target.attr('id') === 'graffiti-takes-list') {
                                              choice = target.find('.graffiti-take-item:first');
                                            } else {
                                              choice = target;
                                            }
                                            if (choice.length > 0) {
                                              const newTakeId = choice.attr('id');
                                              const recordingCellId = choice.attr('recordingCellId');
                                              const recordingKey = choice.attr('recordingKey');
                                              graffiti.updateActiveTakeId(recordingCellId, recordingKey, newTakeId);
                                            }
                                          }
                                        }
                                      ]
        );
        
        const runnerOnIcon = stickerLib.makeRunningMan('black');
        const runnerOffIcon = stickerLib.makeRunningMan('white');
        const exitButtonConfiguration = {
          dimensions: { x: 4, y: 4, width:12, height:12 },
          color:"rgb(249, 92, 60)",
          iconUsage: false,
          strokeWidth:1,
          fillOpacity: 1
        };
        const exitButton = stickerLib.makeSimpleX(exitButtonConfiguration);

        graffiti.setupOneControlPanel('graffiti-playback-controls', 
                                      '<div id="graffiti-narrator-info">' +
                                      '  <div id="graffiti-narrator-pic"></div>' +
                                      '  <div id="graffiti-narrator-details">' +
                                      '    <div>Presenter: </div><div id="graffiti-narrator-name"></div>' +
                                      '  </div>' + 
                                      '</div>' +
                                      '<div id="graffiti-playback-buttons">' +
                                      '  <button class="btn btn-default btn-play" id="graffiti-play-btn" title="' + localizer.getString('START_PLAYBACK') + '">' +
                                      '    <i class="fa fa-play"></i>' +
                                      '  </button>' +
                                      '  <button class="btn btn-default" id="graffiti-pause-btn" title="' + localizer.getString('PAUSE_PLAYBACK') + '">' +
                                      '    <i class="fa fa-pause"></i>' +
                                      '  </button>' +
                                      '  <div id="graffiti-skip-buttons">' +
                                      '    <button class="btn btn-default btn-rewind" id="graffiti-rewind-btn" title="' + localizer.getString('SKIP_BACK') + ' ' +
                                       (state.scanningIsOn() ? localizer.getString('TO_PREVIOUS_SENTENCE') : graffiti.rewindAmt + ' ' + localizer.getString('SECONDS')) + '">' +
                                      '      <i class="fa fa-backward"></i>' +
                                      '    </button>' +
                                      '    <button class="btn btn-default btn-forward" id="graffiti-forward-btn" title="' + localizer.getString('SKIP_FORWARD') + ' ' + 
                                       (state.scanningIsOn() ? localizer.getString('TO_NEXT_SENTENCE') : graffiti.rewindAmt + ' ' + localizer.getString('SECONDS')) + '">' +
                                      '      <i class="fa fa-forward"></i>' +
                                      '    </button>' +
                                      '  </div>' +
                                      '  <div id="graffiti-sound-buttons">' +
                                      '    <button class="btn btn-default btn-sound-on" id="graffiti-sound-on-btn" title="' + localizer.getString('MUTE') + '">' +
                                      '       <i class="fa fa-volume-up"></i>' +
                                      '   </button>' +
                                      '   <button class="btn btn-default btn-sound-off" id="graffiti-sound-off-btn" title="' + localizer.getString('UNMUTE') + '">' +
                                      '     <i class="fa fa-volume-off"></i>' +
                                      '   </button>' +
                                      '  </div>' +
                                      '  <div id="graffiti-rapidplay-buttons">' +
                                      '    <button class="btn btn-default btn-rapidplay-on" id="graffiti-rapidplay-on-btn" title="' +
                                      localizer.getString('HIGH_SPEED_PLAYBACK') + '">' + runnerOnIcon +
                                      '   </button>' +
                                      '   <button class="btn btn-default btn-rapidplay-off" id="graffiti-rapidplay-off-btn" title="' +
                                      localizer.getString('REGULAR_SPEED_PLAYBACK') + '">' + runnerOffIcon +
                                      '   </button>' +
                                      '  </div>' +
                                      '  <div id="graffiti-exit-button">' +
                                      '   <button class="btn btn-default" id="graffiti-exit-playback-btn" title="' +
                                      localizer.getString('EXIT_PLAYBACK') + '">' + exitButton +
                                      '   </button>' +
                                      '  </div>' +
                                      '</div>' +
                                      '<div id="graffiti-scrub-controls">' +
                                      '  <div id="graffiti-playback-range">' +
                                      '    <input type="range" min="0" max="1000" value="0" id="graffiti-recorder-range"></input>' +
                                      '  </div>' +
                                      '  <div id="graffiti-time-display-playback">00:00</div>' +
                                      '</div>',
                                      [
                                        {
                                          ids: ['graffiti-play-btn', 'graffiti-pause-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.togglePlayback();
                                          }
                                        },
                                        { 
                                          ids: ['graffiti-forward-btn','graffiti-rewind-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            //console.log('Graffiti: forward-btn/rewind-btn clicked');
                                            let direction = 1;
                                            if (($(e.target).attr('id') === 'graffiti-rewind-btn') || ($(e.target).hasClass('fa-backward'))) {
                                              direction = -1;
                                            }
                                            graffiti.jumpPlayback(direction, graffiti.rewindAmt);
                                          }
                                        },
                                        {
                                          ids: ['graffiti-sound-on-btn', 'graffiti-sound-off-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            if (state.getMute()) {
                                              state.setMute(false);
                                              graffiti.updateControlPanels();
                                              if (state.getActivity() === 'playing') {
                                                audio.startPlayback(state.getTimePlayedSoFar());
                                              }
                                            } else {
                                              state.setMute(true);
                                              graffiti.updateControlPanels();
                                              if (state.getActivity() === 'playing') {
                                                audio.pausePlayback();
                                              }
                                            }
                                          }
                                        },
                                        {
                                          ids: ['graffiti-rapidplay-on-btn', 'graffiti-rapidplay-off-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.toggleRapidPlay({scan:false});
                                          }
                                        },
                                        {
                                          ids: ['graffiti-rapidscan-on-btn', 'graffiti-rapidscan-off-btn'],
                                          event: 'click',
                                          fn: (e) => {
                                            graffiti.toggleRapidPlay({scan:true});
                                          }
                                        },
                                        {
                                          ids: ['graffiti-exit-button'],
                                          event: 'click',
                                          fn: (e) => {
                                            const activity = state.getActivity();
                                            if ((activity === 'playing') || (activity === 'playbackPaused') || (activity === 'scrubbing')) {
                                              graffiti.cancelPlayback();
                                            }
                                          }
                                        },
                                        {
                                          ids: ['graffiti-recorder-range'],
                                          event: 'mousedown',
                                          fn: (e) => {
                                            //console.log('slider:mousedown');
                                            previousPlayState = state.getActivity();
                                            graffiti.pausePlayback(); // stop playback if playing when you start to scrub
                                            graffiti.changeActivity('scrubbing');
                                          }
                                        },
                                        {
                                          ids: ['graffiti-recorder-range'],
                                          event: 'mouseup',
                                          fn: (e) => {
                                            //console.log('slider:mouseup')
                                            graffiti.handleSliderDrag(); // rerun slider drag on mouseup because we may not have gotten the last input event.
                                            graffiti.changeActivity('playbackPaused');
                                            if (previousPlayState === 'playing') {
                                              graffiti.startPlayback();
                                            }
                                            graffiti.updateAllGraffitiDisplays();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-recorder-range'],
                                          event: 'input',
                                          fn: (e) => {
                                            graffiti.handleSliderDragDebounced();
                                          }
                                        }
                                      ]
        );
        
        graffiti.setupOneControlPanel('graffiti-notifier', 
                                      '<div id="graffiti-notifier"></div>');


        // These two SVGs come from fontawesome-5.2.0: fas fa-highlighter and fas fa-pen-alt, respectively. However, we can't use them without importing the latest
        // fontawesome and that collides with Jupyter's use of fontawesome.

        graffiti.setupOneControlPanel('graffiti-recording-pen-controls', 
                                      '<div id="graffiti-recording-pens-shell">' +
                                      ' <button class="btn btn-default" id="graffiti-line-pen" title="' + localizer.getString('FREEFORM_PEN_TOOL') + '">' +
                                      '<svg class="svg-inline--fa fa-pen-alt fa-w-16" aria-hidden="true" data-prefix="fa" data-icon="pen-alt" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M497.94 74.17l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.75 18.75-49.15 0-67.91zm-246.8-20.53c-15.62-15.62-40.94-15.62-56.56 0L75.8 172.43c-6.25 6.25-6.25 16.38 0 22.62l22.63 22.63c6.25 6.25 16.38 6.25 22.63 0l101.82-101.82 22.63 22.62L93.95 290.03A327.038 327.038 0 0 0 .17 485.11l-.03.23c-1.7 15.28 11.21 28.2 26.49 26.51a327.02 327.02 0 0 0 195.34-93.8l196.79-196.79-82.77-82.77-84.85-84.85z"></path></svg>' +
                                      '</button>' +
                                      ' <button class="btn btn-default" id="graffiti-highlight-pen" title="' + localizer.getString('HIGHLIGHTER_TOOL') + '">' +
                                      '<svg class="svg-inline--fa fa-highlighter fa-w-17" aria-hidden="true" data-prefix="fa" data-icon="highlighter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 544 512" data-fa-i2svg=""><path fill="currentColor" d="M0 479.98L99.92 512l35.45-35.45-67.04-67.04L0 479.98zm124.61-240.01a36.592 36.592 0 0 0-10.79 38.1l13.05 42.83-50.93 50.94 96.23 96.23 50.86-50.86 42.74 13.08c13.73 4.2 28.65-.01 38.15-10.78l35.55-41.64-173.34-173.34-41.52 35.44zm403.31-160.7l-63.2-63.2c-20.49-20.49-53.38-21.52-75.12-2.35L190.55 183.68l169.77 169.78L530.27 154.4c19.18-21.74 18.15-54.63-2.35-75.13z"></path></svg>' +
                                      '</button>' +
                                      ' <button class="btn btn-default" id="graffiti-eraser-pen" title="' + localizer.getString('ERASER_TOOL') + '">' +
                                      '<svg aria-hidden="true" data-prefix="fas" data-icon="eraser" class="svg-inline--fa fa-eraser fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M497.941 273.941c18.745-18.745 18.745-49.137 0-67.882l-160-160c-18.745-18.745-49.136-18.746-67.883 0l-256 256c-18.745 18.745-18.745 49.137 0 67.882l96 96A48.004 48.004 0 0 0 144 480h356c6.627 0 12-5.373 12-12v-40c0-6.627-5.373-12-12-12H355.883l142.058-142.059zm-302.627-62.627l137.373 137.373L265.373 416H150.628l-80-80 124.686-124.686z"></path></svg>' +
                                      '</button>' +
                                      '</div>' +
                                      '<div id="graffiti-recording-colors-shell">' +
                                      Object.keys(graffiti.penColors).map((key) => { 
                                        return '<div id="graffiti-recording-color-' + key + '" colorVal="' + key + '"></div>';
                                      }).join('') +
                                      '</div>' +
                                      '<div id="graffiti-line-style-controls">' +
                                      '  <div id="graffiti-temporary-ink" title="' + localizer.getString('USE_DISAPPEARING_INK') + '">' +
                                      '   <input type="checkbox" id="graffiti-temporary-ink-control" checked />' +
                                      '   <label id="graffiti-temporary-ink-label" for="graffiti-temporary-ink-control">' + localizer.getString('TEMPORARY_INK') + '</label>' +
                                      '  </div>' +
                                      '  <div id="graffiti-dashed-line" title="' + localizer.getString('USE_DASHED_LINES') + '">' +
                                      '   <input type="checkbox" id="graffiti-dashed-line-control" />' +
                                      '   <label id="graffiti-dashed-line-label" for="graffiti-dashed-line-control">' + localizer.getString('DASHED_LINES') + '</label>' +
                                      '  </div>' +
                                      '</div>',
                                      [
                                        {
                                          ids: ['graffiti-highlight-pen'],
                                          event: 'click',
                                          fn: (e) => {
                                            console.log('Graffiti: you picked highlighter tool.');
                                            graffiti.setGraffitiPenColor('yellow');
                                            graffiti.toggleGraffitiPen('highlight');
                                          }
                                        },
                                        {
                                          ids: ['graffiti-line-pen'],
                                          event: 'click',
                                          fn: (e) => {
                                            console.log('Graffiti: you picked line tool.');
                                            graffiti.toggleGraffitiPen('line');
                                          }
                                        },
                                        {
                                          ids: ['graffiti-eraser-pen'],
                                          event: 'click',
                                          fn: (e) => {
                                            console.log('Graffiti: you picked eraser tool.');
                                            graffiti.toggleGraffitiPen('eraser');
                                            $('#graffiti-temporary-ink-control').attr({checked:false});
                                            state.updateDrawingState([ { change: 'drawingModeActivated', data: true }, 
                                                                       { change: 'permanence', data: 'permanent' },
                                                                       { change: 'penType', data: 'eraser' }  ]);
                                          }
                                        },
                                        {
                                          ids: Object.keys(graffiti.penColors).map((key) => { return 'graffiti-recording-color-' + key }),
                                          event: 'click',
                                          fn: (e) => {
                                            const target = $(e.target);
                                            const colorVal = target.attr('colorVal');
                                            graffiti.setGraffitiPenColor(colorVal);
                                            // Turn on the pen/highlighter if you change pen color and not stickering
                                            const activePenType = state.getDrawingPenAttribute('type');
                                            if (activePenType !== 'sticker') {
                                              graffiti.activateGraffitiPen(state.getDrawingPenAttribute('type')); 
                                            }
                                          }
                                        },
                                        {
                                          ids: [ 'graffiti-temporary-ink-control', 'graffiti-temporary-ink-label' ],
                                          event: 'click',
                                          fn: (e) => {
                                            const permanence = ($('#graffiti-temporary-ink-control').is(':checked') ? 'temporary' : 'permanent');
                                            console.log('Graffiti: You set temporary ink to:', permanence);
                                            state.updateDrawingState([ { change: 'permanence', data: permanence } ]);
                                            // Turn on the pen/highlighter if you switch temporary ink status and it's not already on, unless stickering
                                            const activePenType = state.getDrawingPenAttribute('type');
                                            if (activePenType !== 'sticker') {
                                              graffiti.activateGraffitiPen(state.getDrawingPenAttribute('type')); 
                                            }
                                          }
                                        },
                                        {
                                          ids: [ 'graffiti-dashed-line-control', 'graffiti-dashed-line-label' ],
                                          event: 'click',
                                          fn: (e) => {
                                            const dashedLine = ($('#graffiti-dashed-line-control').is(':checked') ? 'dashed' : 'solid');
                                            console.log('Graffiti: You set dashed line to:', dashedLine);
                                            state.updateDrawingState([ { change: 'dash', data: dashedLine } ]);
                                            // Turn on the pen/highlighter if you switch dashed line status and not stickering
                                            const activePenType = state.getDrawingPenAttribute('type');
                                            if (activePenType !== 'sticker') {
                                              graffiti.activateGraffitiPen(state.getDrawingPenAttribute('type')); 
                                            }
                                          }
                                        }
                                      ]
        );

        const rightTriangle = stickerLib.makeRightTriangle(defaultIconConfiguration);
        const isocelesTriangle = stickerLib.makeIsocelesTriangle(defaultIconConfiguration);
        const rectangle = stickerLib.makeRectangle(largeIconConfiguration);
        const roundRectangle = stickerLib.makeRectangle(roundRectConfiguration);
        const checkMark = stickerLib.makeCheckmark(solidFatIconConfiguration);
        const xMark = stickerLib.makeXmark(solidFatIconConfiguration);
        const ribbon = stickerLib.makeRibbon(solidIconConfiguration)
        const axis = stickerLib.makeAxis(solidIconConfiguration)
        const grid = stickerLib.makeGrid(solidIconConfiguration);
        const bomb = stickerLib.makeBomb(defaultIconConfiguration);
        const trophy = stickerLib.makeTrophy(defaultIconConfiguration);
        const smiley = stickerLib.makeSmiley(solidIconConfiguration);
        const horizontalBrackets = stickerLib.makeHorizontalBrackets(defaultIconConfiguration);
        const verticalBrackets = stickerLib.makeVerticalBrackets(defaultIconConfiguration);
        const ellipse = stickerLib.makeEllipse(largeIconConfiguration);
        const bullsEye = stickerLib.makeBullsEye(largeIconConfiguration);
        const pi = stickerLib.makePi(solidIconConfiguration);
        const alpha = stickerLib.makeAlpha(solidIconConfiguration);
        const beta = stickerLib.makeBeta(solidIconConfiguration);
        const sigma = stickerLib.makeSigma(solidIconConfiguration);
        const theta = stickerLib.makeTheta(solidIconConfiguration);
        const angle = stickerLib.makeAngle(defaultIconConfiguration);
        const curlyBraces = stickerLib.makeSymmetricCurlyBraces(solidIconConfiguration);
        const lineWithArrow = stickerLib.makeLine({
          color:'black',
          dimensions: iconDimensions,
          endpoints: { p1: { x:-2, y:iconSize - 2 }, p2: { x:iconSize - 2, y:-2 } },
          lineStartOffset: { x: iconMargin - 2, y:iconMargin - 2 },
          strokeWidth:iconStrokeWidth,
          dashed:'solid',
          usesArrow:true, 
          arrowHeadSize: 10,
        });

        const stickersExpando = 
          '<div id="graffiti-stickers-expando" class="graffiti-expando graffiti-expando-closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" x="0px" y="0px"><title>triangolo</title><g data-name="Livello 11"><polygon points="50 87.5 6.7 87.5 28.35 50 50 12.5 71.65 50 93.3 87.5 50 87.5"/></g></svg></div>';

        graffiti.setupOneControlPanel('graffiti-stickers-controls', 
                                      '<div id="graffiti-stickers-shell">' +
                                      '  <div id="graffiti-stickers-header">' + stickersExpando + '<div>Stickers <span>(Select, then click & drag)</span></div></div>' +
                                      '  <div id="graffiti-stickers-body">' +
                                      '    <div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-lineWithArrow" title="Line with arrow at tip">' + 
                                      lineWithArrow + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-horizontalBrackets" title="Horizontal brackets">' +
                                      horizontalBrackets + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-verticalBrackets" title="Vertical brackets">' + 
                                      verticalBrackets + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-curlyBraces" title="Curly braces">' + curlyBraces + '</div>' +
                                      '    </div>' +
                                      '    <div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-rectangle" title="Rectangle">' + rectangle + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-roundRectangle" title="Rounded corners rectangle">' +
                                      roundRectangle + '</div>' +
                                      //'      <div class="graffiti-stickers-button" id="graffiti-sticker-ellipse" title="Ellipse">' + ellipse + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-ellipse" title="Ellipse">' + bullsEye + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-rightTriangle" title="Right triangle">' + rightTriangle + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-isocelesTriangle" title="Isoceles triangle">' + 
                                      isocelesTriangle + '</div>' +
                                      '    </div>' +
                                      '    <div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-checkmark" title="Checkmark">' + checkMark + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-xmark" title="X mark">' + xMark + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-smiley" title="Smiley face">' + smiley + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-bomb" title="Bomb">' + bomb + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-trophy" title="Trophy">' + trophy + '</div>' +
                                      '    </div>' +
                                      '    <div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-pi" title="Pi symbol">' + pi + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-alpha"  title="Alpha symbol">' + alpha + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-beta" title="Beta symbol">' + beta + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-sigma" title="Sigma symbol">' + sigma + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-theta"  title="Theta symbol">' + theta + '</div>' +
                                      '    </div>' +
                                      '    <div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-axis" title="X-y axis">' + axis + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-grid" title="Square grid">' + grid + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-angle" title="Angle">' + angle + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-label" title="Text label">' + 'Tt' + '</div>' +
                                      '      <div class="graffiti-stickers-button" id="graffiti-sticker-custom" title="Custom sticker">' + 'Cs' + '</div>' +
                                      '    </div>' +
                                      '  </div>' +
                                      '  <div id="graffiti-sticker-style-controls">' +
                                      '    <div id="graffiti-sticker-fill">' +
                                      '     <input type="checkbox" id="graffiti-sticker-fill-control" />' +
                                      '     <label id="graffiti-sticker-fill-control-label" for="graffiti-sticker-fill-control" title="Fill shapes with chosen color">' +
                                      localizer.getString('SOLID_FILL') + '</label>' +
                                      '    </div>' +
                                      '    <div id="graffiti-sticker-hint">' + localizer.getString('SHIFT_KEY_ALIGN') + '</div>' +
                                      '  </div>' +
                                      '</div>',
                                      [
                                        {
                                          ids: [
                                            'graffiti-sticker-rightTriangle',
                                            'graffiti-sticker-isocelesTriangle',
                                            'graffiti-sticker-rectangle', 
                                            'graffiti-sticker-roundRectangle',
                                            'graffiti-sticker-lineWithArrow',
                                            'graffiti-sticker-checkmark',
                                            'graffiti-sticker-xmark',
                                            'graffiti-sticker-grid',
                                            'graffiti-sticker-angle',
                                            'graffiti-sticker-ribbon',
                                            'graffiti-sticker-alpha',
                                            'graffiti-sticker-beta',
                                            'graffiti-sticker-sigma',
                                            'graffiti-sticker-theta',
                                            'graffiti-sticker-axis',
                                            'graffiti-sticker-bomb',
                                            'graffiti-sticker-trophy',
                                            'graffiti-sticker-smiley',
                                            'graffiti-sticker-horizontalBrackets',
                                            'graffiti-sticker-verticalBrackets',
                                            'graffiti-sticker-curlyBraces',
                                            'graffiti-sticker-ellipse',
                                            'graffiti-sticker-pi',
                                            'graffiti-sticker-label',
                                            'graffiti-sticker-custom'
                                          ],
                                          event: 'click',
                                          fn: (e) => {
                                            let stickerId = $(e.target).attr('id');
                                            if (stickerId === undefined) {
                                              stickerId = $(e.target).parents('.graffiti-stickers-button').attr('id');
                                            }
                                            const cleanStickerId = stickerId.replace('graffiti-sticker-','');
                                            console.log('Graffiti: Sticker chosen:', cleanStickerId);
                                            graffiti.toggleGraffitiSticker(cleanStickerId);
                                          }
                                        },
                                        {
                                          ids: [ 'graffiti-stickers-header' ],
                                          event: 'click',
                                          fn: (e) => {
                                            $('#graffiti-stickers-body,#graffiti-sticker-style-controls').slideToggle(200);
                                            if ($('#graffiti-stickers-expando').hasClass('graffiti-expando-closed')) {
                                              $('#graffiti-stickers-expando').removeClass('graffiti-expando-closed').addClass('graffiti-expando-open');
                                              setTimeout(() => {
                                                graffiti.windowResizeHandler({force:true});
                                              }, 400);
                                            } else {
                                              $('#graffiti-stickers-expando').removeClass('graffiti-expando-open').addClass('graffiti-expando-closed');
                                            }
                                          },
                                        },
                                        {
                                          ids: [ 'graffiti-sticker-fill-control', 'graffiti-sticker-fill-control-label' ],
                                          event: 'click',
                                          fn: (e) => {
                                            state.updateDrawingState([ { change: 'fillOpacity', 
                                                                         data: $('#graffiti-sticker-fill-control').is(':checked') ? 1 : 0 } ]);
                                          }
                                        }
                                      ]
        );                                        

        graffiti.setupOneControlPanel('graffiti-access-api',
                                      '<button class="btn btn-default" id="graffiti-access-api-btn" title="' + localizer.getString('SAMPLE_API') + '"></i>&nbsp; <span>' +
                                      localizer.getString('SAMPLE_API') + '</span></button>',
                                      [
                                        { 
                                          ids: ['graffiti-access-api-btn'],
                                          event: 'click', 
                                          fn: (e) => { 
                                            console.log('Graffiti: API key is:', graffiti.recordingAPIKey);
                                            graffiti.provideAPIKeyExamples();
                                          }
                                        }
                                      ]
        );
        
        const lockConfigOn =  $.extend({}, true, defaultIconConfiguration, { color: 'red' });
        const lockConfigOff = $.extend({}, true, defaultIconConfiguration, { color: 'green' });
        const hiddenCellConfiguration = $.extend({}, true, defaultIconConfiguration, { color: '#aaa', fillOpacity: 1.0 });

        // Build the "extras" panel

        graffiti.setupOneControlPanel('graffiti-terminal-builder',
                                      '<div id="graffiti-terminal-builder-header"><div>Extras</div></div>' +
                                      '<div id="graffiti-terminal-builder-body">' +

                                      '  <div>' + 
                                      '    <div id="graffiti-insert-terminal-cell" title="' + localizer.getString('INSERT_GRAFFITI_TERMINAL_ALT_TAG') + '">' +
                                      stickerLib.makeTerminal({width:25}) + 
                                      '    </div>' +

                                      '    <div id="graffiti-insert-btn-cell" title="' + localizer.getString('INSERT_GRAFFITI_BUTTON_CELL_ALT_TAG') + '">' +
                                      stickerLib.makeButton({width:27, height:22, contents:'Run'}) + 
                                      '    </div>' +

                                      '    <div id="graffiti-insert-terminal-suite" title="' + localizer.getString('INSERT_GRAFFITI_TERMINAL_SUITE_ALT_TAG') + '">' +
                                      '      <div>' + stickerLib.makeTerminal({width:25}) + '</div> + ' +
                                      '      <div>' + stickerLib.makeButton({width:27, height:22, contents:'Run'}) + '</div>' +
                                      '    </div>' +

                                      '  </div>' +
                                      '  <div>' + 

                                      '    <div class="graffiti-stickers-button" id="graffiti-create-showhide-button" title="' + 
                                      localizer.getString('CREATE_SHOWHIDE_BUTTON') + '">' + stickerLib.makeHidden(hiddenCellConfiguration) +
                                      '    </div>' +

                                      '    <div class="graffiti-stickers-button" id="graffiti-toggle-markdown-lock" title="' + 
                                      localizer.getString('ACTIVATE_LOCK_ALT_TAG') + '">' +
                                      '<span id="graffiti-locked-on">' + stickerLib.makeLock(lockConfigOn) + '</span>' +
                                      '<span id="graffiti-locked-off">' + stickerLib.makeLock(lockConfigOff) + '</span>' +
                                      '    </div>' +

                                      '  </div>' +
                                      '</div>',
                                      [
                                        { 
                                          ids: ['graffiti-insert-btn-cell'],
                                          event: 'click', 
                                          fn: (e) => { 
                                            console.log('Graffiti: Inserting graffiti button cell')
                                            const suite = graffiti.createGraffitiButtonAboveSelectedCell();
                                            utils.saveNotebook();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-insert-terminal-cell'],
                                          event: 'click', 
                                          fn: (e) => { 
                                            console.log('Graffiti: inserting graffiti terminal cell')
                                            const suite = terminalLib.createTerminalCellAboveSelectedCell();
                                            utils.saveNotebook();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-insert-terminal-suite'],
                                          event: 'click', 
                                          fn: (e) => { 
                                            console.log('Graffiti: inserting graffiti terminal suite')
                                            const suite = graffiti.createTerminalSuiteAboveSelectedCell();
                                            utils.saveNotebook();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-toggle-markdown-lock'],
                                          event: 'click', 
                                          fn: (e) => { 
                                            console.log('Toggle markdown lock')
                                            graffiti.toggleMarkdownLock();
                                            utils.saveNotebook();
                                          }
                                        },
                                        {
                                          ids: ['graffiti-create-showhide-button'],
                                          event: 'click', 
                                          fn: (e) => { 
                                            console.log('Creating show/hide btn')
                                            graffiti.createGraffitiButtonAboveSelectedCell({
                                              tooltipCommands: { 
                                                insertDataFromFile: {
                                                  cellType: 'code',
                                                  filePath: './example.txt',
                                                },
                                                swappingLabels: true,
                                                labelSwaps: ['Show Solution','Hide Solution'],
                                                silenceWarnings: true
                                              },
                                              tooltipDirectives: [
                                                '%%insert_data_from_file code ./example.txt',
                                                '%%label_swaps Show Solution|Hide Solution',
                                                '%%silence_warnings',
                                              ],
                                            });
                                            utils.saveNotebook();
                                          }
                                        }
                                      ]
        );
        graffiti.refreshMarkdownLock();

        // Will return to this code soon. It simulates multiple creators (e.g. students) and switching between their different sets of Graffiti.
        /*
           const creatorsTitle = 'Graffitis by:'.split('').join('&nbsp;');
           graffiti.setupOneControlPanel('graffiti-creators-chooser',
           '<div id="graffiti-creators-chooser">' +
           ' <div id="graffiti-creators-chooser-title">' + creatorsTitle + '</div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h1.jpeg"></div>' +
           '    <div>Stacy M.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h2.jpeg"></div>' +
           '    <div>Bobby P.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h3.jpeg"></div>' +
           '    <div>Akarnam J.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h4.jpeg"></div>' +
           '    <div>James R.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h5.jpeg"></div>' +
           '    <div>Amanda M.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h6.jpeg"></div>' +
           '    <div>Aimee E.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h7.jpeg"></div>' +
           '    <div>Lena Y.</div>' +
           ' </div>' +
           ' <div id="graffiti-creators-chooser-show-all">' +
           '  <input type="checkbox" id="chooser-show-all" /><label for="chooser-show-all">&nbsp;Show All Graffitis</label>' +
           ' </div>' +
           '</div>'
           );
         */

      },

      setupMarkdownLocks: () => {
        graffiti.oldUnrender = graffiti.MarkdownCell.prototype.unrender;
        graffiti.MarkdownCell.prototype.unrender = () => {
          // console.log('Unrender fired.');
          const cell = Jupyter.notebook.get_selected_cell();
          if (cell !== undefined) {
            const cellId = utils.getMetadataCellId(cell.metadata);
            const markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
            if (markdownLocked === true || terminalLib.isTerminalCell(cellId)) {
              console.log('Graffiti: Not unrendering markdown cell, since Graffiti lock in place or is terminal cell.');
            } else {
              console.log('Graffiti: applying old unrender call, cellId', cellId);
              graffiti.oldUnrender.apply(cell, arguments);
              window.brokeCell = cell;
            }
          }
        }
      },

      refreshMarkdownLock: (isLocked) => {
        if (isLocked === undefined) {
          const markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
          isLocked = (((markdownLocked !== undefined) && (markdownLocked === true)) ? true : false);
        }
        if (isLocked) {
          $('#graffiti-locked-off').hide();
          $('#graffiti-locked-on').show();
        } else {
          $('#graffiti-locked-off').show();
          $('#graffiti-locked-on').hide();
        }
        return(isLocked);
      },

      toggleMarkdownLock: () => {
        const markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
        const isLocked = (markdownLocked === true ? true : false);
        const verb = (isLocked ? localizer.getString('UNLOCK_VERB') : localizer.getString('LOCK_VERB'));
        const bodyText = (isLocked ?
                          localizer.getString('UNLOCK_BODY') :
                          localizer.getString('LOCK_BODY') );
        dialog.modal({
          title: verb + ' ' + localizer.getString('LOCK_CONFIRM'),
          body: bodyText,
          sanitize:false,
          buttons: {
            'OK': {
              click: (e) => {
                console.log('Graffiti: You clicked ok, you want to toggle the lock');
                const markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
                const isLocked = (((markdownLocked !== undefined) && (markdownLocked === true)) ? true : false);
                utils.setNotebookGraffitiConfigEntry('markdownLocked', !isLocked);
                utils.saveNotebook();
                graffiti.refreshMarkdownLock(!isLocked);
              }
            },
            'Cancel': { click: (e) => { console.log('Graffiti: you cancelled:', $(e.target).parent()); } },
          }
        });
      },

      setSitePanelScrollTop: (scrollTop) => {
        // console.log('Setting sitepanel to scrolltop:', newScrollTop);
        graffiti.sitePanel.scrollTop(scrollTop);
      },
      
      showControlPanels: (panels) => {
        graffiti.controlPanelsShell.children().hide();
        graffiti.controlPanelIds['graffiti-control-panel-title'].css({display:'flex'}); // the title bar is always shown
        for (controlPanelId of panels) {
          // console.log('Graffiti: showing panel:', controlPanelId);
          graffiti.controlPanelIds[controlPanelId].show();
        }
      },

      updateActiveTakeId: (recordingCellId, recordingKey, activeTakeId) => {
        storage.updateSingleManifestRecordingField(recordingCellId, recordingKey, 'activeTakeId', activeTakeId);
        state.setPlayableMovie('cursorActivity', recordingCellId, recordingKey);
        graffiti.updateTakesPanel(recordingCellId, recordingKey);
      },

      updateTakesPanel: (recordingCellId, recordingKey) => {
        const recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
        const activeTakeId = recording.activeTakeId;
        if ((activeTakeId === undefined) || (recording.takes === undefined)) {
          return false;
        }
        //console.log('updateTakesPanel, recordingCellId, recordingKey, recording', recordingCellId, recordingKey, recording);
        //console.log('we got these takes:', recording.takes);
        let renderedTakes = '';
        const sortedRecs = _.sortBy($.map(recording.takes, (val,key) => { return $.extend(true, {}, val, { key: key }) }), 'createDate')
        //console.log('sorted recs are:', sortedRecs, 'from takes', recording.takes);
        let recIndex, recIndexZerobased, createDateFormatted, renderedDate, rec, takeClass;
        for (recIndex = sortedRecs.length; recIndex > 0; --recIndex) {
          recIndexZerobased = recIndex - 1;
          rec = sortedRecs[recIndexZerobased];
          renderedDate = localizer.getString('RECORDED_ON') + ': ' + new Date(rec.createDate);
          takeClass = ((rec.key === activeTakeId) ? 'graffiti-take-selected' : 'graffiti-take-unselected');
          renderedTakes += '<div ' +
                           'class="' + takeClass + ' graffiti-take-item" ' +
                           'id="' + rec.key + '" ' +
                           'recordingCellId="' + recordingCellId + '" ' +
                           'recordingKey="' + recordingKey + '" ' +
                           'title="' + renderedDate + '">' + recIndex + 
                           '</div>';
        }
        $('#graffiti-takes-list').html(renderedTakes);
        return true;
      },

      updateControlPanels: (cm) => {
        // When we transition to a new state, control panel tweaks need to be made
        const activity = state.getActivity();
        // console.log('Graffiti: updateControlPanels, activity:', activity);
        const accessLevel = state.getAccessLevel();
        const outerControlHidden = graffiti.outerControlPanel.css('display') === 'none';
        if (accessLevel === 'view') {
          if (activity !== 'idle') {
            if (outerControlHidden) {
              //console.trace('fadeIn 1');
              // fadeins/fadeouts cause race conditions when you interrupt a movie in progress
              //graffiti.outerControlPanel.fadeIn(graffiti.panelFadeTime);
              graffiti.outerControlPanel.show();
            }
          } else if ((state.getPlayableMovie('tip') === undefined) && 
                     (state.getPlayableMovie('api') === undefined) && 
                     (state.getPlayableMovie('cursorActivity') === undefined) ||
                     (activity !== 'notifying') ) {
            if (!outerControlHidden) {
              //console.trace('fadeout');
              // fadeins/fadeouts cause race conditions when you interrupt a movie in progress
              //graffiti.outerControlPanel.fadeOut(graffiti.panelFadeTime);
              graffiti.outerControlPanel.hide();
            }
            return;
          }
        } else {
          if (outerControlHidden) {
            //console.trace('fadeIn 2');
              // fadeins/fadeouts cause race conditions when you interrupt a movie in progress
            //graffiti.outerControlPanel.fadeIn(graffiti.panelFadeTime);
            graffiti.outerControlPanel.show();
          }
        }

        // These controls will need to be updated in a variety of activities so easiest just to do their updates in all cases.
        if (state.getMute()) {
          graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-sound-on-btn').hide().parent().find('#graffiti-sound-off-btn').show();
        } else {
          graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-sound-off-btn').hide().parent().find('#graffiti-sound-on-btn').show();
        }
        const currentPlaySpeed = state.getCurrentPlaySpeed();
        graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rewind-btn').attr({title:localizer.getString('SKIP_BACK') + ' ' + graffiti.rewindAmt + ' ' + localizer.getString('SECONDS')});
        graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-forward-btn').attr({title:localizer.getString('SKIP_FORWARD') + ' ' + graffiti.rewindAmt + ' ' + localizer.getString('SECONDS')});
        switch (currentPlaySpeed) {
          case 'scanActive':
          case 'scanInactive':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidscan-on-btn').hide().parent().find('#graffiti-rapidscan-off-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidplay-off-btn').hide().parent().find('#graffiti-rapidplay-on-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rewind-btn').attr({title:localizer.getString('SKIP_BACK') + ' ' +
                                                                                                            localizer.getString('TO_PREVIOUS_SENTENCE')});
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-forward-btn').attr({title:localizer.getString('SKIP_FORWARD') + ' ' +
                                                                                                             localizer.getString('TO_NEXT_SENTENCE')});
            break;
          case 'rapid':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidscan-off-btn').hide().parent().find('#graffiti-rapidscan-on-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidplay-on-btn').hide().parent().find('#graffiti-rapidplay-off-btn').show();
            break;
          case 'regular':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidplay-off-btn').hide().parent().find('#graffiti-rapidplay-on-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidscan-off-btn').hide().parent().find('#graffiti-rapidscan-on-btn').show();
            break;
        }

        let visibleControlPanels;
        switch (activity) {
          case 'idle':
            // Check if anchor or head of current selection is inside an existing recording token set. Controls will be different if so.
            let activeCell;
            if (cm === undefined) {
              activeCell = Jupyter.notebook.get_selected_cell();
            } else {
              activeCell = utils.findCellByCodeMirror(cm);
            }
            graffiti.selectedTokens = utils.findSelectionTokens(activeCell, graffiti.tokenRanges, state);
            const selectedTokens = graffiti.selectedTokens;
            //console.log('Graffiti: selectedTokens:', selectedTokens);
            graffiti.highlightIntersectingGraffitiRange();
            const isMarkdownCell = (activeCell.cell_type === 'markdown');
            if (isMarkdownCell && !selectedTokens.isIntersecting) {
              // swap out the CREATE and RECORD strings depending on what type of new Graffiti could possibly be made
              $('#graffiti-create-btn').attr({title: localizer.getString('CREATE_2')});
              $('#graffiti-create-btn span').text(localizer.getString('CREATE_2'));
            } else {
              $('#graffiti-create-btn').attr({title: localizer.getString('CREATE_1')});
              $('#graffiti-create-btn span').text(localizer.getString('CREATE_1'));
            }

            if ((selectedTokens.noTokensPresent) ||
                (!isMarkdownCell && (selectedTokens.range.selectionStart === selectedTokens.range.selectionEnd) && 
                 (!selectedTokens.isIntersecting)) ||
                (isMarkdownCell && activeCell.rendered)) {
              //console.log('Graffiti: no tokens present, or no text selected.');
              visibleControlPanels = ['graffiti-notifier', 'graffiti-terminal-builder']; // hide all control panels if in view only mode and not play mode
              if (isMarkdownCell) {
                if (!activeCell.rendered) {
                  graffiti.setNotifier('<div>' + localizer.getString('SELECT_SOME_TEXT_MARKDOWN') + '</div>');
                } else {
                  graffiti.setNotifier('<div>' + localizer.getString('EDIT_IN_MARKDOWN_CELL') + '</div>');
                }
              } else {
                graffiti.setNotifier('<div>' + localizer.getString('SELECT_SOME_TEXT_PLAIN') + '</div>');
              }
            } else if (accessLevel === 'view') {
              console.log('Graffiti: view only');
              visibleControlPanels = ['graffiti-playback-controls']; // hide all control panels if in view only mode and not play mode
            } else {
              visibleControlPanels = ['graffiti-record-controls'];
              graffiti.controlPanelIds['graffiti-record-controls'].
                       find('#graffiti-begin-recording-btn').hide().
                       parent().find('#graffiti-begin-rerecording-btn').hide().
                       parent().find('#graffiti-remove-btn').hide();
              graffiti.controlPanelIds['graffiti-record-controls'].
                       find('#graffiti-create-btn').show().
                       parent().find('#graffiti-edit-btn').hide();
              if (selectedTokens.isIntersecting) {
                // console.log('Graffiti: updating recording controls');
                graffiti.highlightIntersectingGraffitiRange();
                graffiti.controlPanelIds['graffiti-record-controls'].
                         find('#graffiti-create-btn').hide().
                         parent().find('#graffiti-edit-btn').show().
                         parent().find('#graffiti-begin-recording-btn').show().
                         parent().find('#graffiti-remove-btn').show();
                //console.log('selectedTokens:', selectedTokens);
                state.clearPlayableMovie('cursorActivity');
                if (selectedTokens.hasMovie) {
                  // Give priority to the tag cellId, not the id of the cell where the graffiti is found currently, when tracking down the recording.
                  const recordingCellId = utils.extractRecordingCellId(selectedTokens);
                  const recordingKey = selectedTokens.recordingKey;
                  state.setPlayableMovie('cursorActivity', recordingCellId, recordingKey);
                  graffiti.recordingAPIKey = utils.composeGraffitiId(recordingCellId, recordingKey);
                  visibleControlPanels.push('graffiti-access-api');
                  visibleControlPanels.push('graffiti-notifier');
                  if (graffiti.updateTakesPanel(recordingCellId, recordingKey)) {
                    visibleControlPanels.push('graffiti-takes-controls');
                    graffiti.setNotifier('<div>' + localizer.getString('YOU_CAN_PLAY_VIA_TOOLTIP') + '</div>');
                  } else {
                    graffiti.setNotifier('<div>' + localizer.getString('NO_MOVIE_RECORDED_YET') + '</div>');
                  }

                  //console.log('this recording has a movie');
                  graffiti.controlPanelIds['graffiti-record-controls'].find('#graffiti-begin-recording-btn').hide().parent().
                           find('#graffiti-begin-rerecording-btn').show();
                  // This "play" link is not reliable because its info is only updated by mousing over tooltips, yet you may be editing
                  // a graffiti that you did not show the tooltip on, making it play the wrong movie. Therefore we instruct users to use the tooltip to play the movie.
                  /*
                     graffiti.setNotifier('<div>You can <span class="graffiti-notifier-link" id="graffiti-idle-play-link">play</span> this movie any time.</div>',
                     [
                     {
                     ids: ['graffiti-idle-play-link'],
                     event: 'click',
                     fn: (e) => {
                     state.setPlayableMovie('cursorActivity', recordingCellId, recordingKey);
                     graffiti.loadAndPlayMovie('cursorActivity');
                     }
                     },
                     ]);
                   */
                }
              }
            }
            graffiti.showControlPanels(visibleControlPanels);
            break;
          case 'playbackPending':
            graffiti.setNotifier('<div>' + localizer.getString('LOADING') + '</div>');
            visibleControlPanels = ['graffiti-notifier'];
            graffiti.showControlPanels(visibleControlPanels);
            break;
          case 'playing':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-play-btn').hide().parent().find('#graffiti-pause-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-info').hide();
            const narratorName = state.getNarratorInfo('name');
            const narratorPicture = state.getNarratorInfo('picture');
            if ((narratorName !== undefined) || (narratorPicture !== undefined)) {
              graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-info').show();
              if (narratorPicture !== undefined) {
                graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-pic').html('<img src="' + narratorPicture + '" />');
              }
              if (narratorName !== undefined) {
                graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-name').html(narratorName);
              }              
            }
            visibleControlPanels = ['graffiti-playback-controls'];
            graffiti.showControlPanels(visibleControlPanels);
            break;
          case 'playbackPaused':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-pause-btn').hide().parent().find('#graffiti-play-btn').show();
            visibleControlPanels = ['graffiti-playback-controls'];
            graffiti.showControlPanels(visibleControlPanels);
            break;
          case 'graffiting':
            graffiti.showControlPanels(['graffiti-finish-edit-controls']);
            graffiti.setNotifier('<div>' + localizer.getString('ENTER_AND_SAVE') + '</div>' +
                                 '<div>' + localizer.getString('CANCEL_CHANGES_1') + '</div>',
                                 [
                                   {
                                     ids: ['graffiti-cancel-graffiting-link'],
                                     event: 'click',
                                     fn: (e) => {
                                       graffiti.finishGraffiti(false);
                                     }
                                   }
                                 ]);
            break;
          case 'recordingPending':
            graffiti.showControlPanels([]);
            graffiti.setNotifier('<div>' + localizer.getString('CLICK_BEGIN_MOVIE_RECORDING') + '</div>',
                                 [
                                   {
                                     ids: ['graffiti-cancel-recording-pending-link'],
                                     event: 'click',
                                     fn: (e) => {
                                       graffiti.finishGraffiti(false);
                                     }
                                   },
                                 ]);
            break;
          case 'recording':
            graffiti.showControlPanels(['graffiti-recording-controls', 'graffiti-recording-pen-controls','graffiti-stickers-controls']);
            graffiti.setNotifier('<div>' + localizer.getString('ACTIVITIES_BEING_RECORDED') + '</div>' +
                                 '<div>' + localizer.getString('CANCEL_RECORDING_2') + '</div>',
                                 [
                                   {
                                     ids: ['graffiti-end-recording-link'],
                                     event: 'click',
                                     fn: (e) => {
                                       graffiti.toggleRecording();
                                     }
                                   },
                                   {
                                     ids: ['graffiti-cancel-recording-link'],
                                     event: 'click',
                                     fn: (e) => {
                                       graffiti.cancelRecording();
                                     }
                                   }
                                 ]);
            break;
          case 'notifying': // Just showing notifier alone. Used when prompting user to play a graffiti with the notifier
            graffiti.showControlPanels(['graffiti-notifier']);
            break;
          case 'scrubbing':
            // do nothing special while scrubbing
            break;
          default:
            console.log('Graffiti: updateControlPanels hit unknown activity:', activity);
            break;
        }

        graffiti.performWindowResizeCheck();
      },

      placeControlPanel: (opts) => {
        let position, newPosition;
        const pointerPosition = state.getPointerPosition();
        const panelBbox = graffiti.sitePanel[0].getBoundingClientRect();
        const controlPanelWidth = graffiti.outerControlPanel.width();
        const controlPanelHeight = graffiti.outerControlPanel.height();
        const pixelBuffer = 25;
        if (opts.nearAction !== undefined) {
          // Position control panel off to the right of the action.
          position = { 
            x: pointerPosition.x + panelBbox.width, 
            y: pointerPosition.y - controlPanelHeight / 2 - pixelBuffer,
          };  
        } else if (opts.keepInView !== undefined) {
          // Try to keep the control panel in view if cut off.
          const bbox = graffiti.outerControlPanel[0].getBoundingClientRect();
          position = { x: bbox.left, y: bbox.top };
          const windowWidth = $(window).width();
          const windowHeight = $(window).height();
          const headerHeight = $('#header').height();
          if (bbox.left < 0) {
            position.x = pixelBuffer;
          } else if (bbox.right > windowWidth) {
            position.x = windowWidth - (controlPanelWidth + pixelBuffer);
          }            
          if (bbox.top < headerHeight) {
            position.y = headerHeight + pixelBuffer;
          } else if (bbox.top > windowHeight) {
            position.y = windowHeight - (controlPanelHeight + pixelBuffer);
          }
        } else if (opts.position !== undefined) {
          // Hardwire the control panel to a fixed spot
          position = opts.position;
        } else if (state.getControlPanelDragging()) {
          const offset = state.getControlPanelDragOffset();
          position = { x: pointerPosition.x - offset.left, y: pointerPosition.y - offset.top };
        }
        if (position !== undefined) {
          // Make sure the control panel stays on screen
          const firstCell = Jupyter.notebook.get_cell(0);
          const firstElem = firstCell.element[0];
          const firstElemBbox = firstElem.getBoundingClientRect();
          const constrainedLeft = Math.min(firstElemBbox.right - controlPanelWidth - pixelBuffer, Math.max(0,position.x));
          //const constrainedTop = Math.min(panelBbox.bottom - controlPanelHeight - pixelBuffer, Math.max(pixelBuffer,position.y));
          const constrainedTop = Math.min(panelBbox.bottom - controlPanelHeight - pixelBuffer, Math.max(pixelBuffer,position.y));
          newPosition = { left: constrainedLeft, top: constrainedTop };
          const newPositionPx = { top: newPosition.top + 'px', left: newPosition.left + 'px' };
          graffiti.outerControlPanel.css(newPositionPx);
        }
      },

      initInteractivity: () => {
        graffiti.notebookContainer.click((e) => {
          // console.log('Graffiti: clicked container');
          if (state.getActivity() === 'recordingPending') {
            console.log('Graffiti: Now starting movie recording');
            graffiti.toggleRecording();
          }
          return true;
        });
        audio.setAudioStorageCallback(storage.storeMovie);
        graffiti.addCMEvents();
        graffiti.refreshGraffitiTooltipsDebounced = _.debounce(graffiti.refreshGraffitiTooltips, 100, false);
        setTimeout(() => { 
          graffiti.setupBackgroundEvents();
          graffiti.refreshAllGraffitiHighlights();
          graffiti.refreshGraffitiTooltipsDebounced();
        }, 500); // this timeout avoids too-early rendering of hidden recorder controls

        graffiti.setupControlPanels();
        graffiti.updateControlPanels();
        graffiti.setupDrawingScreen();
        graffiti.setupSavingScrim();
        graffiti.playAutoplayGraffiti(); // play any autoplay graffiti if there is one set up
        graffiti.setupMarkdownLocks();

        state.refreshCellIdToGraffitiMap();
        graffiti.executeSaveToFileDirectivesDebounced = _.debounce(graffiti.executeSaveToFileDirectives, 750, false);

        terminalLib.init(graffiti.handleTerminalsEvents);
        graffiti.executeAllSaveToFileDirectives(); // autosave any cells that are set up with saveToFile directives pointed at them

        storage.preloadAllMovies();

/*
        let body = '<div>Enter the Graffiti Hub Key to import Graffiti into this notebook.</div>';
        body += '<div style="font-weight:bold;margin-top:15px;">Key: <input type="text" value="R5a7Hb"/ width="60"></div>';
        body += '<div style="font-style:italic; color:green;">(Author: N. Vishalyam)</div>';
        dialog.modal({
          title: 'Import Graffiti from GraffitiHub?',
          body: body,
          sanitize:false,
          buttons: {
            'Import': {
              click: (e) => {
                console.log('Graffiti: You clicked Import');
              }
            },
            'Cancel': {
              click: (e) => {
                console.log('Graffiti: You clicked Cancel');
              }
            }
          }
        });
*/
        
      },

      setGraffitiPenColor: (colorVal) => {
        const activePenType = state.getDrawingPenAttribute('type');
        if (activePenType === 'highlight') {
          if (colorVal === 'black') {
            console.log('Graffiti: black is not choosable when using the highlighter');
            return;
          }
        }

        $('#graffiti-recording-colors-shell div').removeClass('graffiti-recording-color-active');
        console.log('Graffiti: you clicked color:', colorVal);
        state.updateDrawingState([ { change: 'color', data: colorVal } ]);
        $('#graffiti-recording-color-' + colorVal).addClass('graffiti-recording-color-active');
      },

      activateGraffitiPen: (penType) => {
        if (!(state.getActivity() == 'recording')) {
          return; // Pens can only be used while recording
        }
        if (penType === undefined) {
          penType = 'line';
        }
        graffiti.showDrawingScreen();
        $('.graffiti-active-pen').removeClass('graffiti-active-pen');
        let penControl = $('#graffiti-' + penType + '-pen');
        if (penControl.length > 0 && !(penControl.hasClass('btn'))) {
          penControl = penControl.parents('.btn');
        }
        penControl.addClass('graffiti-active-pen');
        // Turn on drawing (if it's not already on), and activate this pen type
        state.updateDrawingState([ 
          { change: 'drawingModeActivated', data: true}, 
          { change: 'stickerType', data: undefined },
          { change: 'penType', data: penType } 
        ]);
      },

      deactivateAllPens: () => {
        graffiti.setGraffitiPenColor('black');
        state.updateDrawingState([ 
          { change: 'drawingModeActivated', data: false}, 
          { change: 'stickerType', data: undefined },
          { change: 'penType', data: undefined } 
        ]);
        $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
        $('.graffiti-active-pen').removeClass('graffiti-active-pen');
      },

      toggleGraffitiPen: (penType) => {
        if (!(state.getActivity() == 'recording')) {
          return; // Pens can only be used while recording
        }
        const activePenType = state.getDrawingPenAttribute('type');
        graffiti.hideLabelInputBoxes();
        if (activePenType !== penType) {
          // Activate a new active pen, unless this pen is already active, in which case, deactivate it
          graffiti.activateGraffitiPen(penType);
          $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
        } else {
          // turn off the active pen and drawing
          $('.graffiti-active-pen').removeClass('graffiti-active-pen');
          // Disable drawing
          state.updateDrawingState([ 
            { change: 'drawingModeActivated', data: false },
            { change: 'stickerType', data: undefined },
            { change: 'penType', data: undefined } 
          ]);
          graffiti.hideDrawingScreen();
        }          

        if (activePenType === 'highlight') {
          // When switching from highlight to pen or eraser, always go to black color because
          // usual color for highlighter is yellow which looks crappy in the line mode.
          graffiti.setGraffitiPenColor('black');
        }
      },

      toggleGraffitiSticker: (stickerType) => {
        if (!(state.getActivity() == 'recording')) {
          return; // Stickers can only be used while recording
        }
        const activePenType = state.getDrawingPenAttribute('type');
        const activeStickerType = state.getDrawingPenAttribute('stickerType');
        if (activeStickerType !== stickerType) {
          // Activate a new sticker, unless sticker is already active, in which case, deactivate it
          graffiti.hideLabelInputBoxes();
          graffiti.clearAnyActiveStickerStages();
          graffiti.showDrawingScreen();
          // Deactivate any active pen
          $('.graffiti-active-pen').removeClass('graffiti-active-pen');
          const stickerControl = $('#graffiti-sticker-' + stickerType);
          $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
          stickerControl.addClass('graffiti-active-sticker');
          state.updateDrawingState([
            { change: 'drawingModeActivated', data: true}, 
            { change: 'stickerType', data: stickerType },
            { change: 'penType', data: 'sticker' }
          ]);          
          if (activePenType === 'highlight') {
            // If we were highlighting, it was probably yellow. we probably don't want that color
            // when switching back to stickering.
            graffiti.setGraffitiPenColor('black'); 
          }
        } else {
          // Turn off the active sticker control.
          graffiti.hideLabelInputBoxes();
          $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
          // Disable stickering
          state.updateDrawingState([ 
            { change: 'drawingModeActivated', data: false },
            { change: 'stickerType', data: undefined },
            { change: 'penType', data: undefined } 
          ]);
          graffiti.hideDrawingScreen();
        }          
      },

      cancelRapidPlay: () => {
        console.log('Graffiti: cancelRapidPlay');
        state.setCurrentPlaySpeed('regular');
        state.storeUserChoicePlaySpeed('regular');
        audio.updateAudioPlaybackRate();
        graffiti.updateControlPanels();
      },

      toggleRapidPlay: (opts) => {
        let forceOn = false;
        if ((state.rapidIsOn() && !opts.scan)  || (state.scanningIsOn() && opts.scan)) {
          graffiti.cancelRapidPlay();
        } else {
          console.log('Graffiti: activating rapidPlay/rapidScan');
          if (opts.scan) {
            const currentSpeakingStatus = state.scanForSpeakingStatus();
            if (currentSpeakingStatus) {
              state.setCurrentPlaySpeed('scanInactive');
            } else {
              state.setCurrentPlaySpeed('scanActive'); // turn on rapid scan immediately if rabbit icon is activated during a silent period
            }
          } else {
            state.setCurrentPlaySpeed('rapid');
            state.storeUserChoicePlaySpeed('rapid');
          }
          audio.updateAudioPlaybackRate();
          graffiti.updateControlPanels();
        }
      },

      dimGraffitiCursor: () => {
        graffiti.graffitiCursorShell.css({opacity:0.1});
      },

      undimGraffitiCursor: () => {
        graffiti.graffitiCursorShell.show().css({opacity:0.65});
      },

      activateTerminalGraffitiCursor: () => {
        graffiti.graffitiTerminalCursor.show();
        graffiti.graffitiNormalCursor.hide();
      },

      activateNormalGraffitiCursor: () => {
        graffiti.graffitiNormalCursor.show();
        graffiti.graffitiTerminalCursor.hide();
      },      

      drawingScreenHandler: (e) => {
        let drawingActivity = state.getDrawingStateField('drawingActivity');
        if (state.getActivity() === 'recording') {
          if (e.type === 'mousedown') {
            console.log('Graffiti: drawingScreenHandler: mousedown');
            const wasFading = (state.getDrawingStateField('drawingActivity') === 'fade');
            // console.log('Graffiti: wasFading:', wasFading);
            graffiti.resetTemporaryCanvases();
            state.disableDrawingFadeClock();
            const stickerType = state.getDrawingPenAttribute('stickerType');
            drawingActivity = 'draw';
            const viewInfo = state.getViewInfo();
            if (stickerType !== undefined) {
              // console.log('Graffiti: mousedown with stickerType:', stickerType);
              drawingActivity = 'sticker';
              if (wasFading) { // terminate any fading in progress when drawing a new sticker
                graffiti.resetStickerCanvases('temporary');
                graffiti.wipeTemporaryStickerDomCanvases();
              }
              const currentPointerPosition = state.getPointerPosition();
              const penType = state.getDrawingPenAttribute('type');
              const minSize = (penType === 'lineWithArrow' ? 1 : graffiti.minimumStickerSize);
              state.updateDrawingState([
                { change: 'mouseDownPosition',
                  data: {
                    x : currentPointerPosition.x,
                    y : currentPointerPosition.y
                  }
                },
                { change: 'positions',
                  data: { 
                    positions: {
                      start: { x: currentPointerPosition.x, y: currentPointerPosition.y },
                      end: { x: currentPointerPosition.x + minSize, y: currentPointerPosition.y + minSize },
                    }
                  }
                },
                { change: 'cellId',
                  data: viewInfo.cellId
                }
              ]);

              // If we are using a label-type sticker, then put the label input box where the mousedown happened.
              if (stickerType === 'label') {
                graffiti.showLabelInputBox();
              }

            }
            state.updateDrawingState( [ 
              { change: 'drawingModeActivated', data: true }, 
              { change: 'isDown',  data: true }, 
              { change: 'drawingActivity', data: drawingActivity },
              { change: 'opacity', data: state.getMaxDrawingOpacity() },
              { change: 'downInMarkdown', data: viewInfo.inMarkdownCell },
              { change: 'downInPromptArea', data: viewInfo.inPromptArea }
            ]);
          } else if ((e.type === 'mouseup') || (e.type === 'mouseleave')) {
            // console.log('Graffiti: drawingScreenHandler: ', e.type);
            if ((drawingActivity === 'sticker') && (e.type === 'mouseup')) {
              graffiti.clearAnyActiveStickerStages();
            }
            if (state.getDrawingPenAttribute('isDown')) {
              state.updateDrawingState( [ { change: 'isDown',  data: false } ]);
              if (state.getDrawingPenAttribute('permanence') === 'temporary') {
                state.startDrawingFadeClock();
              }
            }
          } else if (e.type === 'keyup') {
            console.log('Graffiti: drawingScreen got key:', e);
            graffiti.handleKeyup(e);
          } else if (e.type === 'keydown') {
            console.log('Graffiti: drawingScreen got key:', e);
            graffiti.handleKeydown(e);
          }
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      },

      resetDrawingColor: () => {
        $('#graffiti-recording-colors-shell div').removeClass('graffiti-recording-color-active');
        $('#graffiti-recording-color-black').addClass('graffiti-recording-color-active');
        state.updateDrawingState([ { change: 'color', data: 'black' }] );
      },

      resetDrawingPen: () => {
        $('.graffiti-active-pen').removeClass('graffiti-active-pen');
        graffiti.toggleGraffitiPen(undefined, 'deactivate'); // turn off the active pen
      },

      showDrawingScreen: () => {
        graffiti.drawingScreen.show().focus();
      },

      hideDrawingScreen: () => {
        graffiti.drawingScreen.hide();
      },

      // Inspired by https://www.codicode.com/art/how_to_draw_on_a_html5_canvas_with_a_mouse.aspx
      // and : http://perfectionkills.com/exploring-canvas-drawing-techniques/
      setupDrawingScreen: () => {
        // Note that the tabindex is the key to capture the keydown/up events, 
        // cf https://stackoverflow.com/questions/3149362/capture-key-press-or-keydown-event-on-div-element
        const graffitiDrawingScreen = $('<div tabindex="0" id="graffiti-drawing-screen"></div>');
        graffiti.drawingScreen = graffitiDrawingScreen.prependTo(graffiti.notebookContainer);
        const notebookHeight = $('#notebook').outerHeight(true);
        graffiti.drawingScreen.css({height: notebookHeight + 'px'});
        graffiti.drawingScreen.bind('mousedown mouseup mouseleave keydown keyup', (e) => { graffiti.drawingScreenHandler(e) });
      },
      
      placeLabelInputBox: () => {
        const viewInfo = state.getViewInfo();
        const cell = utils.findCellByCellId(viewInfo.cellId);
        const elem = $(cell.element[0]);
        let labelInputBox = elem.find('.graffiti-label-input');
        if (labelInputBox.length === 0) {
          labelInputBoxElem = $('<div tabindex="0" class="graffiti-label-input"><input type="text" maxlength="50" placeholder="' + localizer.getString('ENTER_LABEL') + 
                                '"/></div>');
          labelInputBox = labelInputBoxElem.appendTo(elem);
          labelInputBox.bind('keydown keyup', (e) => { graffiti.handleLabelInput(e) });
        }
        const penColor = state.getDrawingPenAttribute('color');
        if (penColor === 'white') {
          labelInputBox.find('input').css({color:'black'});
        } else {
          labelInputBox.find('input').css({color:penColor});
        }
        return labelInputBox;
      },

      showLabelInputBox: () => {
        graffiti.clearAnyActiveStickerStages();
        graffiti.hideLabelInputBoxes();
        const labelInputBox = graffiti.placeLabelInputBox(); // make sure there is a label box
        const currentPointerPosition = state.getPointerPosition();
        const viewInfo = state.getViewInfo();
        let adjustedPosition = utils.subtractCoords(viewInfo.outerCellRect, currentPointerPosition);
        const verticalAdjust = parseInt(labelInputBox.height() / 2);
        adjustedPosition.y = adjustedPosition.y - verticalAdjust;
        labelInputBox.show().css({left:adjustedPosition.x + 'px', top:adjustedPosition.y + 'px'}).find('input').val('').focus();
        const outerCellRect = viewInfo.outerCellRect;
        const mouseDownPosition = state.getDrawingPenAttribute('mouseDownPosition');
        state.updateDrawingState([
          { change: 'positions', 
            data: {
              positions: {
                start: { x: mouseDownPosition.x - outerCellRect.left, y: mouseDownPosition.y - outerCellRect.top - verticalAdjust },
                end:   { x: mouseDownPosition.x + 1 - outerCellRect.left, y: mouseDownPosition.y + 1 - outerCellRect.top - verticalAdjust }
              }
            }
          },

          { change: 'downInPromptArea',
            data: viewInfo.inPromptArea
          },
          { change: 'downInMarkdown',
            data: viewInfo.downInMarkdown
          }, 
          { change: 'promptWidth',
            data: viewInfo.promptWidth
          }
        ]);
      },

      hideLabelInputBoxes: () => {
        console.log('Graffiti: Ending labelling');
        $('.graffiti-label-input').val('').hide();
      },

      handleLabelInput: (e) => {
        if (e.which === 9) {
          e.preventDefault(); // don't let tab key buble up
        }
        e.stopPropagation(); // make sure keystrokes in the label input box don't bubble up to jupyter
        if (e.type === 'keyup') {
          if (state.getActivity() === 'recording') {
            // If user hits return tab, we "accept" this label, which simply means hide the input box. The rendered label should be underneath.
            state.disableDrawingFadeClock();
            const inputBox = $(e.target);
            const labelText = inputBox.val();
            state.updateDrawingState([ { change: 'label', data: '' + labelText }]);
            const drawingPermanence = state.getDrawingPenAttribute('permanence');
            graffiti.updateStickerDisplayWhenRecording(drawingPermanence);
            state.storeHistoryRecord('stickers');
            //console.log('keycode',e.which);
            if ((e.which === 13) || (e.which === 9)) {
              graffiti.hideLabelInputBoxes();
              state.startDrawingFadeClock();
            }
          }
        }
      },

      setupSavingScrim: () => {
        const graffitiSavingScrim = $('<div id="graffiti-saving-scrim"><div>Saving Graffiti Recording. Please wait...</div></div>');
        graffiti.savingScrim = graffitiSavingScrim.prependTo(graffiti.notebookContainer);
      },
      
      showSavingScrim: () =>  {
        graffiti.savingScrim.css({display:'flex'});
      },

      hideSavingScrim: () => {
        graffiti.savingScrim.css({display:'none'});
      },

      resizeCanvases: () => {
        const canvasTypes = ['permanent','temporary'];
        let cellElement, cellRect, canvasStyle, canvas, cellCanvas;
        for (let canvasType of canvasTypes) {
          for (let cellId of Object.keys(graffiti.canvases[canvasType])) {
            cell = utils.findCellByCellId(cellId);
            if (cell !== undefined) {
              canvas = graffiti.canvases[canvasType][cellId];
              cellCanvas = canvas.canvas;
              cellElement = cell.element[0];
              cellRect = cellElement.getBoundingClientRect();
              if ((parseInt(cellRect.width) !== parseInt(cellCanvas.width)) || (parseInt(cellRect.height) !== parseInt(cellCanvas.height))) {
                canvasStyle = {
                  width:  cellRect.width + 'px',
                  height: cellRect.height + 'px'
                };
                canvas.div.css(canvasStyle);
                cellCanvas.width = cellRect.width;
                cellCanvas.height = cellRect.height;
                canvas.cellRect = cellRect;
                //console.trace('resized height of ',cellId, 'to ', cellRect.height);
              }
            }
          }
        }
        const notebookHeight = $('#notebook').outerHeight(true);
        graffiti.drawingScreen.css({height: notebookHeight + 'px'});
      },

      // Remove "active" attribute from whatever sticker might have rt now.
      // Pretty inefficient, good enough for time being though.
      clearAnyActiveStickerStages: () => {
        let stickerStage, stickerIndex, sticker, canvasTypes = ['temporary', 'permanent'];
        for (let canvasType of canvasTypes) {
          for (let cellId of Object.keys(graffiti.stickers[canvasType])) {
            stickerStage = graffiti.stickers[canvasType][cellId];
            if (stickerStage.stickers !== undefined) {
              for (let stickerIndex = 0; stickerIndex < stickerStage.stickers.length; ++stickerIndex) {
                sticker = stickerStage.stickers[stickerIndex];
                if (sticker.active) {
                  stickerStage.stickers[stickerIndex].active = false;
                }
              }
            }
          }
        }
      },

      resetGraffitiStickerStage: (cellId, stickerPermanence) => {
        if (!graffiti.stickers[stickerPermanence].hasOwnProperty(cellId)) {
          graffiti.stickers[stickerPermanence][cellId] = {
            stickers: [],
            canvas: undefined
          };
        }
      },

      placeStickerCanvas: (cellId, stickerPermanence) => {
        graffiti.resetGraffitiStickerStage(cellId, stickerPermanence); // put the sticker stage record into memory if we need to before placing a canvas in the dom
        if (graffiti.stickers[stickerPermanence][cellId].canvas !== undefined) {
          return;
        }
        const cell = utils.findCellByCellId(cellId);
        const cellElement = cell.element[0];
        const cellRect = cellElement.getBoundingClientRect();

        // Note that we inline all these styles because to include them from a stylesheet causes rendering jumps.
        const stickerDivId = 'graffiti-sticker-' + cellId;
        graffiti.stickers[stickerPermanence][cellId].canvas = 
          $('<div class="graffiti-sticker-outer graffiti-canvas-type-' + stickerPermanence + '" id="' + stickerDivId + '" ' +
            'style="width:' + parseInt(cellRect.width) + 'px;' +
            'height:' + parseInt(cellRect.height) + 'px;' +
            'position:absolute;left:0;top:0;">' +
            '</div>').appendTo(cellElement);
      },

      placeCanvas: (cellId, drawingPermanence) => {
        const cell = utils.findCellByCellId(cellId);
        const cellElement = $(cell.element[0]);
        const cellRect = cellElement[0].getBoundingClientRect();
        if (graffiti.canvases[drawingPermanence][cellId] !== undefined) {
          //console.log('not adding ' + drawingPermanence + ' canvas to this cell, already exists.');
          return cellRect;
        }
        // console.log('Graffiti: placing ', drawingPermanence, 'canvas for cellId:', cellId);
        $('<div class="graffiti-canvas-outer graffiti-canvas-type-' + drawingPermanence + '"><canvas /></div>').appendTo(cellElement);
        const newCellCanvasDiv = cellElement.find('.graffiti-canvas-outer:last');
        const newCellCanvas = newCellCanvasDiv.find('canvas')[0];
        const ctx =  newCellCanvas.getContext("2d");

        const canvasStyle = {
          width: cellRect.width + 'px',
          height: cellRect.height + 'px'
        };
        newCellCanvasDiv.css(canvasStyle);
        newCellCanvas.width = cellRect.width;
        newCellCanvas.height = cellRect.height;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        graffiti.canvases[drawingPermanence][cellId] = {
          div: newCellCanvasDiv,
          canvas: newCellCanvas,
          ctx: ctx,
          cellRect: cellRect
        };
        // console.log('canvases:', graffiti.canvases);
        return cellRect;
      },
      
      setCanvasStyle: (cellId, penType, penDashStyle, canvasColor, canvasPermanence) => {
        const canvas = graffiti.canvases[canvasPermanence][cellId];
        const ctx = canvas.ctx;
        if (canvasColor === undefined) {
          canvasColor = 'black'; // default to black lines if not set in older recordings before color was supported.
        }
        if (penType === 'highlight') {
          if (canvasColor === 'black') {
            canvasColor = 'yellow';
          }
          ctx.lineWidth = 15;
          ctx.shadowBlur = 35;
          ctx.globalAlpha = 0.5;
        } else { // lines are default although if erase activated, we will ignore this style and use clearRect
          //console.log('canvas color:', canvasColor);
          ctx.shadowBlur = 1;
          ctx.lineWidth = 1.75;
          ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
          if (penDashStyle === 'dashed') {
            ctx.setLineDash([2,10]); /* first parm = dash, second parm = spaces btwn */
            ctx.lineDashOffset = 2;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.5;
          }
        }
        let rawColorVal = '#' + graffiti.penColors[canvasColor];
        // Hack test
        if (rawColorVal === undefined) {
          console.log('Graffiti: warning, rawColorVal is undefined');
          rawColorVal = '#000000';
        }
        ctx.strokeStyle = rawColorVal;
        ctx.shadowColor = rawColorVal;
      },

      clearCanvas: (canvasType, cellId) => {
        const canvas = graffiti.canvases[canvasType][cellId];
        const ctx = canvas.ctx;
        const cellRect = canvas.cellRect;
        ctx.clearRect(0, 0, cellRect.width, cellRect.height);
      },
      
      clearCanvases: (canvasType) => {
        //console.log('clearCanvases');
        if (canvasType === 'all') {
          for (let canvasType of Object.keys(graffiti.canvases)) {
            for (let cellId of Object.keys(graffiti.canvases[canvasType])) {
              graffiti.clearCanvas(canvasType, cellId);
            }
          }
        } else {
          for (let cellId of Object.keys(graffiti.canvases[canvasType])) {
            graffiti.clearCanvas(canvasType, cellId);
          }
        }
        $('.graffiti-canvas-type-temporary').css({opacity: state.getMaxDrawingOpacity() });
      },

      resetTemporaryCanvases: () => {
        console.log('Graffiti: resetTemporaryCanvases.');
        const opacity = state.getDrawingStateField('opacity');
        const maxOpacity = state.getMaxDrawingOpacity();
        if (opacity < maxOpacity) {
          console.log('Graffiti: Clearing temp canvases, since fade was in progress.');
          graffiti.clearCanvases('temporary');
          state.updateDrawingState( [ { change: 'drawingActivity', data: 'wipe' } ]);
          state.storeHistoryRecord('drawings');
          state.updateDrawingState( [ { change: 'opacity', data: maxOpacity } ]);
          state.disableDrawingFadeClock();
        }
      },

      // If a cell is deleted by jupyter we need to forget any the canvases we were tracking for it.
      removeCanvasRecordsForCell: (cellId) => {
        delete(graffiti.canvases['permanent'][cellId]);
        delete(graffiti.stickers['permanent'][cellId]);
        delete(graffiti.canvases['temporary'][cellId]);
        delete(graffiti.stickers['temporary'][cellId]);
      },

      updateDrawingOpacity: () => {
        const maxOpacity = state.getMaxDrawingOpacity();
        // Check for fadeouts
        const currentOpacity = state.getDrawingStateField('opacity');
        const opacityInfo = state.calculateDrawingOpacity();
        switch (opacityInfo.status) {
          case 'max':
            if (currentOpacity !== maxOpacity) { // only go to max if not already set to max
              const drawingActivity = state.getDrawingStateField('drawingActivity');
              state.updateDrawingState( [ { change: 'drawingActivity', data: drawingActivity }, { change: 'opacity', data: maxOpacity } ] );
            }
            break;
          case 'fade':
            state.updateDrawingState( [ { change: 'drawingActivity', data: 'fade' }, { change: 'opacity', data: opacityInfo.opacity } ] );
            state.storeHistoryRecord('drawings');
            $('.graffiti-canvas-type-temporary').css({opacity:opacityInfo.opacity});
            break;
          case 'fadeDone':
            graffiti.resetTemporaryCanvases();
            graffiti.resetStickerCanvases('temporary');
            break;
        }
      },      

      updateDrawingDisplay: (cellId, ax, ay, bx, by, drawingPenType, drawingPermanence ) => {
        //console.log('updateDrawingDisplay, drawingPermanence:', drawingPermanence);
        if (graffiti.canvases[drawingPermanence].hasOwnProperty(cellId)) {
          const ctx = graffiti.canvases[drawingPermanence][cellId].ctx;
          if (drawingPenType === 'eraser') {
            const eraseBuffer = 25;
            ctx.clearRect(ax - eraseBuffer / 2, ay - eraseBuffer / 2, eraseBuffer, eraseBuffer);
          } else {
            //console.log('updateDrawingDisplay:', ax, ay, bx, by);
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(bx, by);
            ctx.closePath();
            ctx.stroke();
          }
        }
      },

      wipeTemporaryStickerDomCanvases: () => {
        $('.graffiti-sticker-outer.graffiti-canvas-type-temporary').empty();
      },
      
      wipeAllStickerDomCanvases: () => {
        //console.log('wipeAllStickerDomCanvases');
        $('.graffiti-sticker-outer').empty();
      },

      resetStickerCanvases: (typeOverride) => {
        let sticker, canvasTypes = (typeOverride === undefined ? ['temporary', 'permanent'] : [ typeOverride ]);
        for (let canvasType of canvasTypes) {
          for (let cellId of Object.keys(graffiti.stickers[canvasType])) {
            sticker = graffiti.stickers[canvasType][cellId];
            if (sticker.canvas !== undefined) {
              sticker.canvas.empty();
            }
            sticker.stickers = [];
          }
        }
      },        

      processPositionsForCellTypeScaling: (record, type) => {
        let positions, scalarX = 1, scalarY = 1, positionsRaw, cell, cellId, cellRects, denomWidth, denomHeight;
        // console.log('scalarX', scalarX, 'scalarY', scalarY);
        if (type === 'cursor') {
          // Scale the cursor position. The cell the cursor is hovering over is in the cellId field, unless the
          // drawingActivity was 'sticker' when this record was made, in which case we'll scale to the cell under
          // the starting coordinates of the sticker to match what happens when we scale the sticker itself.
          if (record.stickerInfo !== undefined) {
            cellId = record.stickerInfo.cellId;
            denomWidth = record.stickerInfo.width;
            denomHeight = record.stickerInfo.height;
          } else {
            cellId = record.cellId;
            denomWidth = record.innerCellRect.width;
            denomHeight = record.innerCellRect.height;
          }
          cell = utils.findCellByCellId(cellId);
          cellRects = utils.getCellRects(cell);
          if (state.getScaleCursorWithWindow()) {
            // only scale the cursor if the directive is set to scale with window.
            scalarX = cellRects.innerCellRect.width / denomWidth;
            scalarY = cellRects.innerCellRect.height / denomHeight;
          }
          positionsRaw = { x: record.x, y: record.y };
          
          if (!record.inMarkdownCell || record.isOverTerminal) {
            // in code cells, or if pen went down in prompt area, just use positions verbatim
            positions = { start: { x: positionsRaw.x, y: positionsRaw.y } };
          } else {
            if (record.inPromptArea || record.downInPromptArea) {
              // in prompt area only scale y value
              positions = { start: { x: positionsRaw.x, y: positionsRaw.y * scalarY } };
            } else {
              // in markdown area, scale full position.
              positions = { start: { x: (positionsRaw.x - record.promptWidth) * scalarX + cellRects.promptRect.width,
                                     y: positionsRaw.y * scalarY } };
            }
          }
          //if (record.drawingActivity === 'sticker') {
          //console.log('cellId', cellId, 'hoverCellId', record.hoverCell.metadata.graffitiCellId, 'positions', positions.start.y, 'scalarX', scalarX, 'scalarY', scalarY);
          //}
        } else {
          //
          // Drawing and sticker scaling code begins here.
          //
          positionsRaw = { start: { x: record.positions.start.x, y: record.positions.start.y },
                           end:   { x: record.positions.end.x, y: record.positions.end.y } };
          cell = utils.findCellByCellId(record.cellId);
          cellRects = utils.getCellRects(cell);
          if (state.getScaleCursorWithWindow()) {
            // only scale the drawing if the directive is set to scale with window.
            scalarX = cellRects.innerCellRect.width / record.innerCellRect.width ;
            scalarY = cellRects.innerCellRect.height / record.innerCellRect.height;
          }
          // If this drawing/sticker started in a markdown cell, we will attempt to scale both x and y coords in the inner_cell rect area but 
          // NOT the prompt area.
          if (record.pen.downInMarkdown) {
            if (record.pen.downInPromptArea) {
              //console.log('inPromptArea and did not start in prompt area');
              // if pen went down in prompt area of a markdown cell, scale the Y value only. 
              positions = { start: { x: positionsRaw.start.x,
                                     y: positionsRaw.start.y * scalarY },
                            end:   { x: positionsRaw.end.x,
                                     y: positionsRaw.end.y * scalarY }
              };
            } else {
              if (record.pen.inPromptArea) {
                scalarX = 1;
              }
              // In the inner_cell, scale both x and y. First subtract the historical prompt width, then scale the value up/down, and then
              // add the current prompt width to calculate the final X (UNLESS we are drawing in the prompt area, then do not scale in X).
              // Y is just scaled by change in cell height.
              positions = { start: { x: (positionsRaw.start.x - record.promptWidth) * scalarX + cellRects.promptRect.width,
                                     y: positionsRaw.start.y * scalarY },
                            end:   { x: (positionsRaw.end.x - record.promptWidth) * scalarX + cellRects.promptRect.width,
                                     y: positionsRaw.end.y * scalarY }
              };
            }
          } else {
            // we don't scale anything if we started in a code cell. Just leave everything as recorded.
            positions = { 
              start: { x : positionsRaw.start.x, y: positionsRaw.start.y },
              end: {   x : positionsRaw.end.x,   y: positionsRaw.end.y }
            }
          }
        }
        return positions;
      },

      // calculate correct offsets based on innerCellRect / dx, dy etc
      drawStickersForCell: (cellId,record) => {
        const activity = state.getActivity();
        const currentlyRecording = (activity === 'recording');
        const canvasTypes = ['temporary', 'permanent'], canvasElements = {};
        let canvasType, newInnerHtml = {}, finalInnerHtml;
        for (canvasType of canvasTypes) {
          graffiti.placeStickerCanvas(cellId, canvasType);
          canvasElements[canvasType] = {elem: graffiti.stickers[canvasType][cellId].canvas };
          canvasElements[canvasType].opacityOverride = canvasElements[canvasType].elem.css('opacity');
          newInnerHtml[canvasType] = [];
        }
        let stickerPermanence, stickerX, stickerY, fillOpacity, width, height, stickerWidth, stickerHeight, 
            generatedStickerHtml, generatedStickerElem, pen, type, positions, p1x,p1y,p2x,p2y,
            stickersRecords, dimensions, stickerProcessingRecord;
        if (record !== undefined) {
          stickersRecords = record.stickersRecords;
        } else { 
          stickerPermanence = state.getDrawingPenAttribute('permanence');
          stickersRecords = graffiti.stickers[stickerPermanence][cellId].stickers; 
        }
        for (let stickerRecord of stickersRecords) {
          pen = stickerRecord.pen;
          type = pen.stickerType;
          stickerPermanence = pen.permanence;
          if (currentlyRecording) {
            positions = stickerRecord.positions;
            fillOpacity = state.getDrawingPenAttribute('fillOpacity');
            //console.log('Recording, Computed fillOpacity:', fillOpacity);
          } else {
            stickerRecord.cellId = cellId;
            // console.log('Graffiti: sticker rendering.  record', record, 'stickerRecord', stickerRecord, 'stickerProcessingRecord', stickerProcessingRecord);
            positions = graffiti.processPositionsForCellTypeScaling(stickerRecord,'positions');
            fillOpacity = stickerRecord.pen.fillOpacity;
          }
          if (type === 'lineWithArrow') {
            stickerX = positions.start.x;
            stickerY = positions.start.y;
          } else {
            stickerX = Math.min(positions.start.x, positions.end.x);
            stickerY = Math.min(positions.start.y, positions.end.y);
          }
          stickerWidth =  Math.abs(positions.end.x - positions.start.x);
          stickerHeight = Math.abs(positions.end.y - positions.start.y);
          const transformX = Math.sign(positions.end.x - positions.start.x);
          const transformY = Math.sign(positions.end.y - positions.start.y);
          let cssTransform = 'scale(' + transformX + ',' + transformY + ')';
          if (stickerRecord.stickerOnGrid) {
            // Make things square when shift key is down, except for certain items,
            // where shift key means align with a fixed grid and fixed graffiti size.
            if ( (type === 'checkmark') || (type === 'xmark') || (type === 'bomb') || (type === 'trophy') || (type === 'smiley') ||
                 (type === 'pi') || (type === 'alpha') || (type === 'beta') || (type === 'sigma') || (type == 'theta') || (type === 'angle') ) {
              stickerX = parseInt(positions.start.x / graffiti.minimumStickerSizeWithBuffer) * graffiti.minimumStickerSizeWithBuffer;
              stickerY = parseInt(positions.start.y / graffiti.minimumStickerSizeWithBuffer) * graffiti.minimumStickerSizeWithBuffer;
              stickerWidth = graffiti.minimumStickerSize;
              cssTransform = undefined; // don't allow transforms while on the fixed grid
            } 
            stickerHeight = stickerWidth;
          }
          dimensions = {
            x: stickerX,
            y: stickerY,
            width: stickerWidth,
            height: stickerHeight
          };
          //console.log('Processing stickerRecord:', stickerRecord);
          //console.log('Drawing to dimensions:', dimensions);
          generatedStickerHtml = undefined;
          //console.log('processing type:', type);
          switch (type) {
            case 'rectangle':
              generatedStickerHtml = stickerLib.makeRectangle({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth: 4,
                dimensions: dimensions,
                fillOpacity: fillOpacity,
              });
              break;
            case 'roundRectangle':
              generatedStickerHtml = stickerLib.makeRectangle({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth: 4,
                rx: 8,
                ry: 8,
                dimensions: dimensions,
                fillOpacity: fillOpacity,
              });
              break;
            case 'isocelesTriangle':
              generatedStickerHtml = stickerLib.makeIsocelesTriangle({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth: 4,
                dimensions: dimensions,
                cssTransform: cssTransform,
                fillOpacity: fillOpacity,
              });
              break;
            case 'rightTriangle':
              generatedStickerHtml = stickerLib.makeRightTriangle({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                strokeWidth: 4,
                cssTransform: cssTransform,
                fillOpacity: fillOpacity,
              });
              break;
            case 'ellipse':
              generatedStickerHtml = stickerLib.makeEllipse({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth:3,
                dimensions: dimensions,
                fillOpacity: fillOpacity,
                buffer: 4,
              });
              break;
            case 'checkmark':
              generatedStickerHtml = stickerLib.makeCheckmark({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions
              });
              break;
            case 'xmark':
              generatedStickerHtml = stickerLib.makeXmark({
                strokeWidth: 2,
                color:  'red',
                dashed: pen.dash, 
                dimensions: dimensions
              });
              break;
            case 'grid':
              generatedStickerHtml = stickerLib.makeGrid({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform,
                strokeWidth: 1
              });
              break;
            case 'axis':
              generatedStickerHtml = stickerLib.makeAxis({
                strokeWidth: 2,
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'bomb':
              generatedStickerHtml = stickerLib.makeBomb({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'trophy':
              generatedStickerHtml = stickerLib.makeTrophy({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'smiley':
              generatedStickerHtml = stickerLib.makeSmiley({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform,
                strokeWidth:2,
              });
              break;
            case 'ribbon':
              generatedStickerHtml = stickerLib.makeRibbon({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth:2,
                dimensions: dimensions,
              });
              break;
            case 'horizontalBrackets':
              generatedStickerHtml = stickerLib.makeHorizontalBrackets({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth:3,
                dimensions: dimensions,
              });
              break;
            case 'verticalBrackets':
              generatedStickerHtml = stickerLib.makeVerticalBrackets({
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                strokeWidth:3,
                dimensions: dimensions,
              });
              break;
            case 'curlyBraces':
              generatedStickerHtml = stickerLib.makeSymmetricCurlyBraces({
                color:  pen.color,
                dashed: pen.dash, 
                strokeWidth:3,
                dimensions: dimensions,
              });
              break;
            case 'pi':
              generatedStickerHtml = stickerLib.makePi({
                color:  pen.color,
                dashed: pen.dash, 
                strokeWidth:2,
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'alpha':
              generatedStickerHtml = stickerLib.makeAlpha({
                color:  pen.color,
                dashed: pen.dash, 
                strokeWidth:2,
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'beta':
              generatedStickerHtml = stickerLib.makeBeta({
                color:  pen.color,
                dashed: pen.dash, 
                strokeWidth:2,
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'sigma':
              generatedStickerHtml = stickerLib.makeSigma({
                strokeWidth:1,
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'theta':
              generatedStickerHtml = stickerLib.makeTheta({
                strokeWidth:1,
                color:  pen.color,
                fill:   pen.fill,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'angle':
              generatedStickerHtml = stickerLib.makeAngle({
                strokeWidth:1,
                fill: pen.fill,
                color:  pen.color,
                dashed: pen.dash, 
                dimensions: dimensions,
                cssTransform: cssTransform
              });
              break;
            case 'lineWithArrow':
              generatedStickerHtml = stickerLib.makeLine({
                color:  pen.color,
                dashed: pen.dash, 
                dimensions: dimensions,
                endpoints: { p1: {x: positions.start.x, y: positions.start.y }, p2: { x: positions.end.x, y: positions.end.y } },
                lineStartOffset: { x: 0, y: 0 },
                usesArrow: true,
                arrowHeadSize: 6
              });
              break;
            case 'label':
              // If we are recording, on mouseup, we will put a centered input box on screen. Otherwise render this label.
              // If not recording, render a text label scaled by the size of this box.
              if (pen.label !== undefined) {
                dimensions.width = 15 * pen.label.length; // large enough for the label
                dimensions.height = 18;
                generatedStickerHtml = stickerLib.makeLabelHtml({
                  color:  pen.color,
                  label: pen.label,
                  dimensions: dimensions,
                  opacity: 1.0,
                });
                //console.log('generatedStickerHtml:', generatedStickerHtml);
              }
              break;
            case 'custom':
              let stickerImageUrl;
              if (currentlyRecording) {
                const recordingCellInfo = state.getRecordingCellInfo();
                stickerImageUrl = recordingCellInfo.recordingRecord.stickerImageUrl;
              } else {
                stickerImageUrl = state.getStickerImageUrl();
              }
              if (stickerImageUrl !== undefined) {
                generatedStickerHtml = stickerLib.makeCustom({
                  dimensions: dimensions,
                  imageUrl: stickerImageUrl,
                  cssTransform: cssTransform
                });
                canvasElements[stickerPermanence].opacityOverride = 1.0; // make parent opacity maximum so child images are fully visible
              } else {
                // Sticker not set or not found; just draw grey rect to let user know
                generatedStickerHtml = stickerLib.makeRectangle({
                  color:  'lightgrey',
                  fill:   pen.fill,
                  dashed: 'dashed',
                  strokeWidth: 3,
                  dimensions: dimensions,
                  fillOpacity: 0,
                });
              }
              break;
          }
          if (generatedStickerHtml !== undefined) {
            newInnerHtml[stickerPermanence].push(generatedStickerHtml);
          }
        }
        // Finally, render all sticker html now that it's built.
        for (canvasType of canvasTypes) {
          if (newInnerHtml[canvasType].length > 0) { // only redraw canvas that has elements drawn during this frame
            canvasElements[canvasType].elem.empty();
            finalInnerHtml = newInnerHtml[canvasType].join('');
            canvasElements[canvasType].elem.html(finalInnerHtml);
            canvasElements[canvasType].elem.css({opacity:canvasElements[canvasType].opacityOverride});
          }
        }
      },

      updateStickerDisplayWhenRecording: (stickerPermanence) => {
        const cellId = state.getDrawingStateField('cellId');
        graffiti.resetGraffitiStickerStage(cellId, stickerPermanence);

        // Replace active sticker if there is one, or add a new active sticker
        const stickers = graffiti.stickers[stickerPermanence][cellId].stickers;
        let stickerRecord = state.createStickerRecord();
        // console.log('stickerRecord', stickerRecord);
        //console.log('stickerRecordEnd:', stickerRecord.positions.start.x, stickerRecord.positions.start.y, stickerRecord.positions.end.x, stickerRecord.positions.end.y);
        stickerRecord.active = true;
        let replaced = false;
        if (stickers.length > 0) {
          const lastSticker = stickers.length - 1;
          if (stickers[lastSticker].active) {
            graffiti.stickers[stickerPermanence][cellId].stickers[lastSticker] = stickerRecord;
            replaced = true;
          }
        }
        if (!replaced) {
          stickers.push(stickerRecord);
        }

        // Store the state for later redrawing.
        state.storeStickersStateForCell(graffiti.stickers[stickerPermanence][cellId].stickers, cellId);
        // Now rerender all stickers for this cell
        graffiti.drawStickersForCell(cellId);
      },

      // This fn is called on mousemove, which means fade counts always reset, and we clear the temporary ink completely if it was part way through a fade
      updateDrawingDisplayWhenRecording: (ax, ay, bx, by, viewInfo) => {
        if (state.getActivity() === 'recording') {
          if (state.getDrawingPenAttribute('isDown')) {
            const drawingActivity = state.getDrawingStateField('drawingActivity');
            const drawingPermanence = state.getDrawingPenAttribute('permanence');
            const cellId = (drawingActivity === 'sticker' ? state.getDrawingStateField('cellId') : viewInfo.cellId);
            const cellRect = graffiti.placeCanvas(cellId, drawingPermanence);
            let drawingRecordType;
            if (drawingActivity === 'sticker') {
              drawingRecordType = 'stickers';
              const mouseDownPosition = state.getDrawingPenAttribute('mouseDownPosition');
              state.updateDrawingState([
                { change:'positions', 
                  data: { 
                    positions: {
                      start: { x: mouseDownPosition.x - cellRect.left, y: mouseDownPosition.y - cellRect.top },
                      end:   { x: bx - cellRect.left, y: by - cellRect.top }
                    }
                  }
                },
                { change: 'inPromptArea',
                  data: viewInfo.inPromptArea
                },
                { change: 'promptWidth',
                  data: viewInfo.promptWidth
                }, 
                // note that we don't change the sticker cellId during mousemove. It's set once at mousedown and kept constant until mouse up.
              ]);
              graffiti.updateStickerDisplayWhenRecording(drawingPermanence);
            } else {
              drawingRecordType = 'drawings';
              const drawingPenType = state.getDrawingPenAttribute('type');
              const drawingPenDash = state.getDrawingPenAttribute('dash');
              const drawingPenColor = state.getDrawingPenAttribute('color');
              // console.log('drawingActivity', drawingActivity, drawingPenType);
              graffiti.setCanvasStyle(viewInfo.cellId, drawingPenType, drawingPenDash, drawingPenColor, drawingPermanence);
              graffiti.updateDrawingDisplay(viewInfo.cellId, 
                                            ax - cellRect.left,
                                            ay - cellRect.top, 
                                            bx - cellRect.left,
                                            by - cellRect.top,
                                            drawingPenType,
                                            drawingPermanence);
              state.updateDrawingState([
                { change:'positions', 
                  data: { 
                    positions: {
                      start: { x: ax - cellRect.left, y: ay - cellRect.top },
                      end:   { x: bx - cellRect.left, y: by - cellRect.top }
                    }
                  }
                },
                { change: 'cellId',
                  data: viewInfo.cellId
                },
                { change: 'inPromptArea',
                  data: viewInfo.inPromptArea
                },
                { change: 'promptWidth',
                  data: viewInfo.promptWidth
                }, 
              ]);
            }
            state.storeHistoryRecord(drawingRecordType);
          }
        }
      },

      // Rerun all drawings up to time t. Used after scrubbing.
      redrawAllDrawings: (targetTime) => {
        if (targetTime === undefined) {
          targetTime = state.getTimePlayedSoFar();
        }
        graffiti.clearCanvases('all');
        const lastDrawFrameIndex = state.getIndexUpToTime('drawings', targetTime);
        if (lastDrawFrameIndex !== undefined) {
          // First, final last opacity reset before the target time. We will start redrawing drawings from this point forward.
          let record;
          for (let index = 0; index < lastDrawFrameIndex; ++index) {
            record = state.getHistoryItem('drawings', index);
            graffiti.updateDrawingCore(record);
          }
        }
      },

      redrawAllDrawingsWhenRecording: () => {
        if (state.getActivity() !== 'recording') {
          return;
        }
        const lastDrawFrameIndex = state.getLastFrameIndex('drawings');
        if (lastDrawFrameIndex !== undefined) {
          let record;
          for (let index = 0; index < lastDrawFrameIndex; ++index) {
            record = state.getHistoryItem('drawings', index);
            graffiti.updateDrawingCore(record);
          }
        }
      },

      // Extract any tooltip commands. Here's some examples:
      //
      // %%button_name Watch Movie
      // %%narrator_pic images/adarsh_pic.png
      // %%narrator_name Adarsh
      // %%caption_pic ![Adarsh](images/adarsh_pic.png)
      // %%caption  What is Naive Bayes?
      //

      extractTooltipCommands: (markdown) => {
        //const commandParts = markdown.match(/^\s*%%(([^\s]*)(\s*)(.*))$/mig);
        const commandParts = markdown.split(/\n/);
        let partsRecord, part, subParts, cleanedPart;
        if (commandParts === null)
          return undefined;
        if (commandParts.length > 0) {
          partsRecord = {
            buttonName: undefined,
            captionPic: '',
            captionVideo: undefined,
            caption: '',
            playback_pic: undefined,
            autoplay: 'never',
            replayAllCells: false, // by default, we will only replay cells that the author interacted with. 
            hideTooltip: false,
            playOnClick: false,
            skipInfo: {
              type: state.skipTypes['absolute'],
              factor: 0,
            },
            saveToFile: undefined, // may be array of save_to_file directives
            scaleCursorToWindow: false, // if set to true, we will try to scale all drawings 
            silenceWarnings: false,
            swappingLabels: false,
          };
          for (let i = 0; i < commandParts.length; ++i) {
            part = $.trim(commandParts[i]);
            //console.log('part:', part);
            if ((part.indexOf('%%') === 0) && (part.indexOf('%% ') !== 0)) {
              cleanedPart = part.replace('%%','');
              subParts = $.trim(cleanedPart).split(/\s+/);
              if (subParts.length > 0) {
                const subPart0 = subParts[0];
                if ((subPart0 === 'button_name') || (subPart0 === 'caption') || (subPart0 === 'caption_pic') || 
                    (subPart0 === 'caption_video_id') || (subPart0 === 'narrator_name') || (subPart0 === 'narrator_pic') || 
                    (subPart0 === 'custom_sticker')) {
                  if (subParts.length === 1) { // not enough parameters given, silently ignore
                    continue;
                  }
                }
                const subPart1 = subParts[1];
                const subPart2 = subParts[2];
                const subPart1ToEnd = subParts.slice(1).join(' ');
                switch (subPart0) {
                  case 'comment':
                    break; // we just ignore these. Used to instruct content creators how to use the editing tip cells.
                  case 'title_tag':
                    state.setTooltipTitleTag(subPart1ToEnd);
                    break;
                  case 'button_name':
                    partsRecord.buttonName = subPart1ToEnd;
                    break;
                  case 'caption': // you can make a special caption for this tip
                    partsRecord.caption = subPart1ToEnd;
                    break;
                  case 'caption_pic': // you can put a tiny pic next to the caption (use markdown)
                    partsRecord.captionPic = utils.renderMarkdown(subPart1);
                    break;
                  case 'caption_video_id': // you can put a tiny video next to the caption
                    if (subPart1.indexOf('images/') === 0) {
                      partsRecord.captionVideo =
                        '<video width="150" height="75" autoplay><source src="' + subPart1 + '" type="video/mp4"></video>';
                    } else {
                      partsRecord.captionVideo =
                        '<iframe width="100" height=80 src="https://www.youtube.com/embed/' + subPart1 + 
                        '?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0"></iframe>';
                    }
                    break;
                  case 'narrator_name': // set the name of the narrator to display in the control panel during playback
                    if (subPart1 !== undefined) {
                      partsRecord.narratorName = subPart1ToEnd;
                    }
                    break;
                  case 'narrator_pic': // specify a picture to display in the control panel during playback
                    if (subPart1 !== undefined) {
                      partsRecord.narratorPicture = subPart1;
                    }
                    break;
                  case 'hide_player_after_playback_complete':
                    state.setHidePlayerAfterPlayback(true);
                    break;
                  case 'dont_restore_cell_contents_after_playback': // if the user hasn't changed cell contents, don't restore the cell contents when playback finishes
                    state.setDontRestoreCellContentsAfterPlayback(true);
                    break;
                  case 'autoplay': // 'never' (optional), 'once', 'always'
                    if (subPart1 !== undefined) { // if not passed in then its considered to be 'never'
                      partsRecord.autoplay = subPart1.toLowerCase();
                    }
                    break;
                  case 'play_on_click': // if present, we will make a click on the target initiate playback.
                  case 'click_to_play':
                    partsRecord.playOnClick = true; 
                    break;
                  case 'hide_tooltip': // if present, we will not render tooltip.
                    partsRecord.hideTooltip = true;
                    break;
                  case 'hide_play_button':
                    // if present, we will render the tooltip but we will not show the play button. 
                    // Used in conjunction with clickToPlay on text graffiti
                    partsRecord.hidePlayButton = true; 
                    break;
                  case 'custom_sticker':
                    // Path to an image or svg that will be a custom sticker.
                    partsRecord.stickerImageUrl = subPart1;
                    break;
                  case 'skip_speed':
                    // One of: 0 (absolute jumps), 2x/3x etc (double speed during skips, triple etc), or 2c/3c (compress skips to 2s or 3s or less, etc)
                    const skipParts = subPart1.match(/(.*?)([cx]{0,1}$)/);
                    if (skipParts !== null) {
                      partsRecord.skipInfo = {
                        factor: skipParts[1],
                      };
                      if (skipParts[1] === '0') {
                        partsRecord.skipInfo.type = state.skipTypes['absolute'];
                      } else {
                        partsRecord.skipInfo.type = (skipParts[2] === 'c' ? state.skipTypes['compressed'] : state.skipTypes['rapid']);
                      }
                    }
                    break;
                  case 'save_to_file':
                    // Param 1: id of cell to save; param 2: path of file to save cell contents to. You can have more than one of these in a tooltip
                    if (partsRecord.saveToFile === undefined) {
                      partsRecord.saveToFile = [];
                    }
                    const saveFile = subParts[2].replace(/^"/,'').replace(/"$/,'');
                    const sourceCell = subPart1;
                    partsRecord.saveToFile.push({ cellId: sourceCell, path: saveFile });
                    break;
                  case 'terminal_command':
                    // pass a shell command to execute, enclosed by double quotes. The outside quotes will be removed.
                    const command = subParts.slice(2).join(' ').replace(/^"/,'').replace(/"$/,'');
                    partsRecord.terminalCommand = { 
                      terminalId: subPart1, 
                      command: command };
                    break;
                  case 'insert_data_from_file':
                    // pass a cell type and a file to read content from.
                    partsRecord.insertDataFromFile = {
                      cellType: subPart1, // either "code" or "markdown"
                      filePath: subPart2.replace(/^"/,'').replace(/"$/,''), // relative path to file to insert, remove quotes.
                    };
                    break;
                  case 'label_swaps':
                    // Using this directive you can change the displayed text in a graffiti eg. in a graffiti button on a click. Separate
                    // the values using a pipe (|)
                    const swaps = subParts.slice(1).join(' ').split('|');
                    partsRecord.swappingLabels = true;
                    partsRecord.labelSwaps = swaps;
                    break;
                  case 'replay_all_cells':
                    // When this is set we will replay all cells in the entire notebook regardless of whether you interacted with them in the 
                    // recording. Default: false
                    partsRecord.replayAllCells = true;
                    break;
                  case 'scale_cursor_with_window':
                    partsRecord.scaleCursorWithWindow = true;
                    break;
                  case 'silence_warnings':
                    // if this is set, then the warning modal shown if a movie cannot be played (maybe because files are missing) is not displayed.
                    partsRecord.silenceWarnings = true;
                    break;
                }
              }
            }
          }
        }
        return partsRecord;
      },

     refreshGraffitiSideMarkers: (cell) => {
       const element = $(cell.element[0]);
       const elemOffset = element.offset();
       element.find('.graffiti-right-side-marker').unbind('mouseenter mouseleave').remove(); // remove all previous markers for this cell
       let markers = element.find('.graffiti-highlight');
       const yBuffer = 2;
       let i, marker, offset, makerIcon, rect, yDiff, className, idMatch, metaData;
       if (markers.length > 0) {
         //console.log('markers:', markers);
         for (i = 0; i < markers.length; ++i) {
           marker = markers[i];
           className = marker.className;
           // extract the recording tag so we can highlight it later
           idMatch = className.match(/graffiti-(id_.[^\-]+-id_[^\s]+)/);
           metaData = (idMatch !== null ? idMatch[1] : undefined);
           offset = $(marker).offset();
           yDiff = offset.top - elemOffset.top;
           markerIcon = stickerLib.makeRightSideMarker({color:'rgb(47,147,107)',
                                                        dimensions: { x: element.width() + 20,
                                                                      y: yDiff - yBuffer,
                                                                      width: 18,
                                                                      height:12,
                                                        },
                                                        metaTag: 'graffiti-id|' + metaData,
                                                        title: localizer.getString('GRAFFITI_PRESENT')
           });
           $(markerIcon).appendTo(element);
         }
       }
       let markerIcons = element.find('.graffiti-right-side-marker');
       if (markerIcons.length > 0) {
         markerIcons.bind('mouseenter mouseleave', (e) => {
           let target = $(e.target);
           if (!target.hasClass('graffiti-right-side-marker')) {
             target = target.parents('.graffiti-right-side-marker');
           }
           const graffitiId = target.attr('graffiti-id');
           const cellElement = target.parents('.cell');
           const graffitiElement = cellElement.find('.graffiti-' + graffitiId);
           if (e.type === 'mouseenter') {
             //console.log('entered right-side-marker:', graffitiId);
             graffitiElement.addClass('graffiti-highlight-extra');
           } else {
             //console.log('left right-side-marker', graffitiId);
             graffitiElement.removeClass('graffiti-highlight-extra');
           }
         });
       }
     },

      // Refresh the markDoc calls for any particular cell based on recording data
      refreshGraffitiHighlights: (params) => {
        params.cellId = utils.getMetadataCellId(params.cell.metadata);

        if (params.cell.cell_type !== 'code') {
          return; // We don't refresh highlights in markdown cells because markdown cells do their highlights with plain html markup.
        }
        const recordings = state.getManifestRecordingsForCell(params.cellId);
        const cm = params.cell.code_mirror;
        const marks = cm.getAllMarks();
        let markClasses;
        if (params.clear) {
          for (let mark of marks) {
            mark.clear();
          }
        } else {
          markClasses = marks.map((mark) => { return mark.className }).join(' ').replace(/graffiti-highlight /g, '');
        }
        const allTokens = utils.collectCMTokens(cm);
        graffiti.tokenRanges[params.cellId] = {};
        if (recordings !== undefined) {
          if (Object.keys(recordings).length > 0) {
            let keyParts,recording, recordingKey, tokens, firstToken, marker, range;
            for (recordingKey of Object.keys(recordings)) {
              recording = recordings[recordingKey];
              tokens = recording.tokens;
              //console.log('recordingKey:', recordingKey);
              range = utils.getCMTokenRange(cm, tokens, allTokens);
              if (range !== undefined) {
                // Store computed character ranges for checking selections against recording ranges.
                graffiti.tokenRanges[params.cellId][recordingKey] = range;
                if (params.clear || (!params.clear && markClasses !== undefined && markClasses.indexOf(recordingKey) === -1)) {
                  // don't call markText twice on a previously marked range
                  marker = 'graffiti-' + recording.cellId + '-' + recordingKey;
                  cm.markText({ line:range.start.line, ch:range.start.ch},
                              { line:range.end.line,   ch:range.end.ch  },
                              { className: 'graffiti-highlight ' + marker });
                }
              }
            }
          }
        }
      },

      refreshAllGraffitiSideMarkers: () => {
        const activity = state.getActivity();
        if (activity === 'playing' || activity === 'recording' || activity === 'scrubbing') {
          return; // don't update these during playback, recording or scrubbing... too slow
        }
        const cells = Jupyter.notebook.get_cells();
        for (let cell of cells) {
          graffiti.refreshGraffitiSideMarkers(cell);
        }
      },

      refreshAllGraffitiHighlights: () => {
        const cells = Jupyter.notebook.get_cells();
        let params;
        for (let cell of cells) {
          params = { cell: cell, clear: true };
          graffiti.refreshGraffitiHighlights(params);
          graffiti.refreshGraffitiSideMarkers(cell);
        }
      },

      updateRefreshableCell: () => {
        const highlightRefreshCellId = state.getHighlightsRefreshCellId();
        if (highlightRefreshCellId !== undefined) {
          const highlightRefreshCell = utils.findCellByCellId(highlightRefreshCellId);
          if (highlightRefreshCell !== undefined) {
            graffiti.refreshGraffitiHighlights({cell: highlightRefreshCell, clear: true});
            graffiti.refreshGraffitiSideMarkers(highlightRefreshCell);
          }
          state.clearHighlightsRefreshableCell();
        }
      },

      hideTip: (tip) => {
        graffiti.notebookContainer.find('.graffiti-tip .headline').remove();
        graffiti.notebookContainer.find('.graffiti-tip').hide();
        // I think this is messing up clickable images.
        //state.clearPlayableMovie('tip');
      },

      refreshGraffitiTooltipsCore: (highlightElem, eventType) => {
        // console.log('Graffiti: handling mousenter/mouseleave/mousemove:', eventType);
        const activity = state.getActivity();
        if (!highlightElem.hasClass('graffiti-highlight')) {
          highlightElem = highlightElem.parents('.graffiti-highlight');
        }
        const highlightElemRect = highlightElem[0].getBoundingClientRect();
        const highlightElemMaxDimension = Math.max(highlightElemRect.width, highlightElemRect.height);
        const highlightElemMaxDimensionSquared = highlightElemMaxDimension * highlightElemMaxDimension;
        const idMatch = highlightElem.attr('class').match(/graffiti-(id_.[^\-]+)-(id_[^\s]+)/);
        if (idMatch !== null) {
          // This is the id of the cell the graffiti was recorded in. the graffiti may have been moved to another cell though, so we need to check
          // if it's mapped to what the reality of the graffit's current location is.
          const cellId = idMatch[1];
          const recordingKey = idMatch[2];
          const viewInfo = state.getViewInfo();
          if (viewInfo === undefined) {
            console.log('Graffiti: warning, viewInfo not defined in refreshGraffitiTooltipsCore!');
            return;
          }
          const hoverCellId = viewInfo.cellId;
          const hoverCell = utils.findCellByCellId(hoverCellId);
          if (hoverCell === undefined) {
            console.log('Graffiti: warning, could not find hoverCell for hoverCellId:', hoverCellId);
            return;
          }
          const hoverCellElement = hoverCell.element[0];
          const hoverCellElementPosition = $(hoverCellElement).position();
          const hoverCellType = hoverCell.cell_type;
          let outerInputElement;
          if (hoverCellType === 'markdown') {
            outerInputElement = $(hoverCellElement).find('.inner_cell');
          } else {
            outerInputElement = $(hoverCellElement).find('.CodeMirror-lines');
          }

          const recording = state.getManifestSingleRecording(cellId, recordingKey);
          if (recording === undefined)  {
            return;
          }

          //console.console.log();('refreshGraffitiTooltips: recording=', recording, cellId, recordingKey);
          if (recording.hasMovie) {
            //console.log('Graffiti: refreshGraffitiTooltips: recording=', recording, cellId, recordingKey);
            state.setPlayableMovie('tip', cellId, recordingKey, hoverCellId);
          }                
          state.setHidePlayerAfterPlayback(false); // default for any recording is not to hide player
          const tooltipCommands = graffiti.extractTooltipCommands(recording.markdown);

          if (recording.playOnClick) {
            //console.log('Graffiti: binding target for click', highlightElem);
            highlightElem.off('click dblclick').bind('click dblclick', (e) => {
              state.clearTipTimeout();
              e.stopPropagation(); // for reasons unknown event still propogates to the codemirror editing area undeneath...

              if (state.getActivity() === 'recordingPending') {
                graffiti.toggleRecording(); // we want clicks on playOnClick to be ignored if a recording is pending.
                return true; // let the focus bubble up so the cell is selected before the recording starts.
              } else {
                graffiti.playMovieViaUserClick();
                return false;
              }
            });
          }

          if ((recording.hideTooltip) || (recording.terminalCommand !== undefined) || activity === 'recording') {
            // console.log('Graffiti: recording is set to hide tip or recording is set to run a terminal command, or recording so we do not display tips');
            return;
          }

          let existingTip = graffiti.notebookContainer.find('.graffiti-tip');
          if (eventType === 'mouseleave') {
            state.setTipTimeout(() => { graffiti.hideTip(); }, 500);
          } else {
            let currentPointerPosition = state.getPointerPosition();
            // Only show tip if cursor rests on hover for a 1/2 second
            state.setTipTimeout(() => {
              //console.log('tip interval');
              const newPointerPosition = state.getPointerPosition();
              const cursorDistanceSquared = (newPointerPosition.x - currentPointerPosition.x) * (newPointerPosition.x - currentPointerPosition.x) +
                                            (newPointerPosition.y - currentPointerPosition.y) * (newPointerPosition.y - currentPointerPosition.y);

              //console.log('comparing currentPointerPosition, newPointerPosition:', currentPointerPosition,
              //newPointerPosition, cursorDistanceSquared);
              // Only show tip if cursor isn't flying over the item at high speeds
              if (cursorDistanceSquared > highlightElemMaxDimensionSquared) {
                currentPointerPosition = state.getPointerPosition();
              } else {
                let contentMarkdown = '';
                //console.log('markId:', markId, 'recordings:', hoverCell.metadata.recordings);
                let headlineMarkdown = '';
                if (tooltipCommands !== undefined) {
                  headlineMarkdown = '<div class="headline">' +
                                     ' <div>' + tooltipCommands.captionPic + '</div>' +
                                     ' <div>' + tooltipCommands.caption + '</div>' +
                                                   (tooltipCommands.captionVideo !== undefined ?
                                                    ' <div class="graffiti-video">' + tooltipCommands.captionVideo + '</div>' : '' ) +
                                     '</div>';
                }
                contentMarkdown = utils.renderMarkdown(recording.markdown)
                // if no tooltip is defined, show a default message. in this case, entire tip becomes clickable to play any movie this graffiti may have
                let entireTipClickable = false;
                if ((contentMarkdown.length === 0) && (recording.hidePlayButton)) {
                  contentMarkdown = utils.renderMarkdown('_' + localizer.getString('TOOLTIP_HINT') + '_');
                  entireTipClickable = true;
                }
                let tooltipContents = headlineMarkdown + '<div class="parts">' + '<div class="info">' + contentMarkdown + '</div>';
                if ((recording.hasMovie) && (!recording.hidePlayButton)) {
                  graffiti.tooltipButtonLabel = (((tooltipCommands !== undefined) && (tooltipCommands.buttonName !== undefined)) ? 
                                                 tooltipCommands.buttonName : 'Play Movie');
                  tooltipContents +=
                    '   <div class="movie"><button class="btn btn-default btn-small" id="graffiti-movie-play-btn">' + 
                    graffiti.tooltipButtonLabel + '</button></div>';
                }
                tooltipContents += '</div>';

                if (existingTip.length === 0) {
                  existingTip = $('<div class="graffiti-tip" id="graffiti-tip">' + tooltipContents + '</div>')
                    .prependTo(graffiti.notebookContainer);
                  existingTip.bind('mouseenter mouseleave', (e) => {
                    // console.log(eventType === 'mouseenter' ? 'entering tooltip' : 'leaving tooltip');
                    if (e.type === 'mouseenter') {
                      state.clearTipTimeout();
                    } else {
                      //console.log('hiding tip');
                      graffiti.hideTip();
                    }
                  });
                } else {
                  // Don't replace the tip if the contents are identical to what we had on the last interval.
                  const currentTipInfo = state.getDisplayedTipInfo();
                  let doUpdate = true;
                  if (!graffiti.forcedGraffitiTooltipRefresh) {
                    if (currentTipInfo !== undefined) {
                      if ((currentTipInfo.cellId === cellId) && (currentTipInfo.recordingKey === recordingKey)) {
                        doUpdate = false;
                      }
                    }
                  }
                  graffiti.forcedGraffitiTooltipRefresh = false;
                  if (doUpdate) {
                    //console.log('replacing tooltip contents ');
                    existingTip.find('#graffiti-movie-play-btn').unbind('click');
                    existingTip.html(tooltipContents);
                    state.setDisplayedTipInfo(cellId,recordingKey);
                  } else {
                    if (graffiti.tooltipButtonLabel !== undefined) {
                      $('#graffiti-movie-play-btn').html(graffiti.tooltipButtonLabel);
                    }
                  }
                  $('#graffiti-movie-play-btn').prop('disabled',false);
                }

                // Set up the call back for the play button on the tooltip that will actually play the movie
                // (or the entire tip, when the entire tip is clickable)
                let bindableTip = (entireTipClickable ? existingTip : existingTip.find('#graffiti-movie-play-btn'));
                bindableTip.unbind('click').click((e) => {
                  state.clearTipTimeout();
                  e.stopPropagation(); // for reasons unknown event still propogates to the codemirror editing area undeneath...
                  graffiti.playMovieViaUserClick();
                  return false;
                });
                const outerInputOffset = outerInputElement.offset();
                const outerInputElementWidth = outerInputElement.width();
                const highlightElemOffset = highlightElem.offset();
                const existingTipWidth = existingTip.width();
                const existingTipHeight = existingTip.height();
                let tipTop = parseInt(highlightElemOffset.top - outerInputOffset.top) - existingTipHeight - graffiti.tipAboveFudge;
                let tipLeft, anchorIsImage = false;
                if (hoverCellType === 'markdown') {
                  const anchorImage = highlightElem.find('img');
                  if (anchorImage.length > 0) {
                    const anchorElemOffset = anchorImage.offset();
                    //console.log('anchorElemOffset', anchorElemOffset);
                    tipLeft = anchorElemOffset.left + anchorImage.width() / 2 - existingTipWidth / 2;
                    tipTop =  anchorElemOffset.top - outerInputOffset.top + anchorImage.height() / 2 - existingTipHeight / 2;
                    anchorIsImage = true;
                    //console.log('image tipLeft, tipTop:', tipLeft, tipTop);
                  } else {
                    const anchorElem = highlightElem.find('i');
                    const anchorElemOffset = anchorElem.offset();
                    const posCandidate1 = outerInputElementWidth - existingTipWidth + outerInputOffset.left - graffiti.notebookContainerPadding;
                    const posCandidate2 = anchorElemOffset.left;
                    tipLeft = parseInt(Math.min(posCandidate1, posCandidate2));
                  }
                } else {                    
                  tipLeft = parseInt(Math.min(outerInputElementWidth - existingTipWidth,
                                              Math.max(highlightElemOffset.left, outerInputOffset.left)));
                }

                // Place tip in the best position on the screen.
                const tipPosition = { left: tipLeft, top: tipTop };
                //console.log('outerInputOffset:', outerInputOffset, 'highlightElemOffset:', highlightElemOffset, 'tipPosition:', tipPosition);
                //console.log('1) tipPosition:', tipPosition);
                const headerRect = $('#header')[0].getBoundingClientRect();
                // If the highlight element is in the upper half of the notebook panel area, flip the tooltip to be below the highlightElem.
                const rectDifference = highlightElemRect.top - headerRect.bottom - 20;
                if (rectDifference < existingTipHeight && !anchorIsImage) { // place tip below the line
                  tipPosition.top = highlightElemOffset.top - outerInputOffset.top + graffiti.cmLineHeight + graffiti.cmLineTipFudge;
                }
                //console.log('2) tipPosition:', tipPosition);
                tipPosition.top += hoverCellElementPosition.top;
                //console.log('3) tipPosition:', tipPosition);

                const positionPx = { left: tipPosition.left + 'px', top: tipPosition.top + 'px' };
                existingTip.css(positionPx);
                existingTip.show();

                // increase counter of total tips shown this session
                state.updateUsageStats({
                  type:'tip',
                  data: { 
                    cellId: cellId,
                    recordingKey: recordingKey
                  }
                });

              }
            }, 425); // this number is how long user has to hover before we display the tooltip
          }
        }
      },

      refreshGraffitiTooltips: () => {
        const tips = $('.graffiti-highlight');
        //console.trace('refreshGraffitiTooltips: binding mousenter/mouseleave');
        tips.unbind('mouseenter mouseleave mousemove').bind('mouseenter mouseleave mousemove', (e) => { graffiti.refreshGraffitiTooltipsCore($(e.target), e.type); } );
      },

      handleExecuteCellViaGraffiti: () => {
        const selectedCell = Jupyter.notebook.get_selected_cell();
        if (selectedCell.cell_type === 'code') {
          const config = utils.getCellGraffitiConfig(selectedCell);
          if (config !== undefined) {
            if (config.hasOwnProperty('executeCellViaGraffiti')) {
              const execKey = config['executeCellViaGraffiti'];
              const keyParts = execKey.split('_');
              state.setPlayableMovie('cellExecute', 'id_' + keyParts[0], 'id_' + keyParts[1]);
              graffiti.loadAndPlayMovie('cellExecute');
              return true;
            }
          }
        }
        return false;
      },

      clearSkipKeyDownTimer: () => {
        clearTimeout(graffiti.skipKeyDownTimer);
        graffiti.skipKeyDownTimer = undefined;
      },

      handleKeydown: (e) => {
        const keyCode = e.which;
        const activity = state.getActivity();
        let stopProp = false;

        //console.log('handleKeydown keyCode:', keyCode, String.fromCharCode(keyCode));
        if (activity === 'recording') {
          if (keyCode === graffiti.skipKeyCode) {
            graffiti.skipKeyDownTimer = setTimeout(() => { 
              console.log('Graffiti: ending recording by key press.');
              graffiti.skipKeyDownTimer = undefined;
              graffiti.endRecordingByKeyPress();
            }, state.END_RECORDING_KEYDOWN_TIMEOUT);
          }
        }


        if (terminalLib.getFocusedTerminal() !== undefined) {
          // Let any focused terminal handle the event. Don't let jupyter or anybody else get it. 
          // (Graffiti will need to capture the data during recording though.)
          // console.log('Graffiti: Focused terminal so stopping propogation');
          e.stopPropagation(); 
          return true;
        }
          
        // If user hit shift-enter or ctrl-enter, in a code cell, and it is marked as "executeCellViaGraffiti" then it will
        // actually run a graffiti movie when you try to execute that cell, rather than the jupyter default (only when in 'idle' activity)
        if (activity === 'idle') {
          if (keyCode === 13) {
            if (e.ctrlKey || e.shiftKey) {
              if (graffiti.handleExecuteCellViaGraffiti()) {
                console.log('Graffiti: executedCellViaGraffiti ran, so: intercepting return-key press.');
                e.stopPropagation();
                return true;
              }
            }
          }
        }

        if ((((48 <= keyCode) && (keyCode <= 57)) ||    // A-Z
             ((65 <= keyCode) && (keyCode <= 90)) ||    // 0-9
             ((37 <= keyCode) && (keyCode <= 40)) ||    // arrow keys                
             (keyCode === 32))                          // space bar
            && activity === 'playing') {
          // Pressing keys : A-Z, 0-9, arrows, and spacebar stop any playback in progress.
          stopProp = true;
          graffiti.togglePlayback();
        } else {
          // Check for other keypress actions
          switch (keyCode) {
            case 27: // escape key CANCELS playback
              stopProp = true;
              if ((activity === 'playing') || (activity === 'playbackPaused') || (activity === 'scrubbing')) {
                graffiti.cancelPlayback();
              }
              break;
            case 16: // shift key
              state.setShiftKeyIsDown(true);
              state.updateDrawingState([ { change: 'stickerOnGrid', data: true } ]);
              //console.log('Graffiti: shiftKeyIsDown');
              break;
              // case 13: // enter key
              // case 18: // meta key
              // case 91: // option key
              //   break;
            default:
              break; // let any other keys pass through
          }
        }
        
        if (stopProp) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        return true;
      },

      handleKeyup: (e) => {
        //console.log('keyUp e.which:', e.which);
        const keyCode = e.which;
        if (keyCode === 16) {
          state.setShiftKeyIsDown(false);
          state.updateDrawingState([ { change: 'stickerOnGrid', data: false } ]);
        } else {
          if ((keyCode === graffiti.skipKeyCode) && (graffiti.skipKeyDownTimer !== undefined)) {
            graffiti.clearSkipKeyDownTimer();
            graffiti.toggleRecordingSkip();
            return true;
          }
        }
        return false;
      },

      // If the skip key was down then we want to cancel the timeout it created, because a mouse click happened (e.g. option-select)
      handleGeneralClick: (e) => {
        //console.log('handled a click');
        graffiti.clearSkipKeyDownTimer();
        return false;
      },
      
      setupBackgroundEvents: () => {
        // Handle rubber banding scrolling that occurs on short notebooks so cursor doesn't look wrong (possibly, only chrome?).
        console.log('Graffiti: setupBackgroundEvents');

        graffiti.sitePanel.on('scroll', (e) => {
          const notebookPanelHeight = graffiti.notebookPanel.height();
          const viewInfo = utils.collectViewInfo(state.getPointerPosition().x,
                                                 state.getPointerPosition().y,
                                                 graffiti.notebookPanel.height(),
                                                 graffiti.sitePanel.scrollTop() - state.getScrollTop());
          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.storeViewInfo(viewInfo);
          state.storeHistoryRecord('scroll');
          if (state.getActivity() === 'playbackPaused') {
            graffiti.undimGraffitiCursor();            
          }
          return true;
        });

        // Temporarily defeating mousewheel pausing of playback because of all the issues showing up
        // when graffitized notebooks are in an iframe. Since the iframe doesn't know its extents accurately
        // visavis the viewport, the user sometimes needs to manually scroll around to keep up with a video
        // that's playing in an iframe. Mousewheel-pause was defeating this workaround so it's turned off.
        // 3/18/19
/*
        graffiti.sitePanel.on('mousewheel', (e) => {
          if (state.getActivity() === 'playing') {
            console.log('Graffiti: pausing playback because of mousewheel scroll.');
            graffiti.pausePlayback();
          }
        });
*/

        $('body').keydown((e) => {
          return graffiti.handleKeydown(e);
        });

        $('body').keyup((e) => {
          return graffiti.handleKeyup(e);
        });
        
        $('body, .cell').click((e) => {
          graffiti.handleGeneralClick(e);
        });

        window.onmousemove = (e) => {
          //console.log('cursorPosition:[',e.clientX, e.clientY, ']');
          //console.log('mouse_e:', e.pageX, e.pageY);
          const previousPointerPosition = state.getPointerPosition();
          const previousPointerX = previousPointerPosition.x;
          const previousPointerY = previousPointerPosition.y;
          state.storePointerPosition( e.clientX, e.clientY ); // keep track of current pointer position at all times
          const viewInfo = utils.collectViewInfo(e.clientX, 
                                                 e.clientY, 
                                                 graffiti.notebookPanel.height(), 
                                                 graffiti.sitePanel.scrollTop() - state.getScrollTop());
          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.storeViewInfo(viewInfo);
          state.storeHistoryRecord('pointer');


          let doDrawingDisplayUpdate = true;
          const drawingActivity = state.getDrawingStateField('drawingActivity');
          if (drawingActivity === 'sticker') {
            const stickerType = state.getDrawingPenAttribute('stickerType');
            if (stickerType === 'label') {
              // We do not want to update the label during recording because this fn is called via onmousemove.
              // We update the label directly from handleLabelInput(), above, for that special case. Otherwise, we
              // will end up dragging the label around the screen while the mousebutton is down.
              doDrawingDisplayUpdate = false;
            }
          }
          if (doDrawingDisplayUpdate) {
              graffiti.updateDrawingDisplayWhenRecording(previousPointerX, previousPointerY, e.clientX, e.clientY, viewInfo );
          }

          graffiti.placeControlPanel({});
          return true; // let this event bubble
        };

        // If we were playing a recording when they hit reload, we need to cancel it, restore, and save before we continue. 
        // Needs more testing!!
        window.addEventListener('beforeunload', function (e) {
          console.log('Graffiti: before unload handler.');
          const activity = state.getActivity();
          if ((activity === 'playing') || (activity === 'playbackPaused') || (activity == 'scrubbing')) {
            graffiti.cancelPlaybackNoVisualUpdates();
          }
          if (workspace.trackUsageStats !== undefined) {
            workspace.trackUsageStats();
          }
        });

        // To make async calls work on non-chrome browsers
        // https://stackoverflow.com/a/20322988/4953199
        window.onunload = (e) => {
          console.log('Graffiti: on unload');
          if (workspace.trackUsageStats !== undefined) {
            workspace.trackUsageStats();
          }
        };

        // https://stackoverflow.com/questions/19469881/remove-all-event-listeners-of-specific-type
        window.addEventListener('dblclick', (e) => { 
          if (state.getActivity() === 'recording') {
            const isTextCell = ($(e.target)).parents('.text_cell');
            if (isTextCell.length > 0) {
              console.log('Graffiti: intercepted doubleclick on markdown during recording, discarding it');
              e.stopPropagation();
              e.preventDefault();
              return true;
            }
          }
          return false;
        }, true);

        window.onblur = (e) => {
          //console.log('window lost focus, pausing any playing movie');
          graffiti.pausePlayback();
        },

        // Serialize/deserialize range objects
        // https://github.com/tildeio/range-serializer
        // https://www.npmjs.com/package/serialize-selection

        // Specially handle selection changes in rendered markdown cells and output areas during recordings
        document.addEventListener("selectionchange", function() {
          // get the selection and serialize it
          if (state.getActivity() === 'recording') {
            state.clearSelectionSerialized();
            const viewInfo = state.getViewInfo();
            const cellId = viewInfo.cellId;
            if (cellId !== undefined) {
              const hoverCell = utils.findCellByCellId(cellId);
              let parentNode;
              if (hoverCell.cell_type === 'markdown') {
                parentNode = $(hoverCell.element).find('.rendered_html');
              } else {
                parentNode = $(hoverCell.element).find('.output_subarea');
              }
              if (parentNode.length > 0) {
                const selectionSerialized = selectionSerializer.get(parentNode[0]);
                if (!selectionSerialized.empty) {
                  selectionSerialized.cellType = hoverCell.cell_type;
                  selectionSerialized.cellId = cellId;
                  // utils.shrinkAllCMSelections(); // cancel all CM selections as they will prevent replaying selection changes in other dom elements
                  state.setSelectionSerialized(selectionSerialized);
                  state.storeHistoryRecord('selections');
                }
              }
            }
          }
        });

        graffiti.handleSliderDragDebounced = _.debounce(graffiti.handleSliderDrag, 20, false);
        console.log('Graffiti: Background setup complete.');
      },

      setRecordingTakeId: (recordingRecord) => {
        if (recordingRecord.activeTakeId === undefined ||
            state.getMovieRecordingStarted()) { // if making a new take, must create a new activeTakeId
          recordingRecord.activeTakeId = utils.generateUniqueId(); // do not set a new activeTakeId if there was already a valid one set for the movie
        }
      },

      storeRecordingInfoInCell: (isOldGraffiti) => {
        let recordingRecord, newRecording, recordingCell, recordingCellId, recordingKey;
        const selectedTokens = graffiti.selectedTokens;        
        if (isOldGraffiti === undefined) {
          isOldGraffiti = selectedTokens.isIntersecting;
        }
        if (isOldGraffiti) { 
          // Prepare to update existing recording
          recordingCellId = utils.extractRecordingCellId(selectedTokens);
          recordingCell = selectedTokens.recordingCell;
          recordingKey = selectedTokens.recordingKey;
          recordingRecord = state.getManifestSingleRecording(recordingCellId, recordingKey);
          graffiti.previousActiveTakeId = recordingRecord.activeTakeId;
          graffiti.setRecordingTakeId(recordingRecord);
          newRecording = false;
        } else { 
          // Prepare to create a new recording
          graffiti.previousActiveTakeId = undefined;
          recordingCell = Jupyter.notebook.get_selected_cell();
          recordingCellId = utils.getMetadataCellId(recordingCell.metadata);
          recordingKey = utils.generateUniqueId();
          newRecording = true;
          recordingRecord = {
            cellId: recordingCellId,
            cellType: recordingCell.cell_type,
            createDate: utils.getNow(),
            inProgress: true,
            tokens: $.extend({}, graffiti.selectedTokens.tokens),
            range: $.extend({}, graffiti.selectedTokens.range),
            allTokensString: graffiti.selectedTokens.allTokensString,
            markdown: '',
            authorId: state.getAuthorId(),
            authorType: state.getAuthorType(), // one of "creator" (eg teacher), "viewer" (eg student)
            activeTakeId: undefined, // this will be replaced with an id for the first movie recording made
            hasMovie: false
          }
          state.setSingleManifestRecording(recordingCellId, recordingKey, recordingRecord);
        }

        state.storeRecordingCellInfo({
          newRecording: newRecording,
          recordingRecord: recordingRecord,
          recordingCell: recordingCell,
          recordingCellId: recordingCellId,
          recordingKey: recordingKey,
          scrollTop: graffiti.sitePanel.scrollTop()
        });

        return recordingRecord;
      },

      clearHighlightMarkText: () => {
        if (graffiti.highlightMarkText !== undefined) {
          graffiti.highlightMarkText.clear();
          graffiti.highlightMarkText = undefined;
        }
      },

      highlightIntersectingGraffitiRange: () => {
        graffiti.clearHighlightMarkText();
        if (state.getAccessLevel() === 'view') { // we never do this in view mode
          return;
        }
        const cell = graffiti.selectedTokens.recordingCell;
        if (cell !== undefined) {
          const cm = cell.code_mirror;
          const startLoc = cm.posFromIndex(graffiti.selectedTokens.range.start);
          const endLoc = cm.posFromIndex(graffiti.selectedTokens.range.end);
          graffiti.highlightMarkText = cm.markText(startLoc, endLoc, { className: 'graffiti-selected' });
        }
      },

      selectIntersectingGraffitiRange: () => {
        if (graffiti.selectedTokens.noTokensPresent) {
          return;
        }
        const recordingCellInfo = state.getRecordingCellInfo();
        const recordingCell = recordingCellInfo.recordingCell;
        const cm = recordingCell.code_mirror;
        const startLoc = cm.posFromIndex(graffiti.selectedTokens.range.start);
        const endLoc = cm.posFromIndex(graffiti.selectedTokens.range.end);
        cm.setSelections([ { anchor: startLoc, head: endLoc } ]);        
        graffiti.selectedTokens = utils.findSelectionTokens(recordingCell, graffiti.tokenRanges, state);
        graffiti.highlightIntersectingGraffitiRange();
      },

      // Edit an existing graffiti, or if we are creating a new one, set up some default values.
      // If creating a new graffiti in markdown text, jump directly to the movie recording phase.
      editGraffiti: () => {
        let editableText;

        graffiti.changeActivity('graffiting');
        state.setLastEditActivityTime();
        const isNewGraffiti = !graffiti.selectedTokens.isIntersecting;
        const isOldGraffiti = !isNewGraffiti;
        const recordingRecord = graffiti.storeRecordingInfoInCell(isOldGraffiti);
        const activeCellIndex = Jupyter.notebook.get_selected_index();
        const isMarkdownCell = (recordingRecord.cellType === 'markdown');
        const isCodeCell = (recordingRecord.cellType === 'code');
        const graffitiEditCell = Jupyter.notebook.insert_cell_above('markdown');
        const editCellIndex = utils.findCellIndexByCellId(utils.getMetadataCellId(graffitiEditCell.metadata));
        Jupyter.notebook.select(editCellIndex); // cell *must* be selected before unrender() called by set_text() below will actually unrender the cell correctly.

        if (isNewGraffiti || isCodeCell || (isMarkdownCell && isOldGraffiti)) {
          utils.setMetadataCellId(graffitiEditCell.metadata,utils.generateUniqueId());
          utils.refreshCellMaps();
          state.setGraffitiEditCellId(utils.getMetadataCellId(graffitiEditCell.metadata));
        }

        if (isNewGraffiti) {
          if (isMarkdownCell) {
            // Set up some reasonable options for Graffiti in markdown. Author can, of course, opt to change these any time.
            editableText = localizer.getString('BELOW_TYPE_MARKDOWN') +
                           "%%play_on_click\n" +
                           "%%hide_player_after_playback_complete\n" +
                           "%%hide_play_button\n";
          } else {
            editableText = localizer.getString('BELOW_TYPE_MARKDOWN') +
                           graffiti.selectedTokens.allTokensString;
          }
        } else {
          // Use whatever author put into this graffiti previously
          editableText = recordingRecord.markdown; 
        }

        graffitiEditCell.set_text(editableText);

        if (isCodeCell || isOldGraffiti) { 
          // For code cell graffiti or non-new markdown graffiti, let us edit the tip contents by scrolling to the edit cell
          Jupyter.notebook.scroll_to_cell(Math.max(0,activeCellIndex),500);
          const selectedCell = Jupyter.notebook.get_selected_cell();
          selectedCell.unselect();
          graffitiEditCell.select();
          graffitiEditCell.code_mirror.focus();
          graffitiEditCell.code_mirror.setSelection( { line:2, ch:0}, { line:10000, ch:10000} );
        }

        if (isMarkdownCell && isNewGraffiti) {
          // Proceed directly to recording a movie, assuming we want to persist this new graffiti (no way to cancel)
          graffiti.finishGraffiti(true).then(() => {
            graffiti.setRecordingTakeId(recordingRecord);
            // Force this function to treat this as a new movie even though we've automatically created the manifest entry.
            graffiti.beginMovieRecordingProcess(true, recordingRecord);
          });
        }
      },

      finishGraffiti: (doSave) => {
        const activity = state.getActivity();
        if (activity !== 'graffiting') {
          return;
        }

        const recordingCellInfo = state.getRecordingCellInfo();
        const recordingCell = recordingCellInfo.recordingCell;

        const editCellIndex = utils.findCellIndexByCellId(state.getGraffitiEditCellId());

        let editCellContents = '';
        if (editCellIndex !== undefined) {
          const editCell = utils.findCellByCellId(state.getGraffitiEditCellId());
          editCellContents = editCell.get_text();
          Jupyter.notebook.delete_cell(editCellIndex);

          // Save the graffiti text into the right cell recording.
          const recordings = state.getManifestRecordingsForCell(recordingCellInfo.recordingCellId);
          if (doSave) {
            if (recordingCellInfo.newRecording) {
              recordings[recordingCellInfo.recordingKey] = recordingCellInfo.recordingRecord;
            }
            recordings[recordingCellInfo.recordingKey].markdown = editCellContents;

            const tooltipCommands = graffiti.extractTooltipCommands(editCellContents);
            const recording = recordings[recordingCellInfo.recordingKey];
            recording.autoplay = 'never';
            if (tooltipCommands.autoplay === 'always') {
              recording.autoplay = 'always';
            } else if (tooltipCommands.autoplay === 'once') {
              recording.autoplay = 'once';
              recording.playedOnce = false;
            }

            // These next lines should be reduce to a single $.extend() call...
            recording.playOnClick = tooltipCommands.playOnClick;
            recording.hideTooltip = tooltipCommands.hideTooltip;
            recording.hidePlayButton = tooltipCommands.hidePlayButton
            recording.narratorName = tooltipCommands.narratorName;
            recording.narratorPicture = tooltipCommands.narratorPicture;
            recording.stickerImageUrl = tooltipCommands.stickerImageUrl;
            recording.skipInfo = $.extend({}, tooltipCommands.skipInfo);
            recording.saveToFile = tooltipCommands.saveToFile;
            recording.terminalCommand = tooltipCommands.terminalCommand;
            recording.insertDataFromFile = tooltipCommands.insertDataFromFile;
            recording.silenceWarnings = tooltipCommands.silenceWarnings;
            recording.replayAllCells = tooltipCommands.replayAllCells;
            recording.scaleCursorWithWindow = tooltipCommands.scaleCursorWithWindow;
            recording.swappingLabels = tooltipCommands.swappingLabels;
            recording.labelSwaps = tooltipCommands.labelSwaps;

            state.updateUsageStats({
              type:'create',
              data: {
                createDate:   recording.createDate,
                cellId:       recordingCellInfo.recordingCellId,
                recordingKey: recordingCellInfo.recordingKey,
                numTakes:     (recording.takes === undefined ? 0 : Object.keys(recording.takes).length),
              }
            });
            
            console.log('Graffiti: finishGraffiti: we got these stats:', state.getUsageStats(), recording);

          } else { // Not saving (recording cancelled by user), so make sure we remove this record from the manifest before saving.
            if (recordingCellInfo.newRecording) {
              state.removeManifestEntry(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey);
            }
          }
        }
        storage.storeManifest();

        if ((recordingCell.cell_type === 'markdown') && (recordingCellInfo.newRecording) && doSave) {
          // If we were adding a Graffiti to a markdown cell, we need to modify the markdown cell to include 
          // our Graffiti span tag around the selection.
          const contents = recordingCell.get_text();
          let parts = [];
          parts.push(contents.substring(0,recordingCellInfo.recordingRecord.range.start));
          parts.push(contents.substring(recordingCellInfo.recordingRecord.range.start, recordingCellInfo.recordingRecord.range.end));
          parts.push(contents.substring(recordingCellInfo.recordingRecord.range.end));
          const spanOpenTag = '<span class="graffiti-highlight graffiti-' + 
                              recordingCellInfo.recordingCellId + '-' + recordingCellInfo.recordingKey + '"><i></i>'; // empty italic helps us find its anchor for tooltip
          const newContents = parts[0] + spanOpenTag + parts[1] + '</span>' + parts[2];
          //console.log('newContents:', newContents);
          recordingCell.set_text(newContents);
        }

        return new Promise((resolve) => {
          utils.saveNotebook(() => {

            // need to reselect graffiti text that was selected in case it somehow got unselected
            //recordingCell.code_mirror.setSelections(recordingCellInfo.selections);
            graffiti.sitePanel.animate({ scrollTop: recordingCellInfo.scrollTop}, 500);
            if (recordingCellInfo.recordingRecord.cellType === 'markdown') {
              recordingCell.render();
            }
            graffiti.changeActivity('idle');
            recordingCell.code_mirror.focus();
            if (doSave) {
              graffiti.refreshGraffitiHighlights({cell: recordingCell, clear: false});
              graffiti.forcedGraffitiTooltipRefresh = true;
            } else {
              graffiti.refreshGraffitiHighlights({cell: recordingCell, clear: true});
            }
            graffiti.refreshGraffitiTooltipsDebounced();
            graffiti.refreshAllGraffitiSideMarkers();
            utils.refreshCellMaps();
            state.refreshCellIdToGraffitiMap();
            resolve();
          });
        });
      },

      removeGraffitiCore: (recordingCellId, recordingKey) => {
        const recordingCell = utils.findCellByCellId(recordingCellId);
        let locationCell;
        if (recordingCell !== undefined) {
          if (recordingCell.cell_type === 'code') {
            locationCell = recordingCell; // note the *code* cell where this graffiti is currently present
          }
        }
        const locationCellId = utils.findCellIdByLocationMap(recordingCellId, recordingKey); // find the actual cell where the graffiti is now living.
        if (locationCellId !== undefined) {
          locationCell = utils.findCellByCellId(locationCellId); // find the *markdown* cell where this recording is currently present
        }
        const currentActivity = state.getActivity();
        if (locationCell.cell_type === 'markdown') {
          // If this Graffiti was in a markdown cell we need to remove the span tags from the markdown source
          const contents = locationCell.get_text();
          const spanRegex = RegExp('<span class="graffiti-highlight graffiti-' + recordingCellId + '-' + recordingKey + '"><i></i>(.*?)</span>','gm')
          let results, foundContents = [];
          while ((results = spanRegex.exec(contents)) !== null) { foundContents.push(results) };
          if (foundContents.length > 0) {
            const innerContents = foundContents[0][1];
            const sourceContents = '<span class="graffiti-highlight graffiti-' + recordingCellId + '-' + recordingKey + '"><i></i>' + innerContents + '</span>';
            const cleanedContents = contents.replace(sourceContents, innerContents);
            // For some unknown reason we have to select a cell before calling set_text() on it, for that fn to work.
            utils.selectCellByCellId(locationCellId);
            setTimeout(() => {
              locationCell.set_text(cleanedContents);
              locationCell.render(); // re-render the cell because set_text will unrender it.
            }, 0);
          }
        }

        storage.deleteMovie(recordingCellId, recordingKey);
        utils.saveNotebook(() => {
          graffiti.updateControlPanels();
        });
      },


      removeAllGraffitis: (graffitiDisabled) => {
        const manifest = state.getManifest(); // save manifest before we wipe it out
        state.setManifest({}); // clear ALL graffiti in the manifest
        let recording, recordingCellId, recordingCell, recordingIds, recordingKeys, destructions = 0;
        for (recordingCellId of Object.keys(manifest)) {
          console.log('Graffiti: Removing recordings from cell:', recordingCellId);
          recordingKeys = Object.keys(manifest[recordingCellId]);
          if (recordingKeys.length > 0) {
            recordingCell = utils.findCellByCellId(recordingCellId);
            for (recordingKey of recordingKeys) {
              console.log('Graffiti: Removing recording id:', recordingKey);
              recording = manifest[recordingCellId][recordingKey];
              destructions++;
              graffiti.removeGraffitiCore(recordingCellId, recordingKey);
              if (recordingCell !== undefined) {
                graffiti.refreshGraffitiHighlights({cell: recordingCell, clear: true});
                graffiti.refreshGraffitiSideMarkers(recordingCell);
              }
            }
          }
        }
        storage.storeManifest();
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();

        if (graffitiDisabled) {
          if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
            storage.deleteDataDirectory(Jupyter.notebook.metadata.graffiti.id);
            storage.removeGraffitiIds();
            graffiti.changeAccessLevel('view');
            graffiti.updateSetupButton();
          }
        }

        utils.saveNotebook(() => {

          if (destructions === 0) {
            destructions = 'all';
          }

          let title, body;
          if (graffitiDisabled) {
            title = 'Graffiti has been disabled on this Notebook.';
            body = 'We removed ' + destructions + ' graffitis, and you will need to Enable Graffiti again to use Graffiti in this notebook.' + 
                   'You will also now want to remove the Graffiti data directory (jupytergraffiti_data) manually.';
          } else {
            title = 'Your notebook is now cleaned of all graffiti.';
            body = 'We removed ' + destructions + ' graffitis. Feel free to create new ones.';
          }
          dialog.modal({
            title: title,
            body: body,
            sanitize:false,
            buttons: {
              'OK': {
                click: (e) => {
                  console.log('Graffiti: You clicked ok, you want to remove ALL graffitis');
                }
              }
            }
          });
        });

      },

      refreshAfterDeletions: (recordingCellId) => {
        graffiti.highlightIntersectingGraffitiRange();
        const recordingCell = utils.findCellByCellId(recordingCellId);
        if (recordingCell !== undefined) {
          graffiti.refreshGraffitiHighlights({cell: recordingCell, clear: true});
          graffiti.refreshGraffitiSideMarkers(recordingCell);
        }
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();
      },

      removeGraffiti: (recordingCellId, recordingKey) => {
        graffiti.removeGraffitiCore(recordingCellId, recordingKey);
        if (state.removeManifestEntry(recordingCellId, recordingKey)) {
          storage.storeManifest();
          graffiti.refreshAfterDeletions(recordingCellId);
        }
      },

      removeAllGraffitisWithConfirmation: () => {
        dialog.modal({
          title: 'Are you sure you want to remove ALL graffitis from this notebook?',
          body: 'Note: this cannot be undone.',
          sanitize:false,
          buttons: {
            'OK': {
              click: (e) => {
                console.log('Graffiti: You clicked ok, you want to remove ALL graffitis');
                graffiti.removeAllGraffitis(false);

              }
            },
            'Cancel': { click: (e) => { console.log('Graffiti: you cancelled:', $(e.target).parent()); } },
          }
        });

      },

      removeUnusedTakes: (recordingFullId) => {
        const parts = utils.parseRecordingFullId(recordingFullId);
        const recordingCell = utils.findCellByCellId(parts.recordingCellId);
        if (recordingCell !== undefined) {
          storage.removeUnusedTakes(parts.recordingCellId, parts.recordingKey);
          graffiti.refreshAfterDeletions(recordingCellId);
        }
      },

      removeAllUnusedTakes: () => {
        const manifest = state.getManifest(); // save manifest before we wipe it out
        let recording, recordingCellId, recordingCell, recordingIds, recordingKeys, deletedTakes = 0;
        for (recordingCellId of Object.keys(manifest)) {
          console.log('Graffiti: Removing unused takes from cell:', recordingCellId);
          recordingKeys = Object.keys(manifest[recordingCellId]);
          if (recordingKeys.length > 0) {
            recordingCell = utils.findCellByCellId(recordingCellId);
            for (recordingKey of recordingKeys) {
              console.log('Graffiti: Removing unused takes from recording id:', recordingKey);
              recording = manifest[recordingCellId][recordingKey];
              deletedTakes += storage.removeUnusedTakesCore(recordingCellId, recordingKey);
            }
          }
        }
        storage.storeManifest();
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();

        utils.saveNotebook(() => {
          if (deletedTakes === 0) {
            deletedTakes = 'all';
          } else {
            storage.storeManifest();
            storage.cleanUpExecutorCell();
            utils.saveNotebook();
          }

          const title = 'Unused takes removed.';
          const body = 'We removed ' + deletedTakes + ' unused takes.'
          dialog.modal({
            title: title,
            body: body,
            sanitize:false,
            buttons: {
              'OK': {
                click: (e) => {
                  console.log('Graffiti: You clicked ok');
                }
              }
            }
          });
        });
      },

      removeAllUnusedTakesWithConfirmation: () => {
        dialog.modal({
          title: 'Are you sure you want to remove ALL unused takes from this notebook?',
          body: 'Note: this cannot be undone.',
          sanitize:false,
          buttons: {
            'OK': {
              click: (e) => {
                console.log('Graffiti: You clicked ok, you want to remove unused takes.');
                graffiti.removeAllUnusedTakes();

              }
            },
            'Cancel': { click: (e) => { console.log('Graffiti: you cancelled:', $(e.target).parent()); } },
          }
        });
      },

      removeUnusedTakesWithConfirmation: (recordingFullId) => {
        dialog.modal({
          title: 'Are you sure you want to remove unused takes from this recording?',
          body: 'Note: this cannot be undone.',
          sanitize:false,
          buttons: {
            'OK': {
              click: (e) => {
                console.log('Graffiti: You clicked ok, you want to remove unused takes.');
                graffiti.removeUnusedTakes(recordingFullId);

              }
            },
            'Cancel': { click: (e) => { console.log('Graffiti: you cancelled:', $(e.target).parent()); } },
          }
        });

      },

      removeGraffitiWithPrompt: () => {
        const selectedTokens = graffiti.selectedTokens;
        if (selectedTokens.isIntersecting) {
          const recordingCellId = utils.extractRecordingCellId(selectedTokens);
          const recordingKey = selectedTokens.recordingKey;
          const recording = state.getManifestSingleRecording(recordingCellId,recordingKey);
          let graffitizedText = selectedTokens.allTokensString;
          if (graffitizedText === undefined) {
            graffitizedText = (recording.allTokensString !== undefined ? recording.allTokensString : recording.markdown );
          }
          const content = '(Please Note: this cannot be undone.)<br/>' +
                          '<b>Graffiti\'d text:&nbsp;</b><span class="graffiti-text-display">' + graffitizedText + '</span><br/>' +
                          '<b>Graffiti contents:</b>' + utils.renderMarkdown(recording.markdown) + '<br/>';
          
          const confirmModal = dialog.modal({
            title: 'Are you sure you want to remove this Graffiti?',
            body: content,
            sanitize:false,
            buttons: {
              'OK': {
                click: (e) => {
                  console.log('Graffiti: you clicked ok, you want to remove graffiti:',
                              $(e.target).parent());
                  graffiti.removeGraffiti(recordingCellId, recordingKey);

                }
              },
              'Cancel': { click: (e) => { console.log('Graffiti: you cancelled:', $(e.target).parent()); } },
            }
          });
          confirmModal.on('hidden.bs.modal', (e) => { 
            console.log('Graffiti: escaped the removeGraffitiWithPrompt modal.');
          });
        }
      },

      // Remove all graffiti and remove the graffiti id's as well. Basically, return a notebook to a pre-graffiti-ized state.
      disableGraffiti: () => {
        graffiti.removeAllGraffitis(true);
      },

      disableGraffitiWithConfirmation: () => {
        const content = 'Clicking OK will <i>remove any trace of Graffiti</i> in this notebook, setting it to a state as if you had never enabled Graffiti. ' +
                        '<br><br><b>NOTE</b>: This <b>cannot</b> be undone.';
        const confirmModal = dialog.modal({
          title: 'Are you sure you want to disable Graffiti?',
          body: content,
          sanitize:false,
          buttons: {
            'OK': {
              click: (e) => {
                console.log('Graffiti: you clicked ok, you want to disable graffiti:',
                            $(e.target).parent());
                graffiti.disableGraffiti();

              }
            },
            'Cancel': { click: (e) => { console.log('Graffiti: you cancelled:', $(e.target).parent()); } },
          }
        });

      },

      updateAllGraffitiDisplays: () => {
        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltipsDebounced();
      },

      //
      // Recording control functions
      //

      setPendingRecording: () => {
        console.log('Graffiti: Setting pending recording.');
        graffiti.changeActivity('recordingPending');
        state.restoreCellStates('selections'); // reset selections to when you clicked to begin the recording
      },

      beginMovieRecordingProcess: (isOldGraffiti, recordingRecord) => {
        // Preserve the state of all cells and selections before we begin recording so we can restore when the recording is done.
        state.storeCellStates();
        graffiti.preRecordingScrollTop = state.getScrollTop();
        state.setMovieRecordingStarted(true);
        if (recordingRecord === undefined) {
          recordingRecord = graffiti.storeRecordingInfoInCell(isOldGraffiti);
        }
        if (recordingRecord.cellType === 'markdown') {
          if (!graffiti.selectedTokens.noTokensPresent) {
            graffiti.selectedTokens.recordingCell.render();
          }
        }
        graffiti.setPendingRecording();
      },

      addCMEventsToSingleCell: (cell) => {
        graffiti.CMEvents[utils.getMetadataCellId(cell.metadata)] = true;
        const cm = cell.code_mirror;
        cm.on('focus', (cm, e) => {
          // console.log('Graffiti: CM focus:' , cm, e);
          // Check to see if we jumped from another cell to this cell with the arrow keys. If we did and we're recording, we need to
          // create a focus history record because jupyter is not firing the select cell event in those cases.
          const activity = state.getActivity();
          if (activity === 'recording') {
            const cellId = utils.getMetadataCellId(cell.metadata);
            if (cellId !== state.getSelectedCellId()) {
              state.saveSelectedCellId(cellId);
            }
            state.storeHistoryRecord('focus');
          } else if (activity === 'recordingPending') {
            // Ensure this cell has focus before recording begins.
            const focusCellIndex = utils.findCellIndexByCodeMirror(cm);
            Jupyter.notebook.select(focusCellIndex);
            graffiti.toggleRecording();
          }
          graffiti.updateControlPanels(cm); // this is necessary since a focus change can happen when you arrow advance from one cell to the next cell
        });

        cm.on('cursorActivity', (cm, e) => {
          //console.log('cursorActivity');
          if (state.getActivity() === 'idle') {
            graffiti.updateControlPanels(cm); // this is necessary because you can move the cursor from inside a graffiti to outside one
          }
          //console.log('graffiti.selectedTokens:', graffiti.selectedTokens);
          let affectedCell = utils.findCellByCodeMirror(cm);
          if (affectedCell === undefined) {
            utils.refreshCellMaps();
            affectedCell = utils.findCellByCodeMirror(cm);
            console.log('Graffiti: cursorActivity handler had to refreshCellMaps twice. Should never occur!');
          }
          state.storeCellIdAffectedByActivity(utils.getMetadataCellId(affectedCell.metadata));
          state.storeHistoryRecord('selections');
          graffiti.refreshGraffitiSideMarkers(affectedCell);
        });

        cm.on('change', (cm, changeObj) => {
          //console.log('change activity:', changeObj);
          const affectedCell = utils.findCellByCodeMirror(cm);
          const affectedCellId = utils.getMetadataCellId(affectedCell.metadata);
          if (affectedCell !== undefined) {
            state.storeCellIdAffectedByActivity(affectedCellId);
            state.storeHistoryRecord('contents');
            graffiti.executeSaveToFileDirectivesDebounced(affectedCellId); // if any graffiti call for this cell to be persisted to file(s), then do it now
            if (state.getActivity() === 'idle') {
              state.setHighlightsRefreshCellId(utils.getMetadataCellId(affectedCell.metadata));
              setTimeout(graffiti.updateRefreshableCell, 250); // set up to refresh side markers shortly after changes
            }
          }
        });

        cm.on('mousedown', (cm, e) => {
          //console.log('mousedown, e:', e);
        });

        cm.on('refresh', (cm, e) => {
          //console.log('**** CM refresh event ****');
        });

        cm.on('update', (cm, e) => {
          //console.log('**** CM update event ****');
          graffiti.refreshGraffitiTooltipsDebounced();
        });

        cm.on('scroll', (cm, e) => {
          const pointerPosition = state.getPointerPosition();
          const viewInfo = utils.collectViewInfo(pointerPosition.x,
                                                 pointerPosition.y, 
                                                 graffiti.notebookPanel.height(), 
                                                 graffiti.sitePanel.scrollTop() - state.getScrollTop());

          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.storeViewInfo(viewInfo);
          state.storeHistoryRecord('innerScroll');
        });

      },

      addCMEventsToCells: () => {
        const inputCells = Jupyter.notebook.get_cells();
        for (let cell of inputCells) {
          // Don't rebind if already bound
          if (!graffiti.CMEvents.hasOwnProperty(utils.getMetadataCellId(cell.metadata))) {
            graffiti.addCMEventsToSingleCell(cell);
          }
        }
      },

      // Bind all select, create, delete, execute  cell events at the notebook level
      addCMEvents: () => {
        graffiti.addCMEventsToCells();

        Jupyter.notebook.events.on('select.Cell', (e, cell) => {
          //console.log('cell select event fired, e, cell:',e, cell.cell);
          state.storeHistoryRecord('selectCell');
          graffiti.refreshGraffitiTooltipsDebounced();
          graffiti.updateControlPanels();
        });

        Jupyter.notebook.events.on('create.Cell', (e, results) => {
          //console.log('create.Cell fired');
          //console.log(results);
          const newCell = results.cell;
          const newCellIndex = results.index;
          let newCellId;
          if (utils.getMetadataCellId(newCell.metadata) === undefined) { 
            // Do not assign a graffiti id if we already have one. This may happen when applyCellListToNotebook is reinserting cells from the history
            // and has set the new cell's id to the value of a historical cell's id.
            newCellId = utils.setMetadataCellId(newCell.metadata,utils.generateUniqueId());
          } else {
            newCellId = utils.getMetadataCellId(newCell.metadata);
          }
          utils.refreshCellMaps();
          graffiti.addCMEventsToSingleCell(newCell);
          state.storeCellAddition(newCellId, newCellIndex);
          state.storeHistoryRecord('contents');
        });

        Jupyter.notebook.events.on('delete.Cell', (e,results) => {
          utils.refreshCellMaps();
          const deletedCell = results.cell;
          if (deletedCell !== undefined) {
            const deletedCellId = utils.getMetadataCellId(deletedCell.metadata);
            if (deletedCellId !== undefined) {
              graffiti.removeCanvasRecordsForCell(deletedCellId);              
              terminalLib.removeTerminal(deletedCellId);
            }
          }
          state.storeHistoryRecord('contents');
        });

        Jupyter.notebook.events.on('finished_execute.CodeCell', (e, results) => {
          //console.log('Graffiti: Finished execution event fired, e, results:',e, results);
          utils.refreshCellMaps();
          state.storeHistoryRecord('contents');
          graffiti.resizeCanvases();
          graffiti.redrawAllDrawingsWhenRecording(); // need to do this because resizeCanvases erases all canvases
        });

        // Because we get this event when output is sent but before it's rendered into the dom, we set up to collect
        // the output on the next tick rather than this loop.
        Jupyter.notebook.events.on('set_dirty.Notebook', (e, results) => {
          // console.log('Graffiti: set_dirty.Notebook, e, results:',e, results);
          utils.refreshCellMaps();
          graffiti.runOnceOnNextRecordingTick = () => {
            state.storeHistoryRecord('contents');
          };
        });

        
        Jupyter.notebook.events.on('rendered.MarkdownCell', (e, results) => {
          const activity = state.getActivity();
          if ((activity === 'graffiting') &&
              (utils.getMetadataCellId(results.cell.metadata) === state.getGraffitiEditCellId())) {
            // When creating Graffitis for markdown cells, the user can also save the Graffiti by rendering the target
            // markdown cell rather than the editing cell. Some content creators get confused and do this, so we support it.
            const lastEditActivityTime = state.getLastEditActivityTime();
            if (lastEditActivityTime !== undefined && utils.getNow() - lastEditActivityTime > 250) {
              console.log('Graffiti: rendered MarkdownCell event fired and editing with long enough delay, so finishing graffiti. e, results:',e, results);
              graffiti.finishGraffiti(true);
              state.clearLastEditActivityTime();
            }
          }
          graffiti.refreshAllGraffitiHighlights();
        });

        Jupyter.notebook.events.on('shell_reply.Kernel', (e, results) => {
          // console.log('Graffiti: Kernel shell reply event fired, e, results:',e, results);
          utils.refreshCellMaps();
          const activity = state.getActivity();
          if (activity === 'idle') {
            graffiti.updateAllGraffitiDisplays();
            graffiti.updateControlPanels(); // necessary because we just finished a save
          }
        });

      },

      //
      // End a movie recording currently underway.
      //
      stopRecordingCore: (useCallback) => {
        audio.setExecuteCallback(useCallback);
        graffiti.clearCanvases('all');
        graffiti.hideDrawingScreen();
        graffiti.resetDrawingColor();
        state.storeTerminalsContentsInHistory();
        state.setSpeakingStatus(false); // if we were still speaking, record a history record that will terminate that state during playback.
        state.finalizeHistory();
        if (useCallback) {
          state.dumpHistory();
        }
        state.clearAnimationIntervals();

        // This will use the callback defined in setAudioStorageCallback to actually persist the
        // whole recording, if useCallback (passed in to this fn) is true.
        audio.stopRecording();
        console.log('Graffiti: stopRecordingCore is refreshing.');
        state.restoreCellStates('contents');
        graffiti.updateAllGraffitiDisplays();
        graffiti.wipeAllStickerDomCanvases();
        graffiti.resetStickerCanvases();
        graffiti.deactivateAllPens();
        graffiti.removeCellsAddedByPlaybackOrRecording();
        graffiti.hideLabelInputBoxes();
        state.restoreCellStates('selections');
        state.restoreLineNumbersStates();
        graffiti.sitePanel.animate({ scrollTop: graffiti.preRecordingScrollTop }, 750);
        graffiti.selectIntersectingGraffitiRange();
        state.deleteTrackingArrays();
        state.clearDisplayedTipInfo();
        terminalLib.saveOrRestoreTerminalOutputs('restore');
        graffiti.changeActivity('idle');
      },

      cancelRecording: () => {
        const currentActivity = state.getActivity();
        console.log('Graffiti: canceling recording, current activity:', currentActivity);
        if (currentActivity === 'recording') {
          const recordingCellInfo = state.getRecordingCellInfo();
          if (recordingCellInfo.newRecording) {
            graffiti.removeGraffiti(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey);
          } else if (graffiti.previousActiveTakeId !== undefined) {
            storage.updateSingleManifestRecordingField(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey,
                                                       'activeTakeId', graffiti.previousActiveTakeId);
          }
          graffiti.stopRecordingCore(false);
        }
      },

      toggleRecording: (opts) => {
        const currentActivity = state.getActivity();
        if (currentActivity !== 'playing') {
          if (currentActivity === 'recording') {

            //
            // End movie recording.
            //

            console.log('Graffiti: Now ending movie recording');
            state.blockRecording(); // this is here because a race condition can happen right at the end of recording
            graffiti.setNotifier(localizer.getString('PLEASE_WAIT_STORING_MOVIE'));
            graffiti.showControlPanels(['graffiti-notifier']);
            graffiti.showSavingScrim();
            storage.setMovieCompleteCallback(graffiti.hideSavingScrim);
            graffiti.stopRecordingCore(true);
            state.unblockRecording();
            graffiti.clearJupyterMenuHint();
            if (opts !== undefined && opts.endByKeyPress) {
              state.addCancelTimeSkipRecord();
            }
            state.stopSkipping();
            console.log('Graffiti: Stopped recording.');
          } else {

            //
            // Start new movie recording.
            //

            const recordingCellInfo = state.getRecordingCellInfo();
            if (recordingCellInfo === undefined) {
              // Error condition, cannot start recording without an active cell
              console.log('Graffiti: Cannot begin recording, no cell chosen to store recording.');
              return;
            }
            console.log('Graffiti: Begin recording for cell id:', recordingCellInfo.recordingCellId);

            terminalLib.saveOrRestoreTerminalOutputs('save');
            state.resetPlayState();
            graffiti.changeActivity('recording');
            graffiti.clearSkipKeyDownTimer();
            utils.assignCellIds();
            state.initHistory({
              storageCellId: recordingCellInfo.recordingCellId,
            });
            state.clearCellAdditions();

            audio.startRecording();
            state.setScrollTop(graffiti.sitePanel.scrollTop());
            state.updateDrawingState([ { change: 'drawingModeActivated', data: false },
                                       { change: 'drawingActivity', data: 'idle' },
                                       { change: 'penType', data: undefined },
                                       { change: 'opacity', data: state.getMaxDrawingOpacity() } ]);
            graffiti.resetDrawingPen();
            state.disableDrawingFadeClock(); // initially, we don't fade since nothing drawn yet

            state.startAnimationInterval('recording',
                                         () => {
                                           //console.log('Moving recording time ahead');
                                           if (graffiti.runOnceOnNextRecordingTick !== undefined) {
                                             graffiti.runOnceOnNextRecordingTick();
                                             graffiti.runOnceOnNextRecordingTick = undefined;
                                           }
                                           graffiti.updateTimeDisplay(state.getTimeRecordedSoFar());
                                           graffiti.updateDrawingOpacity();
                                         },
                                         graffiti.recordingIntervalMs);

            // Flash a red recording bullet while recording is ongoing, every second. 
            state.startAnimationInterval('recordingIndicator',
                                         () => {
                                           if (state.isSkipping()) {
                                             $('#graffiti-recording-flash-icon').css({background:'rgb(255,0,0)'});
                                           } else {
                                             if (state.getTimeRecordedSoFar() % 2000 > 1000) {
                                               $('#graffiti-recording-flash-icon').css({background:'rgb(245,245,245)'});
                                             } else {
                                               $('#graffiti-recording-flash-icon').css({background:'rgb(255,0,0)'});
                                             }
                                           }
                                         },
                                         graffiti.recordingIntervalMs);
            
            console.log('Graffiti: Started recording');
          }
        }
      },

      endRecordingByKeyPress: () => {
        const activity = state.getActivity();
        if (activity === 'recording') {
          graffiti.toggleRecording({endByKeyPress:true});
        } else if (activity === 'recordingPending') {
          graffiti.changeActivity('idle');
          graffiti.clearJupyterMenuHint();
        }
      },

      changeActivity: (newActivity) => {
        if (state.getActivity() === newActivity) {
          console.log('Graffiti: state is already :', newActivity, 'not changing it');
          return; // no change to activity
        }
        state.setActivity(newActivity);
        graffiti.updateControlPanels();
      },

      //
      // Movie playback code begins
      //

      resetScrollNudge: () => {
        graffiti.scrollNudge = undefined;
      },

      applyScrollNudge: (position, record, useTrailingVelocity) => {
        //console.log('applyScrollNudge, useTrailingVelocity:', useTrailingVelocity);
        const clientHeight = document.documentElement.clientHeight;
        const topbarHeight = $('#header').height();
        //const bufferY = clientHeight / 9;
        const bufferY = clientHeight / 6;
        const minAllowedCursorY = topbarHeight + bufferY;
        const maxAverageVelocity = 0.5;
        const minBottomBufferY = 150; // approximately 1.5x the height of bottom bar in udacity classroom
        const maxAllowedCursorY = clientHeight - Math.max(bufferY, minBottomBufferY);
        let mustNudgeCheck = !useTrailingVelocity;
        let nudgeIncrements = graffiti.scrollNudgeQuickIncrements;
        
        // Watch trailing average of cursor. If the average over twenty samples is in a nudge zone, then nudge
        if (useTrailingVelocity) {
          nudgeIncrements = ((state.getActivity === 'scrubbing') ? 1.0 : graffiti.scrollNudgeSmoothIncrements);
          //const trailingAverageSize = 85;
          const trailingAverageSize = 10;
          if (graffiti.scrollNudgeAverages.length > 0) {
            if (((graffiti.scrollNudgeAverages[graffiti.scrollNudgeAverages.length-1].x === position.x) &&
                 (graffiti.scrollNudgeAverages[graffiti.scrollNudgeAverages.length-1].y === position.y)) ||
                (graffiti.scrollNudgeAverages[graffiti.scrollNudgeAverages.length-1].t === record.startTime)) {
              return; // cursor didn't move or time didn't change, dont record velocity
            }
          }
          if (record.inTopBarArea !== undefined && record.inTopBarArea) {
            //console.log('Ignoring cursor activity recorded above the site panel');
            return; // ignore the cursor when it is above the site panel
          }
          graffiti.scrollNudgeAverages.push({t:record.startTime, pos: { x: position.x, y: position.y }});
          if (graffiti.scrollNudgeAverages.length > trailingAverageSize) {
            graffiti.scrollNudgeAverages.shift();
            let velocities = [], distance, timeDiff;
            for (let i = 1; i < graffiti.scrollNudgeAverages.length; ++i) {
              // This is highly mathematically inefficient but maybe in this scale of things, it's ok.
              distance =
                Math.sqrt(
                  Math.pow((graffiti.scrollNudgeAverages[i].pos.y - graffiti.scrollNudgeAverages[i-1].pos.y),2) +
                  Math.pow((graffiti.scrollNudgeAverages[i].pos.x - graffiti.scrollNudgeAverages[i-1].pos.x),2) );
              timeDiff = graffiti.scrollNudgeAverages[i].t - graffiti.scrollNudgeAverages[i-1].t;
              velocities.push(distance / timeDiff );
            }
            const averageVelocity = Math.abs(utils.computeArrayAverage(velocities));
            //console.log('averageVelocity:', averageVelocity);
            mustNudgeCheck = mustNudgeCheck || (averageVelocity < maxAverageVelocity);
          }
        }

        // console.log('averageVelocity:', averageVelocity, velocities, graffiti.scrollNudgeAverages);
        if (mustNudgeCheck) {
          // If we are scrubbing, do not nudge but immediately push the correct spot into view by setting the increment divider to 1 so we jump the 
          // full amount all at once.
          let nudging = false, nudgeAmount;
          if (position.y < minAllowedCursorY) {
            nudgeAmount = (position.y - minAllowedCursorY) / nudgeIncrements;
            nudging = true;
          } else if (position.y > maxAllowedCursorY) {
            nudgeAmount = (position.y - maxAllowedCursorY) / nudgeIncrements;
            nudging = true;
          }
          if (nudging) {
            /*
               console.log('Graffiti: nudgeAmount', nudgeAmount, 'position', position.x, position.y,
               'minAllowedCursorY',minAllowedCursorY, 'maxAllowedCursorY', maxAllowedCursorY, 
               'nudgeIncrements', nudgeIncrements, 'bufferY', bufferY, 'useTrailingVelocity', useTrailingVelocity);
             */
            graffiti.scrollNudge = { 
              counter: nudgeIncrements,
              amount: nudgeAmount
            };
            //console.log('nudging:', graffiti.scrollNudge.amount);
          } else {
            //console.log('not nudging, y', position.y, 'maxY', maxAllowedCursorY);
          }
        }
      },

      applyScrollNudgeAtCell: (cell, record, selChange) => {
        const cellId = utils.getMetadataCellId(cell.metadata);
        const cellRects = utils.getCellRects(cell);
        let selectionRecord, selections;
        if (record.cellsSelections !== undefined) {
          selectionRecord = record.cellsSelections[cellId];
        }
        if (selectionRecord !== undefined) {
          selections = selectionRecord.selections;
        } else {
          const code_mirror = cell.code_mirror;
          selections = code_mirror.listSelections();
        }

        if (selections.length !== 0) {
          const cellOffsetY = selections[0].head.line * (graffiti.cmLineHeight + graffiti.cmLineFudge);
          const offsetPosition = {
            x: cellRects.innerCellRect.left, 
            y: cellOffsetY + cellRects.innerCellRect.top
          }
          //console.log('applyScrollNudgeAtCell:offsetPosition:', offsetPosition, 'cellId', cellId, 'selChange', selChange);
          graffiti.applyScrollNudge(offsetPosition, record, false);
        }
      },

      calculateMappedScrollDiff: (record) => {
        const currentNotebookPanelHeight = graffiti.notebookPanel.height();
        let mappedScrollDiff = 0;
        if (record !== undefined) {          
          mappedScrollDiff = (record.scrollDiff / record.notebookPanelHeight) * currentNotebookPanelHeight;
        }
        return mappedScrollDiff;
      },

      doScrollNudging: (record, viewIndex) => {
        const currentScrollTop = graffiti.sitePanel.scrollTop();
        let newScrollTop = currentScrollTop;
        mappedScrollDiff = graffiti.calculateMappedScrollDiff(record);
        if (graffiti.scrollNudge !== undefined) {
          // console.log('updateDisplay, nudgeAmount:', graffiti.scrollNudge.amount, 'counter:', graffiti.scrollNudge.counter);
          let scrollNudgeAmount = 0;
          graffiti.scrollNudge.counter--;
          if (graffiti.scrollNudge.counter > 0) {
            scrollNudgeAmount = graffiti.scrollNudge.amount;
            //console.log('Going to nudge scroll by:', scrollNudgeAmount, 'counter:', graffiti.scrollNudge.counter);
            newScrollTop = currentScrollTop + scrollNudgeAmount;
          } else {
            graffiti.resetScrollNudge(); // stop nudging
          }
        }
        // Only apply a user-recorded scroll diff if we haven't applied it already. When this function is called with no parameters, then
        // it is only doing "maintenance nudging", ie over-time nudging to keep the most important zones of interest in the viewport.
        // console.log('Now applying mappedScrollDiff:', mappedScrollDiff);
        const skipMappedScrollDiff = (viewIndex !== undefined) &&
                                      (graffiti.lastScrollViewId !== undefined && graffiti.lastScrollViewId === viewIndex);
        //console.log('skipMappedScrollDiff', skipMappedScrollDiff);
        if (!skipMappedScrollDiff) {
          newScrollTop += mappedScrollDiff;
          graffiti.lastScrollViewId = viewIndex;
        }

        graffiti.setSitePanelScrollTop(newScrollTop);
      },

      updateDrawingCore: (record) => {
        //console.log('updateDrawingCore:', record);
        record.hoverCell = utils.findCellByCellId(record.cellId);

        switch (record.drawingActivity) {
          case 'draw':
            graffiti.placeCanvas(record.cellId, record.pen.permanence);
            graffiti.setCanvasStyle(record.cellId, record.pen.type, record.pen.dash, record.pen.color, record.pen.permanence);
            // console.log('inPromptArea:', record.pen.inPromptArea, 'downInMarkdown:', record.pen.downInMarkdown );
            const positions = graffiti.processPositionsForCellTypeScaling(record, 'positions');
            graffiti.updateDrawingDisplay(record.cellId, 
                                          positions.start.x, 
                                          positions.start.y,
                                          positions.end.x, 
                                          positions.end.y,
                                          record.pen.type,
                                          record.pen.permanence);
            break;
          case 'sticker':
            graffiti.drawStickersForCell(record.cellId, record);
            break;
          case 'fade':
            $('.graffiti-canvas-type-temporary').css({opacity: record.opacity });
            break;
          case 'wipe':
            console.log('Graffiti: wiping temporary sticker canvas');
            graffiti.wipeTemporaryStickerDomCanvases();
            graffiti.clearCanvases('temporary');            
            break;
        }
      },

      updateDrawings: (drawingFrameIndex) => {
        if (drawingFrameIndex === undefined) {
          return; // no drawings yet at this index
        }

        // console.log('updateDrawings');
        // Need to process a range of records if that's required.
        const startIndex = ((drawingFrameIndex.rangeStart === undefined) ? drawingFrameIndex.index : drawingFrameIndex.rangeStart);
        const endIndex = drawingFrameIndex.index;
        let index, record;
        for (index = startIndex; index <= endIndex; ++index) {
          record = state.getHistoryItem('drawings', index);
          graffiti.updateDrawingCore(record);
        }
      },

      updatePointer: (record) => {
        if (record.hoverCell !== undefined) {
          const hoverCellId = record.cellId;
          record.isOverTerminal = false;
          const offsetPositionScaled = graffiti.processPositionsForCellTypeScaling(record, 'cursor');
          const cellRects = utils.getCellRects(record.hoverCell);        
          const offsetPosition = { x: cellRects.cellRect.left + offsetPositionScaled.start.x - graffiti.halfBullseye,
                                   y: cellRects.cellRect.top + offsetPositionScaled.start.y - graffiti.halfBullseye
          };
          const isOverTerminalCell = terminalLib.isTerminalCell(hoverCellId);
          if (isOverTerminalCell) {
            const hoverCellElement = record.hoverCell.element[0];
            const terminalContainer = $(hoverCellElement).find('.graffiti-terminal-container');
            const termWidth = terminalContainer.width();
            const termHeight = terminalContainer.height();
            const termOffset = terminalContainer.offset();
            record.isOverTerminal = ((termOffset.left <= offsetPosition.x) && (offsetPosition.x <= termOffset.left + termWidth) &&
                                     (termOffset.top  <= offsetPosition.y) && (offsetPosition.y <= termOffset.top + termHeight));
          }
          graffiti.applyScrollNudge(offsetPosition, record, true);

          const lastPosition = state.getLastRecordedCursorPosition();
          if ((offsetPosition.x !== lastPosition.x) || (offsetPosition.y !== lastPosition.y)) {
            // Show cursor whenever it's moved by user
            //console.log('Showing cursor:', offsetPosition, lastPosition);
            graffiti.undimGraffitiCursor();
            const offsetPositionPx = { left: offsetPosition.x + 'px', top: offsetPosition.y + 'px'};
            graffiti.graffitiCursorShell.css(offsetPositionPx);
            if (record.isOverTerminal) {
              graffiti.activateTerminalGraffitiCursor();
            } else {
              graffiti.activateNormalGraffitiCursor();
            }
          }            
          state.setLastRecordedCursorPosition(offsetPosition);
        }
      },

      updateView: (viewIndex, currentScrollTop) => {
        //console.log('updateView, viewIndex:', viewIndex);
        let record = state.getHistoryItem('view', viewIndex);
        record.hoverCell = utils.findCellByCellId(record.cellId);

        // Make sure the hoverCell shows line numbers if they were visible during recording; otherwise all registration will be off
        // by the width of the line number gutter.
        if (record.hoverCell !== undefined) { // make sure we were actually hovering over a cell before we try to tweak the gutter.
          if (record.hasOwnProperty('lineNumbersVisible')) { // some early recordings won't have this property
            const cm = record.hoverCell.code_mirror;
            const currentlyVisible = cm.options.lineNumbers;
            if (record.lineNumbersVisible != cm.options.lineNumbers) {
              record.hoverCell.toggle_line_numbers();
            }
          }
        }

        // Select whatever cell is currently selected
        if (record.selectedCellId !== undefined) {
          const selectedCellIndex = utils.findCellIndexByCellId(record.selectedCellId); // we should use a map to speed this up
          //console.log('about to select index:', selectedCellIndex, record.selectedCellId)
          Jupyter.notebook.select(selectedCellIndex);
        }

        // Handle pointer updates and canvas updates, as well as cell focus changes
        if (record.subType === 'pointer') {
          //console.log('pointerUpdate is true, record:', record);
          graffiti.updatePointer(record);
        } else {
          graffiti.dimGraffitiCursor();
          if (record.selectedCell !== undefined) {
            if ((record.subType === 'focus') || (record.subType === 'selectCell')) {
              //console.log('processing focus/selectCell, record:', record);
              const selectedCell = utils.findCellByCellId(record.selectedCellId);
              if (selectedCell !== undefined) {
                if (utils.getMetadataCellId(record.selectedCell.metadata) === utils.getMetadataCellId(record.hoverCell.metadata)) {
                  selectedCell.focus_cell();
                  if (record.subType === 'focus') {
                    const code_mirror = selectedCell.code_mirror;
                    if (!code_mirror.state.focused) {
                      code_mirror.focus();
                    }
                    code_mirror.getInputField().focus();
                  }
                }
              }
            }
          }
        }

        graffiti.setSitePanelScrollTop(currentScrollTop); // restore scrollTop because changing selections messes with it

        if (record.hoverCell !== undefined) {
          const cm = record.hoverCell.code_mirror;
          // Update innerScroll if required
          cm.scrollTo(record.innerScroll.left, record.innerScroll.top);
          //console.log('updateView is calling doScrollNudging');
          graffiti.doScrollNudging(record, viewIndex);
          //console.log('after doScrollNudging, we have new scrollTop:', graffiti.sitePanel.scrollTop());
        }
      },

      updateCellSelections: (cell,cm, selections, currentScrollTop) => {
        //console.log('updateCellSelections', selections);
        cm.setSelections(selections);
        graffiti.setSitePanelScrollTop(currentScrollTop); // preserve scrollTop because changing selections messes with it (safety check)
        utils.refreshCodeMirrorSelection(cell);
        graffiti.setSitePanelScrollTop(currentScrollTop); // preserve scrollTop because changing selections messes with it (safety check)
      },

      updateSelectedCellSelections: (currentScrollTop) => {
        const selectedCell = Jupyter.notebook.get_selected_cell();
        utils.refreshCodeMirrorSelection(selectedCell);
        graffiti.setSitePanelScrollTop(currentScrollTop);
      },

      updateSelections: (index,currentScrollTop) => { 
        const record = state.getHistoryItem('selections', index);
        let cellId, cell, selectionRecord, selections, code_mirror, currentSelections, active, lineCheck;

        // If there were text selections in rendered markdown or rendered output during this frame, restore them first if we need to.
        if (record.textSelection !== undefined) {
          const cellId = record.textSelection.cellId;
          const cell = utils.findCellByCellId(cellId);
          let referenceNode;
          if (cell !== undefined) {
            const cellType = cell.cell_type;
            // find the right reference node so we can highlight the correct text in either a markdown cell or a code cell output area
            if (cellType === 'markdown') {
              referenceNode = $(cell.element).find('.rendered_html')[0];
            } else {
              referenceNode = $(cell.element).find('.output_subarea')[0];
            }
            const currentSelection = selectionSerializer.get(referenceNode);
            if (!(_.isEqual(currentSelection.state, record.textSelection.state))) {
              if (cellType === 'markdown') {
                // console.log('Graffiti: Focusing on markdown cell');
                cell.focus_cell();
                // we don't need to shrink if we focus the cell
                graffiti.setSitePanelScrollTop(currentScrollTop); // restore scrollTop because changing selections messes with it
              }
              // console.log('Graffiti: Selection restoring textSelection, currentSelection:', record.textSelection, currentSelection);
              record.textSelection.referenceNode = referenceNode;
              selectionSerializer.restore(record.textSelection);
            }
          }
        } else {
          for (cellId of Object.keys(record.cellsSelections)) {
            selectionRecord = record.cellsSelections[cellId];
            selections = selectionRecord.selections;
            if (selectionRecord.active) {
              const selectedCellIndex = utils.findCellIndexByCellId(cellId);
              if (Jupyter.notebook.get_selected_index() !== selectedCellIndex) {
                Jupyter.notebook.select(selectedCellIndex);
                graffiti.setSitePanelScrollTop(currentScrollTop); // restore scrollTop because changing selections messes with it
              }
            }
            cell = utils.findCellByCellId(cellId);
            if (cell !== undefined) {
              code_mirror = cell.code_mirror;
              currentSelections = utils.cleanSelectionRecords(code_mirror.listSelections());
              //console.log('cellId, selections, currentSelections, subType:', cellId, selections, currentSelections, record.subType);
              const numLines = code_mirror.lineCount();
              // Make sure the recorded selection point does not exceed the size of the current cm's text, 
              // before checking for whether we need to set the selection.
              selections[0].anchor.line = Math.min(numLines - 1, selections[0].anchor.line);
              lineCheck = code_mirror.getLine(selections[0].anchor.line);
              selections[0].anchor.ch = Math.min(lineCheck.length, selections[0].anchor.ch);
              selections[0].head.line = Math.min(numLines - 1, selections[0].head.line);
              lineCheck = code_mirror.getLine(selections[0].head.line);
              selections[0].head.ch = Math.min(lineCheck.length, selections[0].head.ch);

              if (!(_.isEqual(selections,currentSelections))) {
                graffiti.dimGraffitiCursor();

                graffiti.updateCellSelections(cell,code_mirror, selections, currentScrollTop);

                //console.log('nudge check, cellId', cellId, 'code_mirror.state.focused',code_mirror.state.focused);
                setTimeout(() => {
                  if (code_mirror.state.focused) {
                    // If we made a selections update this frame, AND we are focused in it,
                    // make sure that we keep it in view. We need to compute the
                    // offset position of the *head* of the selection where the action is.
                    // NOTE: the setTimeout is needed because codemirror seems to do selections and focus async so we may end
                    // up applying scrollnudging to the cell too early, ie nudge to a cell that is not visible.
                    // console.log('setting selections with selections:', selections);
                    graffiti.applyScrollNudgeAtCell(cell, record, true);
                  }
                }, 0);
              }
            }
          }
        }
      },

      // After playback finishes, delete any cells added during playback.
      removeCellsAddedByPlaybackOrRecording: () => {
        const cellAdditions = state.getCellAdditions(); // all cells added during this recording
        if (cellAdditions !== undefined) {
          let deleteCellIndex;
          for (let cellId of cellAdditions) {
            deleteCellIndex = utils.findCellIndexByCellId(cellId);
            if (deleteCellIndex !== undefined) {
              //console.log('Going to delete:', cellId, 'at index:', deleteCellIndex);
              Jupyter.notebook.delete_cell(deleteCellIndex);
              utils.refreshCellMaps();
            }
          }
        }
      },

      // At any timeframe add cells that were present during recording but aren't now, and remove any that were added by playback/scrub
      // but aren't present at this timeframe.
      applyCellListToNotebook: (record) => {
        const cellsPresentThisFrame = record.cellsPresentThisFrame;
        const fullCellsPresentIds = Object.keys(cellsPresentThisFrame);
        // During playback, only add back cells that were actually interacted with, unless replayAll directive was set to be on.
        const cellsPresentIds = fullCellsPresentIds.filter( cellId => state.graffitiShouldUpdateCellContents(cellId));
        const numCellsPresent = cellsPresentIds.length;
        let mustRefreshCellMaps = false;
        let deletableCellId;
        if (numCellsPresent > 0) {
          // First figure out which cells are extra and need to be deleted on this cell
          let deleteCellId, deleteCellIndex;
          const cellAdditions = state.getCellAdditions(); // all cells added during this recording
          const cellAdditionsIds = Object.values(cellAdditions);
          // Any cells that may have been added during the movie, not present in this timeframe, must be deleted.
          const deletableCellIds = _.difference(cellAdditionsIds, cellsPresentIds); 
          //console.log('deletableCellIds', deletableCellIds, cellAdditions, cellsPresentIds);
          for (deletableCellId of deletableCellIds) {
            // console.log('Graffiti: Trying to delete cellid:', deletableCellId);
            deleteCellIndex = utils.findCellIndexByCellId(deletableCellId);
            if (deleteCellIndex !== undefined) {
              //console.log('Going to delete:', deleteCellId, 'at index:', deleteCellIndex);
              Jupyter.notebook.delete_cell(deleteCellIndex);
            }
          }

          // Now figure out which cells are missing and need to be added in. Add them in above whatever position 
          // they were recorded in, or right after the last present cell (whichever is greater), to try to match
          // its position from the recording time. This works ok because usually content creators will add a 
          // cell after another specific cell.
          let i, checkCellId, foundCell, newCell, cellPosition, previousCellPosition, previousPlusOne;
          for (i = 0; i < cellsPresentIds.length; ++i) {
            checkCellId = cellsPresentIds[i];
            foundCell = utils.findCellByCellId(checkCellId);
            if (foundCell === undefined) {
              cellPosition = cellsPresentThisFrame[checkCellId];
              if (i > 0) {
                previousCellPosition = utils.findCellIndexByCellId(cellsPresentIds[i - 1]);
                if (previousCellPosition !== undefined) {
                  previousPlusOne = previousCellPosition + 1;
                  if (previousPlusOne > cellPosition) {
                    cellPosition = previousPlusOne;
                  }
                }
              }              
              const cells = Jupyter.notebook.get_cells();
              cellPosition = Math.min(cellPosition, cells.length - 1);
              newCell = Jupyter.notebook.insert_cell_above('code', cellPosition);
              utils.setMetadataCellId(newCell.metadata, checkCellId);
              state.storePlaybackCellAddition(checkCellId, cellPosition);
              mustRefreshCellMaps = true;
              // console.log('Graffiti: Just inserted new cell, cellId:', checkCellId, 'at position', cellPosition);
              // This causes excessive scrolling and isn't really necessary if the author moves the cursor to a new cell anyway
              // graffiti.applyScrollNudgeAtCell(newCell, record, false);
            }
          }
        }
        if (mustRefreshCellMaps) {
          utils.refreshCellMaps();
        }
      },

      // set_text() causes jupyter to scroll to top of cell so we need to restore scrollTop after calling this fn, on a timeout, cf 
      // https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful/779785#779785
      updateContents: (index, currentScrollTop) => {
        const contentsRecord = state.getHistoryItem('contents', index);
        const cells = Jupyter.notebook.get_cells();
        let cellId, contents, outputs, frameContents, frameOutputs, renderedFrameOutput = false;
        graffiti.applyCellListToNotebook(contentsRecord);
        for (let cell of cells) {
          if (cell.cell_type === 'code') {
            cellId = utils.getMetadataCellId(cell.metadata);
            if (state.graffitiShouldUpdateCellContents(cellId)) {
              contents = cell.get_text();
              if (contentsRecord.cellsContent.hasOwnProperty(cellId)) {
                frameContents = state.extractDataFromContentRecord(contentsRecord.cellsContent[cellId].contentsRecord, cellId);
                if (frameContents !== undefined && frameContents !== contents) {
                  //console.log('Setting text on cellid:', utils.getMetadataCellId(cell.metadata));
                  cell.set_text(frameContents);
                }
                frameOutputs = state.extractDataFromContentRecord(contentsRecord.cellsContent[cellId].outputsRecord, cellId);
                renderedFrameOutput = renderedFrameOutput || state.restoreCellOutputs(cell, frameOutputs);
              }
            }
          }
        }
        if (renderedFrameOutput) {
          graffiti.resizeCanvases();
          graffiti.redrawAllDrawings();
          setTimeout(() => {
            // For some reason we have to restore scrollTop on timeout because CM's setValue() fn seems to move scrollTop, async.
            graffiti.setSitePanelScrollTop(currentScrollTop); 
          }, 100);
        }
      },

      updateTerminals: (index) => {
        const record = state.getHistoryItem('terminals', index);
        const termRecords = record.terminals;
        let focusedTerminal = undefined;
        if (termRecords !== undefined) {
          const terminalsContents = state.getHistoryTerminalsContents();
          const currentMovie = state.getCurrentlyPlayingMovie();
          const nearestCellPosition = currentMovie.cellIndex;
          for (let i = 0; i < termRecords.length; ++i) {
            terminalLib.setTerminalContents($.extend(true, termRecords[i], { 
              incremental: (state.getActivity() === 'playing'), 
              terminalsContents: terminalsContents,
              nearestCellPosition: nearestCellPosition,
              useNearestCellPosition: true, // try to dump output into nearest terminal you find
            }));

            if (termRecords[i].isFocused) {
              focusedTerminal = termRecords[i].id;
            }
          }
        }
        terminalLib.focusTerminal(focusedTerminal);        
      },

      updateSpeaking: (index) => {
        const record = state.getHistoryItem('speaking', index);
        //console.log('Processing speaking record', index, record);
        if (state.scanningIsOn()) {
          if (record.speaking) {
            // console.log('Graffiti: Begun speaking.');
            state.setCurrentPlaySpeed('scanInactive');
            state.setSpeakingStatus(true);
          } else {
            // console.log('Graffiti: Stopped speaking.');
            state.setCurrentPlaySpeed('scanActive');
            state.setSpeakingStatus(false);
          }
//          console.log('playTimes:regular', state.playTimes['regular'].total,
//                      'scanActive:',  state.playTimes['scanActive'].total, 
//                      'scanInactive', state.playTimes['scanInactive'].total);
          audio.updateAudioPlaybackRate();
        }
      },

      updateDisplay: (frameIndexes) => {
        const currentScrollTop = graffiti.sitePanel.scrollTop();
        const activity = state.getActivity();
        if (state.shouldUpdateDisplay('contents', frameIndexes.contents)) {
          graffiti.updateContents(frameIndexes.contents.index, currentScrollTop);
          //console.log('update contents:', 'currentScrollTop', currentScrollTop, 'new scrollTop', graffiti.sitePanel.scrollTop());
        }
        if (state.shouldUpdateDisplay('selections', frameIndexes.selections)) {
          graffiti.updateSelections(frameIndexes.selections.index, currentScrollTop);
          //console.log('update selections:', 'currentScrollTop', currentScrollTop, 'new scrollTop', graffiti.sitePanel.scrollTop());
        }
        if (state.shouldUpdateDisplay('drawings', frameIndexes.drawings)) {
          if (activity !== 'scrubbing') {
            //console.log('calling updateDrawings from updateDisplay');
            graffiti.updateDrawings(frameIndexes.drawings);
          }
        }
        if (state.shouldUpdateDisplay('terminals', frameIndexes.terminals)) {
          graffiti.updateTerminals(frameIndexes.terminals.index);
        }
        if (state.shouldUpdateDisplay('speaking', frameIndexes.speaking)) {
          //console.log(state.history.processed);
          graffiti.updateSpeaking(frameIndexes.speaking.index);
        }
        if (state.shouldUpdateDisplay('view', frameIndexes.view)) {
          graffiti.updateView(frameIndexes.view.index, currentScrollTop);
          //console.log('update view:', frameIndexes.view.index, 'currentScrollTop', currentScrollTop, 'new scrollTop', graffiti.sitePanel.scrollTop());
        }

      },

      // update the timer display for play or recording
      updateTimeDisplay: (playedSoFar) => {
        let totalTimeDisplay = localizer.getString('IS_SKIPPING');
        const activity = state.getActivity();
        if (!state.isSkipping()) {
          let timeSkippedSoFar = state.getSkippedTimeSoFar();
          if (isNaN(timeSkippedSoFar)) {
            timeSkippedSoFar = graffiti.lastTimeSkippedSoFar;
          }
          graffiti.lastTimeSkippedSoFar = timeSkippedSoFar;
          //const playTimeDisplay = utils.formatTime(playedSoFar  - timeSkippedSoFar, { includeMillis: false });
          const playTimeDisplay = utils.formatTime(playedSoFar, { includeMillis: false });
          const recordingTimeDisplay = utils.formatTime(playedSoFar, { includeMillis: true }) ;
          const totalSkipTimeForRecording = state.getTotalSkipTimeForRecording();
          //console.log('totalSkipTimeForRecording', totalSkipTimeForRecording);
          // work in progress
          //const durationDisplay = utils.formatTime(state.getHistoryDuration() - totalSkipTimeForRecording, { includeMillis: false });
          const durationDisplay = utils.formatTime(state.getHistoryDuration(), { includeMillis: false });
          if (activity === 'recording') {
            totalTimeDisplay = recordingTimeDisplay;
          } else {
            totalTimeDisplay = playTimeDisplay + '/' + durationDisplay;
          }
        }
        const recorderTimeElem = (activity === 'recording' ? $('#graffiti-time-display-recording') : $('#graffiti-time-display-playback'));
        recorderTimeElem.text(totalTimeDisplay);
      },

      updateSlider: (playedSoFar) => {
        const ratio = playedSoFar / state.getHistoryDuration();
        const sliderVal = ratio * 1000;
        //console.log('updateSlider, playedSoFar:', playedSoFar, 'sliderVal:', sliderVal);
        const slider = $('#graffiti-recorder-range');
        slider.val(sliderVal);
      },

      //
      // Playback functions
      //

      // When jumping around, or if we reached the end of playback and the next playback will reset to beginning, then we may need to attempt to recalculate 
      // and apply the raw scrollTop (excluding any nudging, so it's approximate).
      applyRawCalculatedScrollTop: (viewIndex) => {
        let record, i, calculatedScrollTop = graffiti.prePlaybackScrolltop;
        for (i = 0; i < viewIndex; ++i) {
          record = state.getHistoryItem('view', i);
          calculatedScrollTop += graffiti.calculateMappedScrollDiff(record);
        }
        graffiti.sitePanel.scrollTop(calculatedScrollTop);
      },

      // Skip around by X seconds forward or back.
      jumpPlayback: (direction, jumpAmount) => {
        const previousPlayState = state.getActivity();
        graffiti.pausePlayback();
        const timeElapsed = state.getTimePlayedSoFar();
        //console.log('jumpPlayback timeElapsed',timeElapsed);
        let t;
        if (state.scanningIsOn()) {
          t = state.findSpeakingStartNearestTime(timeElapsed,direction, jumpAmount);
        } else {
          t = Math.max(0, Math.min(timeElapsed + (jumpAmount * 1000 * direction * state.getPlayRateScalar()), state.getHistoryDuration() - 2 ));
        }
        // console.log('Graffiti: t:', t);
        state.resetPlayTimes(t);
        const frameIndexes = state.getHistoryRecordsAtTime(t);
        state.clearSetupForReset();
        state.resetProcessedArrays();
        graffiti.wipeAllStickerDomCanvases();
        graffiti.updateDisplay(frameIndexes);
        graffiti.updateSlider(t);
        graffiti.updateTimeDisplay(t);
        graffiti.redrawAllDrawings(t);
        if (previousPlayState === 'playing') {
          graffiti.startPlayback();
        }
        graffiti.updateAllGraffitiDisplays();
        graffiti.applyRawCalculatedScrollTop(frameIndexes.view.index);
      },

      handleSliderDrag: () => {
        // Handle slider drag
        const target = $('#graffiti-recorder-range');
        const timeLocation = target.val() / 1000;
        //console.log('handleSliderDrag, slider value:', target.val());
        const t = Math.min(state.getHistoryDuration() * timeLocation, state.getHistoryDuration() - 1);
        // Now we need to set the time we are going to start with if we play from here.
        state.resetPlayTimes(t);
        state.updateCurrentSkipRecord();
        state.clearSetupForReset();
        state.resetProcessedArrays();
        graffiti.undimGraffitiCursor();
        const frameIndexes = state.getHistoryRecordsAtTime(t);
        graffiti.wipeAllStickerDomCanvases();
        graffiti.updateDisplay(frameIndexes); // can replay scroll diffs, and in playback use cumulative scroll diff
        graffiti.updateTimeDisplay(t);
        graffiti.redrawAllDrawings(t);
        graffiti.applyRawCalculatedScrollTop(frameIndexes.view.index);
      },

      handleTerminalsEvents: (event) => {
        if (state.getActivity() === 'recording') {
          // If we are recording, we need to record latest terminal output for replay
          // console.log('Terminal event:', event);
          state.storeTerminalsState([event]);
          state.storeHistoryRecord('terminals');
        }
      },

      // If we are inside a skip record, apply its speed or absolute skip
      applyCurrentSkipRecord: (t) => {
        const currentSkipRecord = state.timeInSkipRecordRange(t);
        const userChoicePlaySpeed = state.getUserChoicePlaySpeed();
        let didSkip = false;
        let changedSpeed = false;
        const currentActivity = state.getActivity();
        if (currentSkipRecord !== undefined) {
          if (currentSkipRecord.status !== undefined) {
            // Return early. these records are old legacy recordings with skip statuses in them. we are ignoring these in favor of specifying skip type in directives.
            return didSkip;
          }
          const skipInfo = state.getSkipInfo();
          state.setAppliedSkipRecord();
          const isLastSkipRecord = state.isLastSkipRecord();
          let duration;
          if (isLastSkipRecord) {
            console.log('Graffiti: doing last skip as absolute');
            skipInfo.type = state.skipTypes['absolute']; // last skip is overridden to always be absolute.
            // This is -1,  because we want to resume playing for last millisecond of skip so we come to a regular stop after the last skip.
            duration = state.getHistoryDuration() - state.getTimePlayedSoFar() - 1; 
          } else {
            duration = currentSkipRecord.endTime - currentSkipRecord.startTime + 1;
          }
          const durationMillis = duration / 1000;
          switch (skipInfo.type) {
            case state.skipTypes['rapid']:
              state.setPlayRate('rapid', skipInfo.factor);
              state.setCurrentPlaySpeed('rapid');
              changedSpeed = true;
              break;
            case state.skipTypes['absolute']:
              state.setCurrentPlaySpeed('regular'); // during absolute skips set play rate to regular so we don't skip too much
              graffiti.jumpPlayback(1, durationMillis);
              state.updateCurrentSkipRecord();
              state.setCurrentPlaySpeed(userChoicePlaySpeed);
              didSkip = true;
              break;
            case state.skipTypes['compressed']:
              // This is the time we're going to try to compress time into (assume user gave us seconds, not millis)
              const compressedTimeTarget = Math.min(duration, skipInfo.factor * 1000); 
              state.setCompressedTimePlayRate(duration, compressedTimeTarget);
              state.setCurrentPlaySpeed('compressed');
              didSkip = true;
              break;
          }
        } else {
          state.clearAppliedSkipRecord();
          // Now stop any acceleration from a skip, and return to whatever speed the user was viewing with before the skip started.
          state.setCurrentPlaySpeed(userChoicePlaySpeed);
        }
        if (didSkip || changedSpeed) {
          graffiti.updateControlPanels();
          audio.updateAudioPlaybackRate();
        }
        return didSkip;
      },

      pausePlaybackNoVisualUpdates: () => {
        if (state.getActivity() === 'playing') {
          graffiti.changeActivity('playbackPaused');
          audio.pausePlayback();
          //console.log('Graffiti: pausePlaybackNoVisualUpdates');
          state.setPlayTimeEnd();
          // Make sure, if some markdown was selected, that the active code_mirror textarea reengages to get keystrokes.
          graffiti.updateSelectedCellSelections(graffiti.sitePanel.scrollTop()); 
          state.updateUsageStats({
            type:'play',
            data: {
              actions: ['updateCurrentPlayTime']
            }
          });
        }
      },

      // Pause any ongoing playback
      pausePlayback: () => {
        if (state.getActivity() !== 'playing')
          return;

        graffiti.pausePlaybackNoVisualUpdates();
        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();
        state.clearAnimationIntervals();
        utils.saveNotebook(() => {
          console.log('Graffiti: Stopped playback.');
        });
      },

      cancelPlaybackNoVisualUpdates: () => {
        const accessLevel = state.getAccessLevel();
        graffiti.pausePlaybackNoVisualUpdates();
        state.updateUsageStats({
          type:'play',
          data: {
            actions: ['updateTotalPlayTime']
          }
        });
        state.resetPlayState();
        graffiti.changeActivity('idle');

        // Saving and restoring the scroll top is a bit of hack.
        const currentScrollTop = graffiti.sitePanel.scrollTop();

        if (state.getDontRestoreCellContentsAfterPlayback()) {
          console.log('Graffiti: not restoring cell contents.');
        } else {
          graffiti.removeCellsAddedByPlaybackOrRecording();
          state.restoreCellStates('contents');
          state.restoreCellStates('selections');
          state.restoreLineNumbersStates();
        }
        state.setDontRestoreCellContentsAfterPlayback(false); // make sure by default we restore contents.
        terminalLib.saveOrRestoreTerminalOutputs('restore');  // restore any terminals affected by playback
        utils.saveNotebook();
        graffiti.setSitePanelScrollTop(currentScrollTop); // restore scrollTop because restoring cell contents messes with it

        console.log('Graffiti: Got these stats:', state.getUsageStats());
      },

      cancelPlaybackFinish: () => {
        graffiti.resetStickerCanvases();
        graffiti.cancelRapidPlay();
        graffiti.graffitiCursorShell.hide();
        graffiti.clearCanvases('all');
        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips(); 
        graffiti.updateControlPanels();
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.clearJupyterMenuHint();
      },

      cancelPlayback: () => {
        console.log('Graffiti: cancelPlayback called');
        const activity = state.getActivity();
        if ((activity !== 'playing') && (activity !== 'playbackPaused') && (activity !== 'scrubbing')) {
          return;
        }

        console.log('Graffiti: Cancelling playback');
        graffiti.cancelPlaybackNoVisualUpdates();
        state.clearAnimationIntervals();
        state.clearNarratorInfo();
        graffiti.cancelPlaybackFinish();

      },

      startPlayback: () => {
        // Start playback
        const activity = state.getActivity();
        // Prevent playing while playing already. Not sure how this occurs so trapping for it here
        if (activity === 'playing') {
          console.log('Graffiti: Cannot start playing because already playing.');
          return;
        }

        console.log('Graffiti: Starting playback, current activity:', activity);
        if ((activity === 'idle') || (activity === 'notifying') || (activity === 'playbackPending')) {
          // If just starting to play back, store all cells current contents so we can restore them when you cancel playback.
          // utils.saveNotebook();
          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.setCurrentPlaySpeed('regular');
          state.storeUserChoicePlaySpeed('regular');
          state.setSpeakingStatus(false);
          terminalLib.clearTerminalsContentsPositions();
          state.resetPlayTimes();
          graffiti.resetScrollNudge();
          graffiti.updateSlider(0);
          graffiti.placeControlPanel({nearAction:true});
          graffiti.prePlaybackScrolltop = state.getScrollTop();
          graffiti.lastScrollViewId = undefined;
          graffiti.lastDrawIndex = undefined;
          graffiti.lastDrawingEraseIndex = undefined;
          state.storeCellStates();
          state.clearCellOutputsSent();
          terminalLib.saveOrRestoreTerminalOutputs('save');
          graffiti.scrollNudgeAverages = [];
          const stickerImageCandidateUrl = state.getStickerImageCandidateUrl();
          if (stickerImageCandidateUrl !== undefined) {
            state.setStickerImageUrl(stickerImageCandidateUrl);
          } else {
            state.setStickerImageUrl(undefined);
          }
        } else if (activity === 'playbackPaused') {
          graffiti.hideTip(); // immediately hide any tips when resuming play
        }

        if ((activity === 'idle') || (activity === 'notifying') || (activity === 'playbackPaused') || (activity === 'playbackPending')) {
          graffiti.clearCanvases('all');
        }

        graffiti.clearHighlightMarkText();
        graffiti.undimGraffitiCursor();
        graffiti.changeActivity('playing');
        graffiti.lastTemporaryCanvasClearViewIndex = -1;

        if (state.getResetOnNextPlay()) {
          console.log('Graffiti: Resetting for first/re play.');
          graffiti.clearCanvases('all');
          graffiti.wipeAllStickerDomCanvases();
          state.resetPlayState();
          graffiti.removeCellsAddedByPlaybackOrRecording();
          graffiti.applyRawCalculatedScrollTop(0);
        }

        if (state.getCurrentPlaySpeed() === 'scan') {
          state.setPlayTimeBegin('regular'); // all scanning playback starts at regular playback speed initially until speaking starts and ends
        }

        state.setPlaybackStartTime(utils.getNow() - state.getTimePlayedSoFar());
        state.setPlayStartTimeToNow();
        state.updateCurrentSkipRecord();

        if (!state.getMute()) {
          audio.startPlayback(state.getTimePlayedSoFar());
        }

        // Set up main playback loop
        state.startAnimationInterval('playback',        
                                     () => {
                                       const playedSoFar = state.getTimePlayedSoFar();
                                       const endOfPlayableTime = state.getHistoryDuration();
                                       if (playedSoFar >= endOfPlayableTime) {
                                         // reached end of recording naturally, so set up for restart on next press of play button
                                         //console.log('end of recording reached, playedSoFar:', playedSoFar, 'duration', state.getHistoryDuration());
                                         state.setupForReset();
                                         graffiti.togglePlayback();
                                       } else {
                                         if (!graffiti.applyCurrentSkipRecord(playedSoFar)) {
                                           graffiti.updateSlider(playedSoFar);
                                           graffiti.updateTimeDisplay(playedSoFar);
                                           const frameIndexes = state.getHistoryRecordsAtTime(playedSoFar);
                                           graffiti.updateDisplay(frameIndexes);
                                         }
                                         //console.log('play interval, now=', utils.getNow());
                                       }
                                     },
                                     graffiti.playbackIntervalMs);
      },

      togglePlayback: () => {
        const activity = state.getActivity();
        if (activity !== 'recording') {
          if (activity === 'playing') {
            state.clearAnimationIntervals();
            if (state.getHidePlayerAfterPlayback() && state.getSetupForReset()) {
              graffiti.cancelPlayback();
            } else {
              graffiti.pausePlayback();
              //console.log('total play time:', utils.getNow() - playStartedAt);
            }
          } else {
            graffiti.startPlayback();
            playStartedAt = utils.getNow();
            //console.log('started playback at:', playStartedAt);
          }
        }
      },

      // If there is a graffiti that has the autoplayAlways attribute set to true, play it immediately.
      // Otherwise, if there is one with autoplayOnce attribute set to true and it hasn't been played previously, play it immediately.
      playAutoplayGraffiti: () => {
        const manifest = state.getManifest();
        let recordingCellId, recordingKeys, recording, autoplayGraffiti, autoplayedOnce = false;
        for (recordingCellId of Object.keys(manifest)) {
          recordingKeys = Object.keys(manifest[recordingCellId]);
          if (recordingKeys.length > 0) {
            for (recordingKey of recordingKeys) {
              recording = manifest[recordingCellId][recordingKey];
              // console.log('Graffiti autoplay rec:', recording);
              if (recording.autoplay !== undefined) {
                if (autoplayGraffiti === undefined) {
                  if (recording.autoplay === 'always') {
                    autoplayGraffiti = { recordingCellId: recordingCellId, recordingKey: recordingKey };
                  } else if (recording.autoplay === 'once') {
                    if (!recording.playedOnce) {
                      autoplayGraffiti = { recordingCellId: recordingCellId, recordingKey: recordingKey };
                      recording.playedOnce = true;
                      autoplayedOnce = true;
                    }
                  }
                }
              }
            }
          }
        }
        if (autoplayGraffiti !== undefined) {
          graffiti.playRecordingById(autoplayGraffiti.recordingCellId, autoplayGraffiti.recordingKey);
          if (autoplayedOnce) {
            storage.storeManifest();
          }
        }
      },

      playMovieViaUserClick: () => {
        console.log('Graffiti: playMovieViaUserClick starts.');
        const activity = state.getActivity();
        const playableMovie = state.getPlayableMovie('tip');
        console.log('Graffiti: playableMovie', playableMovie);
        if (playableMovie === undefined) {
          console.log('Graffiti: no playable movie known.');
          if (activity !== 'recording') {
            graffiti.changeActivity('idle');
          }
          return;
        }

        if (activity === 'recording') {
          // Allow the first part of a graffiti to fire during recording (not the movie), so that terminal commands and show/hide buttons
          // can be used during recordings.
          // Prevent running the same graffiti you're recording for, however.
          const recordingCellInfo = state.getRecordingCellInfo();
          if (recordingCellInfo !== undefined) {
            if ((recordingCellInfo.recordingCellId == playableMovie.recordingCellId) &&
                (recordingCellInfo.recordingKey == playableMovie.recordingKey)) {
              console.log('Graffiti: not running this graffiti during recording because it is the same one you are recording for:', recordingCellInfo);
              return;
            }
          }
          graffiti.loadAndPlayMovie('tip');
          return;
        } else if (activity === 'playbackPending') {
          console.log('Graffiti: not playing movie via user click because another movie is pending.');
          return; // prevent rapid clicks on graffiti where play_to_click is active.
        } 
        const recording = state.getManifestSingleRecording(playableMovie.recordingCellId, playableMovie.recordingKey);
        if (recording.terminalCommand === undefined) {
          // Cancel any ongoing playback before starting playback, unless this graffiti has a terminal command.
          graffiti.cancelPlayback();
          graffiti.changeActivity('playbackPending');
        }
        if (state.getDontRestoreCellContentsAfterPlayback()) {
          // If this movie is set to NOT restore cell contents, give the user a chance to opt-out of playback.
          const dialogContent = localizer.getString('REPLACE_CONFIRM_BODY_1');
          const modalButtons = {};
          modalButtons[localizer.getString('REPLACE_CONFIRM_BODY_2')] = 
            {
              click: (e) => {
                console.log('Graffiti: you want to preserve cell contents after playback.');
                // Must restore playable movie values because jupyter dialog causes the tip to hide, which clears the playableMovie
                state.setPlayableMovie('tip', playableMovie.recordingCellId, playableMovie.recordingKey);
                state.setDontRestoreCellContentsAfterPlayback(false);
                graffiti.loadAndPlayMovie('tip');
              }
            };
          modalButtons[localizer.getString('REPLACE_CONFIRM_BODY_3')] =
            { 
              click: (e) => { 
                // Must restore playable movie values because jupyter dialog causes the tip to hide, which clears the playableMovie
                state.setPlayableMovie('tip', playableMovie.recordingCellId, playableMovie.recordingKey);
                state.setDontRestoreCellContentsAfterPlayback(true);
                graffiti.loadAndPlayMovie('tip'); 
              }
            };
          const confirmModal = dialog.modal({
            title: localizer.getString('PLAY_CONFIRM'),
            body: dialogContent,
            sanitize:false,
            buttons: modalButtons,
          });
          confirmModal.on('hidden.bs.modal', (e) => { 
            console.log('Graffiti: escaped the dontRestoreCellContents modal.');
          });
        } else {
          graffiti.loadAndPlayMovie('tip');
        }
      },

      executeSaveToFileDirectives: (cellId) => {
        if (cellId !== undefined) {
          const cellIdToGraffitiMap = state.getCellIdToGraffitiMap(cellId);
          if (cellIdToGraffitiMap !== undefined) {
            console.log('Graffiti: executing saveToFile directives for cell id:', cellId);
            const cell = utils.findCellByCellId(cellId);
            const fileContents = cell.get_text();
            let saveToFilePath, i;
            // Loop over all directives and save all files.
            for (i = 0; i < cellIdToGraffitiMap.length; ++i) {
              saveToFilePath = cellIdToGraffitiMap[i];
              console.log('Graffiti: Writing fileContents to saveToFilePath', saveToFilePath);
              storage.writeTextToFile({ path: saveToFilePath,
                                        contents: fileContents,
                                        stripCRs: false });
            }
          }
          storage.cleanUpExecutorCell();
        }
      },

      executeAllSaveToFileDirectives: () => {
        const cells = Jupyter.notebook.get_cells();
        for (let cell of cells) {
          if (cell.cell_type === 'code') {
            const cellId = utils.getMetadataCellId(cell.metadata);
            graffiti.executeSaveToFileDirectives(cellId);
          }
        }        
      },

      executeInsertDataFromFile: (recordingCellId, recordingKey, recording) => {
        //console.trace('executeInsertDataFromFile');
        const insertDataFromFile = recording.insertDataFromFile;
        const filePath = insertDataFromFile.filePath;
        // Note that we re-use the recording key here. See note below about why.
        const existingCellId = recordingKey;
        const existingCell = utils.findCellByCellId(existingCellId);
        if (existingCell === undefined) {
          return storage.fetchDataFile(filePath).then((contents) => {
            const viewInfo = state.getViewInfo();
            const cellType = insertDataFromFile.cellType;
            const newCell = Jupyter.notebook.insert_cell_below((cellType === undefined ? 'markdown' : cellType), viewInfo.cellIndex);
            // Override the randomly created cell id for this inserted cell with a fixed id based on the recording key. This way, any graffiti
            // recorded for this directive will have a known graffiti cell id to record activity over.  When we start recording a movie
            // for a graffiti with the insertDataFromFile directive, we should run this function first before beginning the movie recording
            // so that we have the cell ready to record from.
            utils.setMetadataCellId(newCell.metadata, existingCellId);
            utils.refreshCellMaps();
            newCell.set_text(contents);
            newCell.render();
            return Promise.resolve(true);
          }).catch((ex) => {
            console.log('Graffiti: executeInsertDataFromFile is unable to fetch data from path:', filePath);
            dialog.modal({
              title: localizer.getString('FILE_UNAVAILABLE') + ' : ' + filePath,
              body:  localizer.getString('FILE_UNAVAILABLE_EXPLANATION'),
              sanitize:false,
              buttons: {
                'OK': {
                  click: (e) => { 
                    console.log('Graffiti: Missing file acknowledged.'); 
                  }
                }
              }
            });
            return Promise.reject();
          });
        } else {
          const existingCellIndex = utils.findCellIndexByCellId(existingCellId);
          if (existingCellIndex !== undefined) {
            Jupyter.notebook.delete_cell(existingCellIndex);
            return Promise.resolve(false); // false indicates we did not insert a new cell
          }
        }
      },

      // Execute any "label swaps" on graffiti clicks.  This is smart enough to distinguish graffiti buttons from other graffiti.
      executeLabelSwaps: (recording, recordingCellId, recordingKey, insertedData) => {
        if (recording.swappingLabels === true) {
          if ((recording.labelSwaps !== undefined) && (recording.labelSwaps.length === 2)) {
            const viewInfo = state.getViewInfo();
            const hoverCellId = viewInfo.cellId;
            const hoverCellIndex = viewInfo.cellIndex;
            const hoverCell = utils.findCellByCellId(hoverCellId);
            if (hoverCell.cell_type !== 'markdown') {
              return Promise.reject(); // we cannot do label swaps on code cells
            }
            Jupyter.notebook.select(hoverCellIndex);
            const hoverCellText = hoverCell.get_text();
            const tagClass = 'graffiti-' + recordingCellId + '-' + recordingKey;
            const startTag = '<span class="graffiti-highlight ' + tagClass + '">';
            const startPos = hoverCellText.indexOf(startTag);
            if (startPos >= 0) {
              const endTag = '</span>';
              endPos = hoverCellText.indexOf(endTag, startPos);
              const startPastTag = startPos + startTag.length;
              let currentLabel = hoverCellText.substr(startPastTag, endPos - startPastTag);
              const buttonMatch = currentLabel.match(/(<i><\/i><button>)(.*?)(<\/button>)/);
              if (buttonMatch !== null) {
                currentLabel = buttonMatch[2];
              }
              currentLabel = recording.labelSwaps[0];
              if (insertedData) {
                currentLabel = recording.labelSwaps[1];
              }
              const newContents = hoverCellText.substr(0, startPastTag) + 
                                     (buttonMatch !== null ? buttonMatch[1] : '') +
                                  currentLabel +
                                     (buttonMatch !== null ? buttonMatch[3] : '') +
                                  hoverCellText.substr(endPos);
              hoverCell.set_text(newContents);
              hoverCell.render();
              graffiti.refreshAllGraffitiHighlights();
              const hoverCellElement = hoverCell.element[0];
              const swappedButtonDOM = $(hoverCellElement).find('.' + tagClass);
              graffiti.refreshGraffitiTooltipsCore(swappedButtonDOM, 'mouseenter'); // simulate a mouseenter event so that the new button gets bound
            }
          }
        }
        return Promise.resolve(insertedData);
      },

      cleanupAfterLoadAndPlayDidNotPlay: () => {
        const activity = state.getActivity();
        if (activity === 'playbackPending') {
          graffiti.clearJupyterMenuHint();
          graffiti.changeActivity('idle');
          state.setDontRestoreCellContentsAfterPlayback(false);
          graffiti.refreshAllGraffitiHighlights();
          graffiti.refreshGraffitiTooltips(); 
          graffiti.updateControlPanels();
        }
      },

      startLoadedMovie: (recording, playableMovie) => {
        console.log('Graffiti: Movie loaded for cellId, recordingKey:', playableMovie.recordingCellId, playableMovie.recordingKey);

        state.setCurrentlyPlayingMovie(playableMovie);
        state.setNarratorInfo('name', recording.narratorName);
        state.setNarratorInfo('picture', recording.narratorPicture);
        state.setSkipInfo(recording.skipInfo);
        state.clearScaleCursorWithWindow();
        if (recording.scaleCursorWithWindow) {
          state.setScaleCursorWithWindow();
        }
        state.setTotalSkipTimeForRecording();
        if ((playableMovie.cell !== undefined) && (playableMovie.cellType === 'markdown')) {
          playableMovie.cell.render(); // always render a markdown cell first before playing a movie on a graffiti inside it
        }
        state.updateUsageStats({
          type: 'setup',
          data: {
            cellId:        playableMovie.recordingCellId,
            recordingKey:  playableMovie.recordingKey,
            activeTakeId:  playableMovie.activeTakeId,
          }
        });            
        state.updateUsageStats({
          type:'play',
          data: {
            actions: ['resetCurrentPlayTime', 'incrementPlayCount']
          }
        });
        graffiti.togglePlayback();
        graffiti.hideTip();
      },

      loadAndPlayMovie: (kind) => {
        const playableMovie = state.getPlayableMovie(kind);
        if (playableMovie === undefined) {
          console.log('Graffiti: no playable movie defined.');
          return;
        }

        console.log('Graffiti: playableMovie:', playableMovie);

        const activity = state.getActivity();
        const recording = state.getManifestSingleRecording(playableMovie.recordingCellId, playableMovie.recordingKey);
        const fireUpMovie = () => {
          if (activity === 'recording') {
            return;
            // Don't start any movie if in the middle of a recording session. Bailing early means that we can fire up
            // graffiti that have movies without starting the movie, so that we can run terminal commands and show/hide+insertDataFromfile
            // rigs while recording.
          }

          // Default is now to only replay cells involved in the recording (that got focus, selection, were drawn on, etc, but not moused over)
          if (recording.replayAllCells === true) {
            state.setShouldUpdateCellContentsDuringPlayback(true);
          } else { // if false or undefined, only update cells affected by the recording
            state.setShouldUpdateCellContentsDuringPlayback(false);
          }

          $('#graffiti-movie-play-btn').html('<i>' + localizer.getString('LOADING') + '</i>').prop('disabled',true);
          const historyData = state.getFromMovieCache('history', playableMovie);
          const audioData   = state.getFromMovieCache('audio',   playableMovie);
          if ((historyData !== undefined) && (audioData !== undefined)) {
            //console.log('historyData:', historyData.terminalsContents['id_za35048']);
            state.setHistory(historyData);
            audio.setRecordedAudio(audioData);
            graffiti.startLoadedMovie(recording, playableMovie);
          } else {
            storage.fetchMovie(playableMovie).then( (movieData) => {
              state.setHistory(movieData.history);
              audio.setRecordedAudio(movieData.audio);
              graffiti.startLoadedMovie(recording, playableMovie);
            }).catch( (ex) => {
              graffiti.cleanupAfterLoadAndPlayDidNotPlay();
              if (!(recording.silenceWarnings === true)) {
                dialog.modal({
                  title: localizer.getString('MOVIE_UNAVAILABLE'),
                  body:  localizer.getString('MOVIE_UNAVAILABLE_EXPLANATION'),
                  sanitize:false,
                  buttons: {
                    'OK': {
                      click: (e) => { 
                        console.log('Graffiti: Missing movie acknowledged.'); 
                      }
                    }
                  }
                });
              }
              console.log('Graffiti: could not load movie:', ex);
            });
          }
        };


        if (recording.terminalCommand !== undefined) {
          const terminalCommand = recording.terminalCommand;
          terminalLib.runTerminalCommand(terminalCommand.terminalId, terminalCommand.command, true);

          if (activity !== 'recording') {
            graffiti.cleanupAfterLoadAndPlayDidNotPlay(); // clean up *unless* we are recording; then we should just let things keep going.
          }
          
          state.updateUsageStats({
            type: 'terminalCommand',
            data: {
              cellId:        playableMovie.recordingCellId,
              recordingKey:  playableMovie.recordingKey,
              command:       recording.terminalCommand,
            }
          });
          return; // we are done if we ran a terminal command, don't bother to load any movies for playback.
        }

        // Execute any "insert data from file" directives.
        if (recording.insertDataFromFile !== undefined) {
          graffiti.executeInsertDataFromFile(playableMovie.recordingCellId, 
                                             playableMovie.recordingKey,
                                             recording)
                  .then((results) => {
                    return graffiti.executeLabelSwaps(recording, playableMovie.recordingCellId, playableMovie.recordingKey, results);
                  })
                  .then((results) => {
                    if (results) {
                      fireUpMovie(); // do not play a movie unless we actually inserted content with insertDataFromFile.
                    } else {
                      graffiti.cleanupAfterLoadAndPlayDidNotPlay();
                    }
                  }).catch(() => {
                    console.log('Graffiti: could not run executeInsertDataFromFile.');
                    graffiti.cleanupAfterLoadAndPlayDidNotPlay();
                  });
        } else {
          // There are no insertDataFromFile directives, so just start the movie.
          fireUpMovie();
        }
      },

      playRecordingById: (recordingCellId, recordingKey) => {
        const recording = state.setPlayableMovie('api', recordingCellId, recordingKey);
        if (recording !== undefined) {
          graffiti.loadAndPlayMovie('api');
        } else {
          // Putting an error message in console for this failure mode is gentler than the dialog box put up by loadAndPlayMovie(),
          // because if we are being called by an autoplay movie that was on a delete cell, the
          // endless dialog boxes would drive the user crazy (because they could not remove the graffiti from our manifest)
          console.log('Graffiti: not playing movie ' + recordingCellId + ':' + recordingKey + ', as it was not available.');
        }
      },      

      playRecordingByIdString: (recordingFullId) => {
        const parts = utils.parseRecordingFullId(recordingFullId);
        graffiti.playRecordingById(parts.recordingCellId, parts.recordingKey);
      },

      playRecordingByIdWithPrompt: (recordingFullId, promptMarkdown) => {
        graffiti.changeActivity('notifying');
        const promptHtml = '<span>' + utils.renderMarkdown(promptMarkdown) + '</span>';
        
        graffiti.setNotifier('<div id="graffiti-notifier-prompt">' + promptHtml + '</div>',
                             [
                               {
                                 ids: ['graffiti-notifier-prompt'],
                                 event: 'click',
                                 fn: (e) => {
                                   graffiti.playRecordingByIdString(recordingFullId);
                                 }
                               }
                             ]);
      },

      activateAudio: () => {
        if (!state.getAudioInitialized()) {
          audio.init({
            succeed: () => {
              state.setAudioInitialized();
            },
            fail: () => {
              dialog.modal({
                title: localizer.getString('ACCESS_MICROPHONE_PROMPT'),
                body: localizer.getString('ACCESS_MICROPHONE_ADVISORY'),
                sanitize:false,
                buttons: {
                  'OK': {
                  }
                }
              });
            }
          });
        }
      },

      changeAccessLevel: (level) => {
        if (level === 'create') {
          graffiti.cancelPlayback();
          graffiti.activateAudio(); // we need to activate audio to create the audio object, even if microphone access was previously granted.
          storage.ensureNotebookGetsGraffitiId();
          storage.ensureNotebookGetsFirstAuthorId();
          utils.assignCellIds();
          utils.saveNotebook(() => {
            graffiti.refreshAllGraffitiHighlights();
            graffiti.refreshGraffitiTooltipsDebounced();
          });
        } else {
          graffiti.outerControlPanel.fadeOut(graffiti.panelFadeTime);          
        }
        state.setAccessLevel(level); 
        graffiti.updateControlPanels();
      },

      toggleAccessLevel: (forcedLevel) => {
        let buttonLabel;
        const level = (forcedLevel === undefined ? state.getAccessLevel() : forcedLevel);
        if (forcedLevel !== undefined) {
          if (level === 'create') {
            buttonLabel = localizer.getString('HIDE_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('create');
          } else {
            buttonLabel = localizer.getString('SHOW_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('view');
          }
        } else {
          if (level === 'create') {
            buttonLabel = localizer.getString('SHOW_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('view');
          } else {
            buttonLabel = localizer.getString('HIDE_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('create');
          }
        }
        $('#graffiti-setup-button span:last').text(buttonLabel);
      },

      showCreatorsChooser: () => {
        graffiti.setNotifier(localizer.getString('YOU_CAN_FILTER'));
        graffiti.showControlPanels(['graffiti-notifier','graffiti-creators-chooser']);
      },

      transferGraffitis: () => {
        storage.transferGraffitis().then(() => {
          dialog.modal({
            title: 'Transfer Complete',
            body: 'Your Notebook\'s Graffitis have been copied over from the original notebook. ' +
                  'Now you can modify them (or add and remove Graffitis to this notebook),  without affecting the original notebook\'s Graffitis.',
            sanitize:false,
            buttons: {
              'OK': {
                click: (e) => {
                  console.log('Graffiti: You clicked ok');
                }
              }
            }
          });
        });
      },

      packageGraffitis: () => {
        storage.packageGraffitis().then((fileName) => {
          dialog.modal({
            title: 'Packaging Complete',
            body: 'Your Notebook\'s Graffitis, and your notebook, have been copied into a archive file.<br><br>' +
                  'Now you can copy and unpack that archive file anywhere Graffiti is supported, using the terminal command: ' +
                  '<code>tar zxf ' + fileName + '</code>',
            sanitize:false,
            buttons: {
              'OK': {
                click: (e) => {
                  console.log('Graffiti: You clicked ok');
                }
              }
            }
          });
        });
      },

      updateSetupButton: () => {
        const notebook = Jupyter.notebook;
        const sprayCanIcon = stickerLib.makeSprayCanIcon();
        const workspace = state.getWorkspace();
        const buttonStyleHtml = workspace && workspace.coco 
              ? 'display:inline-block;' : '"display:none;"';
        let buttonLabel, setupForSetup = false;
        let buttonContents = '<div id="graffiti-setup-button" style='+ buttonStyleHtml +' class="btn-group"><button class="btn btn-default" title="' + localizer.getString('ENABLE_GRAFFITI') + '">';

        if (!notebook.metadata.hasOwnProperty('graffiti')) {
          // This notebook has never been graffiti-ized, or it just got un-graffiti-ized
          const existingSetupButton = $('#graffiti-setup-button');
          if (existingSetupButton.length > 0) {
            existingSetupButton.remove();
          }
          buttonLabel = localizer.getString('ACTIVATE_GRAFFITI');
          setupForSetup = true;
        } else {
          // This notebook has already been graffiti-ized. Render the setup button for view mode,
          // which is the default mode to start.
          buttonLabel = localizer.getString('SHOW_GRAFFITI_EDITOR');
        }
        const setupButtonDiv = $(buttonContents + '<span>' + buttonLabel + '</div></button></span>');
        const jupyterMainToolbar = $('#maintoolbar-container');
        setupButtonDiv.appendTo(jupyterMainToolbar);
        $('#graffiti-setup-button button').prepend(sprayCanIcon);
        if (setupForSetup) {
          $('#graffiti-setup-button').click(() => {
            graffiti.firstTimeSetup();
          });
        } else {
          $('#graffiti-setup-button').click(() => {
            graffiti.toggleAccessLevel();
          });
        }
      },

      firstTimeSetup: () => {
        dialog.modal({
          title: localizer.getString('ACTIVATE_GRAFFITI_CONFIRM'),
          body: localizer.getString('ACTIVATE_GRAFFITI_ADVISORY'),
          sanitize:false,
          buttons: {
            'OK': {
              click: (e) => {
                console.log('Graffiti: You clicked ok');
                storage.ensureNotebookGetsGraffitiId();
                storage.ensureNotebookGetsFirstAuthorId();
                utils.saveNotebook(() => {
                  utils.createApiSymlink();
                  graffiti.initInteractivity();
                  graffiti.toggleAccessLevel('view');
                  graffiti.activateAudio(); // request microphone access in case switching to 'create' mode later
                  $('#graffiti-setup-button').unbind('click').click(() => {
                    graffiti.toggleAccessLevel();
                  });
                });
              }
            },
            'Cancel': {
              click: (e) => {
                console.log('Graffiti: Not adding Graffiti.');
              }
            }
          }
        });
      },
    };


    // Functions exposed externally to the Python API.
    return {
      init: graffiti.init,
      graffiti:graffiti, // remove me
      state: state, // remove me
      playRecordingById: (recordingFullId) => { graffiti.playRecordingByIdString(recordingFullId) },
      playRecordingByIdWithPrompt: (recordingFullId, promptMarkdown) => { graffiti.playRecordingByIdWithPrompt(recordingFullId, promptMarkdown) },
      cancelPlayback: () => { graffiti.cancelPlayback() },
      removeUnusedTakes: (recordingFullId) => { graffiti.removeUnusedTakesWithConfirmation(recordingFullId) },
      removeAllUnusedTakes: () => { graffiti.removeAllUnusedTakesWithConfirmation() },
      removeAllGraffiti:  graffiti.removeAllGraffitisWithConfirmation,
      disableGraffiti: graffiti.disableGraffitiWithConfirmation,
      setAccessLevel: (level) => { graffiti.toggleAccessLevel(level) },
      transferGraffitis: () => { graffiti.transferGraffitis() },
      packageGraffitis: () => { graffiti.packageGraffitis() },
      getUsageStats: () => { return state.getUsageStats() },
      selectionSerializer: selectionSerializer,
      controlTerminal: (opts) => { graffiti.controlTerminal(opts) },
      // showCreatorsChooser: graffiti.showCreatorsChooser, // demo only
    }

  })();

  return Graffiti;

});

// affected files
//      modified:   js/graffiti.js
//	modified:   js/loader.js
//	modified:   js/state.js
//	modified:   js/storage.js
//	modified:   js/utils.js
;
/*
  Used in api.py when importing graffiti as python module.
  Notice that unlike main.js this doesn't return  "load_ipython_extension" call
*/

define('js/loader.js',[], () => {
  if (window.Graffiti !== undefined) {
    console.log('Graffiti already instantiated, not reinitializing');
    return;
  }
  require(['js/initExtension.js']);
});

/*
   Used by main.js and loader.js 
 */

define('js/initExtension.js',[
  'base/js/namespace',
  'js/graffiti.js',
  'js/utils.js',
  'js/state.js',
  'js/workspace.js'
], (Jupyter, Graffiti, utils, state, workspace) => {
  console.log('Graffiti loaded:', Graffiti);

  const initGraffiti = () => { 
    state.init();
    workspace.setWorkspace()
    .then(() => Graffiti.init());
  }

  // This ensures Jupyter.kernel.execute works
  const waitForKernelToBeReady = () => {
    window.Graffiti = Graffiti;
    
    if (Jupyter.notebook.kernel) {
      initGraffiti();
    } else {
      Jupyter.notebook.events.on('kernel_ready.Kernel', (e) => {
        console.log('Graffiti: kernel ready, possible kernel restart.', e);
        console.log('Graffiti: Reloading loader.js');
        // Prevent double initialization
        if (!state.getActivity()) {
          initGraffiti();
        }
        require(['js/loader.js']);
        utils.saveNotebook();
      });
    }
  }

  // the notebook may have fully loaded before the nbextension gets loaded
  // so the nbextension would miss the `notebook_loaded.Notebook` event
  if (Jupyter.notebook._fully_loaded) {
    console.log('Graffiti: Notebook is already fully loaded.');
    waitForKernelToBeReady();
  } else {
    Jupyter.notebook.events.on('notebook_loaded.Notebook', (e) => {
      console.log('Graffiti: Notebook is loaded.');
      waitForKernelToBeReady();
    })
  } 
});

// Mark Graffiti as about to load, because extension should always get precedence over python API library
// in case that is also going to be loaded by Jupyter.

window.Graffiti = null; 

define('nbextensions/graffiti-dist/graffiti',[], () => {
  return {
    load_ipython_extension: () => {
      require(['js/initExtension.js']);
    }
  };
});

